import {
  __commonJS
} from "./chunk-TYRVL62N.js";

// node_modules/turf-helpers/index.js
var require_turf_helpers = __commonJS({
  "node_modules/turf-helpers/index.js"(exports, module) {
    function feature(geometry, properties) {
      return {
        type: "Feature",
        properties: properties || {},
        geometry
      };
    }
    module.exports.feature = feature;
    module.exports.point = function(coordinates, properties) {
      if (!Array.isArray(coordinates))
        throw new Error("Coordinates must be an array");
      if (coordinates.length < 2)
        throw new Error("Coordinates must be at least 2 numbers long");
      return feature({
        type: "Point",
        coordinates: coordinates.slice()
      }, properties);
    };
    module.exports.polygon = function(coordinates, properties) {
      if (!coordinates)
        throw new Error("No coordinates passed");
      for (var i2 = 0; i2 < coordinates.length; i2++) {
        var ring = coordinates[i2];
        if (ring.length < 4) {
          throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.");
        }
        for (var j = 0; j < ring[ring.length - 1].length; j++) {
          if (ring[ring.length - 1][j] !== ring[0][j]) {
            throw new Error("First and last Position are not equivalent.");
          }
        }
      }
      return feature({
        type: "Polygon",
        coordinates
      }, properties);
    };
    module.exports.lineString = function(coordinates, properties) {
      if (!coordinates) {
        throw new Error("No coordinates passed");
      }
      return feature({
        type: "LineString",
        coordinates
      }, properties);
    };
    module.exports.featureCollection = function(features) {
      return {
        type: "FeatureCollection",
        features
      };
    };
    module.exports.multiLineString = function(coordinates, properties) {
      if (!coordinates) {
        throw new Error("No coordinates passed");
      }
      return feature({
        type: "MultiLineString",
        coordinates
      }, properties);
    };
    module.exports.multiPoint = function(coordinates, properties) {
      if (!coordinates) {
        throw new Error("No coordinates passed");
      }
      return feature({
        type: "MultiPoint",
        coordinates
      }, properties);
    };
    module.exports.multiPolygon = function(coordinates, properties) {
      if (!coordinates) {
        throw new Error("No coordinates passed");
      }
      return feature({
        type: "MultiPolygon",
        coordinates
      }, properties);
    };
    module.exports.geometryCollection = function(geometries, properties) {
      return feature({
        type: "GeometryCollection",
        geometries
      }, properties);
    };
    var factors = {
      miles: 3960,
      nauticalmiles: 3441.145,
      degrees: 57.2957795,
      radians: 1,
      inches: 250905600,
      yards: 6969600,
      meters: 6373e3,
      metres: 6373e3,
      kilometers: 6373,
      kilometres: 6373
    };
    module.exports.radiansToDistance = function(radians, units) {
      var factor = factors[units || "kilometers"];
      if (factor === void 0) {
        throw new Error("Invalid unit");
      }
      return radians * factor;
    };
    module.exports.distanceToRadians = function(distance, units) {
      var factor = factors[units || "kilometers"];
      if (factor === void 0) {
        throw new Error("Invalid unit");
      }
      return distance / factor;
    };
    module.exports.distanceToDegrees = function(distance, units) {
      var factor = factors[units || "kilometers"];
      if (factor === void 0) {
        throw new Error("Invalid unit");
      }
      return distance / factor * 57.2958;
    };
  }
});

// node_modules/turf-tin/index.js
var require_turf_tin = __commonJS({
  "node_modules/turf-tin/index.js"(exports, module) {
    var polygon = require_turf_helpers().polygon;
    var featurecollection = require_turf_helpers().featureCollection;
    module.exports = function(points, z) {
      return featurecollection(triangulate(points.features.map(function(p) {
        var point = {
          x: p.geometry.coordinates[0],
          y: p.geometry.coordinates[1]
        };
        if (z)
          point.z = p.properties[z];
        return point;
      })).map(function(triangle) {
        return polygon([[
          [triangle.a.x, triangle.a.y],
          [triangle.b.x, triangle.b.y],
          [triangle.c.x, triangle.c.y],
          [triangle.a.x, triangle.a.y]
        ]], {
          a: triangle.a.z,
          b: triangle.b.z,
          c: triangle.c.z
        });
      }));
    };
    function Triangle(a, b, c) {
      this.a = a;
      this.b = b;
      this.c = c;
      var A = b.x - a.x, B = b.y - a.y, C = c.x - a.x, D = c.y - a.y, E = A * (a.x + b.x) + B * (a.y + b.y), F = C * (a.x + c.x) + D * (a.y + c.y), G = 2 * (A * (c.y - b.y) - B * (c.x - b.x)), minx, miny, dx, dy;
      if (Math.abs(G) < 1e-6) {
        minx = Math.min(a.x, b.x, c.x);
        miny = Math.min(a.y, b.y, c.y);
        dx = (Math.max(a.x, b.x, c.x) - minx) * 0.5;
        dy = (Math.max(a.y, b.y, c.y) - miny) * 0.5;
        this.x = minx + dx;
        this.y = miny + dy;
        this.r = dx * dx + dy * dy;
      } else {
        this.x = (D * E - B * F) / G;
        this.y = (A * F - C * E) / G;
        dx = this.x - a.x;
        dy = this.y - a.y;
        this.r = dx * dx + dy * dy;
      }
    }
    function byX(a, b) {
      return b.x - a.x;
    }
    function dedup(edges) {
      var j = edges.length, a, b, i2, m, n;
      outer:
        while (j) {
          b = edges[--j];
          a = edges[--j];
          i2 = j;
          while (i2) {
            n = edges[--i2];
            m = edges[--i2];
            if (a === m && b === n || a === n && b === m) {
              edges.splice(j, 2);
              edges.splice(i2, 2);
              j -= 2;
              continue outer;
            }
          }
        }
    }
    function triangulate(vertices) {
      if (vertices.length < 3)
        return [];
      vertices.sort(byX);
      var i2 = vertices.length - 1, xmin = vertices[i2].x, xmax = vertices[0].x, ymin = vertices[i2].y, ymax = ymin;
      while (i2--) {
        if (vertices[i2].y < ymin)
          ymin = vertices[i2].y;
        if (vertices[i2].y > ymax)
          ymax = vertices[i2].y;
      }
      var dx = xmax - xmin, dy = ymax - ymin, dmax = dx > dy ? dx : dy, xmid = (xmax + xmin) * 0.5, ymid = (ymax + ymin) * 0.5, open = [
        new Triangle(
          {
            x: xmid - 20 * dmax,
            y: ymid - dmax,
            __sentinel: true
          },
          {
            x: xmid,
            y: ymid + 20 * dmax,
            __sentinel: true
          },
          {
            x: xmid + 20 * dmax,
            y: ymid - dmax,
            __sentinel: true
          }
        )
      ], closed = [], edges = [], j, a, b;
      i2 = vertices.length;
      while (i2--) {
        edges.length = 0;
        j = open.length;
        while (j--) {
          dx = vertices[i2].x - open[j].x;
          if (dx > 0 && dx * dx > open[j].r) {
            closed.push(open[j]);
            open.splice(j, 1);
            continue;
          }
          dy = vertices[i2].y - open[j].y;
          if (dx * dx + dy * dy > open[j].r)
            continue;
          edges.push(
            open[j].a,
            open[j].b,
            open[j].b,
            open[j].c,
            open[j].c,
            open[j].a
          );
          open.splice(j, 1);
        }
        dedup(edges);
        j = edges.length;
        while (j) {
          b = edges[--j];
          a = edges[--j];
          open.push(new Triangle(a, b, vertices[i2]));
        }
      }
      Array.prototype.push.apply(closed, open);
      i2 = closed.length;
      while (i2--)
        if (closed[i2].a.__sentinel || closed[i2].b.__sentinel || closed[i2].c.__sentinel)
          closed.splice(i2, 1);
      return closed;
    }
  }
});

// node_modules/turf-invariant/index.js
var require_turf_invariant = __commonJS({
  "node_modules/turf-invariant/index.js"(exports, module) {
    function getCoord(obj) {
      if (Array.isArray(obj) && typeof obj[0] === "number" && typeof obj[1] === "number") {
        return obj;
      } else if (obj) {
        if (obj.type === "Feature" && obj.geometry && obj.geometry.type === "Point" && Array.isArray(obj.geometry.coordinates)) {
          return obj.geometry.coordinates;
        } else if (obj.type === "Point" && Array.isArray(obj.coordinates)) {
          return obj.coordinates;
        }
      }
      throw new Error("A coordinate, feature, or point geometry is required");
    }
    function geojsonType(value, type, name) {
      if (!type || !name)
        throw new Error("type and name required");
      if (!value || value.type !== type) {
        throw new Error("Invalid input to " + name + ": must be a " + type + ", given " + value.type);
      }
    }
    function featureOf(feature, type, name) {
      if (!name)
        throw new Error(".featureOf() requires a name");
      if (!feature || feature.type !== "Feature" || !feature.geometry) {
        throw new Error("Invalid input to " + name + ", Feature with geometry required");
      }
      if (!feature.geometry || feature.geometry.type !== type) {
        throw new Error("Invalid input to " + name + ": must be a " + type + ", given " + feature.geometry.type);
      }
    }
    function collectionOf(featurecollection, type, name) {
      if (!name)
        throw new Error(".collectionOf() requires a name");
      if (!featurecollection || featurecollection.type !== "FeatureCollection") {
        throw new Error("Invalid input to " + name + ", FeatureCollection required");
      }
      for (var i2 = 0; i2 < featurecollection.features.length; i2++) {
        var feature = featurecollection.features[i2];
        if (!feature || feature.type !== "Feature" || !feature.geometry) {
          throw new Error("Invalid input to " + name + ", Feature with geometry required");
        }
        if (!feature.geometry || feature.geometry.type !== type) {
          throw new Error("Invalid input to " + name + ": must be a " + type + ", given " + feature.geometry.type);
        }
      }
    }
    module.exports.geojsonType = geojsonType;
    module.exports.collectionOf = collectionOf;
    module.exports.featureOf = featureOf;
    module.exports.getCoord = getCoord;
  }
});

// node_modules/turf-inside/index.js
var require_turf_inside = __commonJS({
  "node_modules/turf-inside/index.js"(exports, module) {
    var invariant = require_turf_invariant();
    module.exports = function input(point, polygon) {
      var pt = invariant.getCoord(point);
      var polys = polygon.geometry.coordinates;
      if (polygon.geometry.type === "Polygon")
        polys = [polys];
      for (var i2 = 0, insidePoly = false; i2 < polys.length && !insidePoly; i2++) {
        if (inRing(pt, polys[i2][0])) {
          var inHole = false;
          var k = 1;
          while (k < polys[i2].length && !inHole) {
            if (inRing(pt, polys[i2][k])) {
              inHole = true;
            }
            k++;
          }
          if (!inHole)
            insidePoly = true;
        }
      }
      return insidePoly;
    };
    function inRing(pt, ring) {
      var isInside = false;
      for (var i2 = 0, j = ring.length - 1; i2 < ring.length; j = i2++) {
        var xi = ring[i2][0], yi = ring[i2][1];
        var xj = ring[j][0], yj = ring[j][1];
        var intersect = yi > pt[1] !== yj > pt[1] && pt[0] < (xj - xi) * (pt[1] - yi) / (yj - yi) + xi;
        if (intersect)
          isInside = !isInside;
      }
      return isInside;
    }
  }
});

// node_modules/turf-point/index.js
var require_turf_point = __commonJS({
  "node_modules/turf-point/index.js"(exports, module) {
    var isArray = Array.isArray || function(arg) {
      return Object.prototype.toString.call(arg) === "[object Array]";
    };
    module.exports = function(coordinates, properties) {
      if (!isArray(coordinates))
        throw new Error("Coordinates must be an array");
      if (coordinates.length < 2)
        throw new Error("Coordinates must be at least 2 numbers long");
      return {
        type: "Feature",
        geometry: {
          type: "Point",
          coordinates
        },
        properties: properties || {}
      };
    };
  }
});

// node_modules/turf-grid/index.js
var require_turf_grid = __commonJS({
  "node_modules/turf-grid/index.js"(exports, module) {
    var point = require_turf_point();
    module.exports = function(extents, depth) {
      var xmin = extents[0];
      var ymin = extents[1];
      var xmax = extents[2];
      var ymax = extents[3];
      var interval = (xmax - xmin) / depth;
      var coords = [];
      var fc = {
        type: "FeatureCollection",
        features: []
      };
      for (var x = 0; x <= depth; x++) {
        for (var y = 0; y <= depth; y++) {
          fc.features.push(point([x * interval + xmin, y * interval + ymin]));
        }
      }
      return fc;
    };
  }
});

// node_modules/turf-meta/index.js
var require_turf_meta = __commonJS({
  "node_modules/turf-meta/index.js"(exports, module) {
    function coordEach(layer, callback, excludeWrapCoord) {
      var i2, j, k, g, l, geometry, stopG, coords, geometryMaybeCollection, wrapShrink = 0, isGeometryCollection, isFeatureCollection = layer.type === "FeatureCollection", isFeature = layer.type === "Feature", stop = isFeatureCollection ? layer.features.length : 1;
      for (i2 = 0; i2 < stop; i2++) {
        geometryMaybeCollection = isFeatureCollection ? layer.features[i2].geometry : isFeature ? layer.geometry : layer;
        isGeometryCollection = geometryMaybeCollection.type === "GeometryCollection";
        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;
        for (g = 0; g < stopG; g++) {
          geometry = isGeometryCollection ? geometryMaybeCollection.geometries[g] : geometryMaybeCollection;
          coords = geometry.coordinates;
          wrapShrink = excludeWrapCoord && (geometry.type === "Polygon" || geometry.type === "MultiPolygon") ? 1 : 0;
          if (geometry.type === "Point") {
            callback(coords);
          } else if (geometry.type === "LineString" || geometry.type === "MultiPoint") {
            for (j = 0; j < coords.length; j++)
              callback(coords[j]);
          } else if (geometry.type === "Polygon" || geometry.type === "MultiLineString") {
            for (j = 0; j < coords.length; j++)
              for (k = 0; k < coords[j].length - wrapShrink; k++)
                callback(coords[j][k]);
          } else if (geometry.type === "MultiPolygon") {
            for (j = 0; j < coords.length; j++)
              for (k = 0; k < coords[j].length; k++)
                for (l = 0; l < coords[j][k].length - wrapShrink; l++)
                  callback(coords[j][k][l]);
          } else {
            throw new Error("Unknown Geometry Type");
          }
        }
      }
    }
    module.exports.coordEach = coordEach;
    function coordReduce(layer, callback, memo, excludeWrapCoord) {
      coordEach(layer, function(coord) {
        memo = callback(memo, coord);
      }, excludeWrapCoord);
      return memo;
    }
    module.exports.coordReduce = coordReduce;
    function propEach(layer, callback) {
      var i2;
      switch (layer.type) {
        case "FeatureCollection":
          for (i2 = 0; i2 < layer.features.length; i2++) {
            callback(layer.features[i2].properties);
          }
          break;
        case "Feature":
          callback(layer.properties);
          break;
      }
    }
    module.exports.propEach = propEach;
    function propReduce(layer, callback, memo) {
      propEach(layer, function(prop) {
        memo = callback(memo, prop);
      });
      return memo;
    }
    module.exports.propReduce = propReduce;
    function featureEach(layer, callback) {
      if (layer.type === "Feature") {
        callback(layer);
      } else if (layer.type === "FeatureCollection") {
        for (var i2 = 0; i2 < layer.features.length; i2++) {
          callback(layer.features[i2]);
        }
      }
    }
    module.exports.featureEach = featureEach;
    function coordAll(layer) {
      var coords = [];
      coordEach(layer, function(coord) {
        coords.push(coord);
      });
      return coords;
    }
    module.exports.coordAll = coordAll;
  }
});

// node_modules/turf-bbox/index.js
var require_turf_bbox = __commonJS({
  "node_modules/turf-bbox/index.js"(exports, module) {
    var each = require_turf_meta().coordEach;
    module.exports = function(geojson) {
      var bbox = [Infinity, Infinity, -Infinity, -Infinity];
      each(geojson, function(coord) {
        if (bbox[0] > coord[0])
          bbox[0] = coord[0];
        if (bbox[1] > coord[1])
          bbox[1] = coord[1];
        if (bbox[2] < coord[0])
          bbox[2] = coord[0];
        if (bbox[3] < coord[1])
          bbox[3] = coord[1];
      });
      return bbox;
    };
  }
});

// node_modules/turf-planepoint/index.js
var require_turf_planepoint = __commonJS({
  "node_modules/turf-planepoint/index.js"(exports, module) {
    module.exports = function(point, triangle) {
      var x = point.geometry.coordinates[0], y = point.geometry.coordinates[1], x1 = triangle.geometry.coordinates[0][0][0], y1 = triangle.geometry.coordinates[0][0][1], z1 = triangle.properties.a, x2 = triangle.geometry.coordinates[0][1][0], y2 = triangle.geometry.coordinates[0][1][1], z2 = triangle.properties.b, x3 = triangle.geometry.coordinates[0][2][0], y3 = triangle.geometry.coordinates[0][2][1], z3 = triangle.properties.c;
      var z = (z3 * (x - x1) * (y - y2) + z1 * (x - x2) * (y - y3) + z2 * (x - x3) * (y - y1) - z2 * (x - x1) * (y - y3) - z3 * (x - x2) * (y - y1) - z1 * (x - x3) * (y - y2)) / ((x - x1) * (y - y2) + (x - x2) * (y - y3) + (x - x3) * (y - y1) - (x - x1) * (y - y3) - (x - x2) * (y - y1) - (x - x3) * (y - y2));
      return z;
    };
  }
});

// node_modules/turf-distance/index.js
var require_turf_distance = __commonJS({
  "node_modules/turf-distance/index.js"(exports, module) {
    var getCoord = require_turf_invariant().getCoord;
    var radiansToDistance = require_turf_helpers().radiansToDistance;
    module.exports = function(from, to, units) {
      var degrees2radians = Math.PI / 180;
      var coordinates1 = getCoord(from);
      var coordinates2 = getCoord(to);
      var dLat = degrees2radians * (coordinates2[1] - coordinates1[1]);
      var dLon = degrees2radians * (coordinates2[0] - coordinates1[0]);
      var lat1 = degrees2radians * coordinates1[1];
      var lat2 = degrees2radians * coordinates2[1];
      var a = Math.pow(Math.sin(dLat / 2), 2) + Math.pow(Math.sin(dLon / 2), 2) * Math.cos(lat1) * Math.cos(lat2);
      return radiansToDistance(2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)), units);
    };
  }
});

// node_modules/turf-square/index.js
var require_turf_square = __commonJS({
  "node_modules/turf-square/index.js"(exports, module) {
    var distance = require_turf_distance();
    module.exports = function(bbox) {
      var horizontalDistance = distance(bbox.slice(0, 2), [bbox[2], bbox[1]], "miles");
      var verticalDistance = distance(bbox.slice(0, 2), [bbox[0], bbox[3]], "miles");
      if (horizontalDistance >= verticalDistance) {
        var verticalMidpoint = (bbox[1] + bbox[3]) / 2;
        return [
          bbox[0],
          verticalMidpoint - (bbox[2] - bbox[0]) / 2,
          bbox[2],
          verticalMidpoint + (bbox[2] - bbox[0]) / 2
        ];
      } else {
        var horizontalMidpoint = (bbox[0] + bbox[2]) / 2;
        return [
          horizontalMidpoint - (bbox[3] - bbox[1]) / 2,
          bbox[1],
          horizontalMidpoint + (bbox[3] - bbox[1]) / 2,
          bbox[3]
        ];
      }
    };
  }
});

// node_modules/turf-isolines/conrec.js
var require_conrec = __commonJS({
  "node_modules/turf-isolines/conrec.js"(exports, module) {
    module.exports = Conrec;
    var EPSILON = 1e-10;
    function pointsEqual(a, b) {
      var x = a.x - b.x, y = a.y - b.y;
      return x * x + y * y < EPSILON;
    }
    function reverseList(list) {
      var pp = list.head;
      while (pp) {
        var temp = pp.next;
        pp.next = pp.prev;
        pp.prev = temp;
        pp = temp;
      }
      var temp = list.head;
      list.head = list.tail;
      list.tail = temp;
    }
    function ContourBuilder(level) {
      this.level = level;
      this.s = null;
      this.count = 0;
    }
    ContourBuilder.prototype.remove_seq = function(list) {
      if (list.prev) {
        list.prev.next = list.next;
      } else {
        this.s = list.next;
      }
      if (list.next) {
        list.next.prev = list.prev;
      }
      --this.count;
    };
    ContourBuilder.prototype.addSegment = function(a, b) {
      var ss = this.s;
      var ma = null;
      var mb = null;
      var prependA = false;
      var prependB = false;
      while (ss) {
        if (ma == null) {
          if (pointsEqual(a, ss.head.p)) {
            ma = ss;
            prependA = true;
          } else if (pointsEqual(a, ss.tail.p)) {
            ma = ss;
          }
        }
        if (mb == null) {
          if (pointsEqual(b, ss.head.p)) {
            mb = ss;
            prependB = true;
          } else if (pointsEqual(b, ss.tail.p)) {
            mb = ss;
          }
        }
        if (mb != null && ma != null) {
          break;
        } else {
          ss = ss.next;
        }
      }
      var c = (ma != null ? 1 : 0) | (mb != null ? 2 : 0);
      switch (c) {
        case 0:
          var aa = { p: a, prev: null };
          var bb = { p: b, next: null };
          aa.next = bb;
          bb.prev = aa;
          ma = { head: aa, tail: bb, next: this.s, prev: null, closed: false };
          if (this.s) {
            this.s.prev = ma;
          }
          this.s = ma;
          ++this.count;
          break;
        case 1:
          var pp = { p: b };
          if (prependA) {
            pp.next = ma.head;
            pp.prev = null;
            ma.head.prev = pp;
            ma.head = pp;
          } else {
            pp.next = null;
            pp.prev = ma.tail;
            ma.tail.next = pp;
            ma.tail = pp;
          }
          break;
        case 2:
          var pp = { p: a };
          if (prependB) {
            pp.next = mb.head;
            pp.prev = null;
            mb.head.prev = pp;
            mb.head = pp;
          } else {
            pp.next = null;
            pp.prev = mb.tail;
            mb.tail.next = pp;
            mb.tail = pp;
          }
          break;
        case 3:
          if (ma === mb) {
            var pp = { p: ma.tail.p, next: ma.head, prev: null };
            ma.head.prev = pp;
            ma.head = pp;
            ma.closed = true;
            break;
          }
          switch ((prependA ? 1 : 0) | (prependB ? 2 : 0)) {
            case 0:
              reverseList(ma);
            case 1:
              mb.tail.next = ma.head;
              ma.head.prev = mb.tail;
              mb.tail = ma.tail;
              this.remove_seq(ma);
              break;
            case 3:
              reverseList(ma);
            case 2:
              ma.tail.next = mb.head;
              mb.head.prev = ma.tail;
              ma.tail = mb.tail;
              this.remove_seq(mb);
              break;
          }
      }
    };
    function Conrec(drawContour) {
      if (!drawContour) {
        var c = this;
        c.contours = {};
        this.drawContour = function(startX, startY, endX, endY, contourLevel, k) {
          var cb = c.contours[k];
          if (!cb) {
            cb = c.contours[k] = new ContourBuilder(contourLevel);
          }
          cb.addSegment({ x: startX, y: startY }, { x: endX, y: endY });
        };
        this.contourList = function() {
          var l = [];
          var a = c.contours;
          for (var k in a) {
            var s = a[k].s;
            var level = a[k].level;
            while (s) {
              var h = s.head;
              var l2 = [];
              l2.level = level;
              l2.k = k;
              while (h && h.p) {
                l2.push(h.p);
                h = h.next;
              }
              l.push(l2);
              s = s.next;
            }
          }
          l.sort(function(a2, b) {
            return a2.k - b.k;
          });
          return l;
        };
      } else {
        this.drawContour = drawContour;
      }
      this.h = new Array(5);
      this.sh = new Array(5);
      this.xh = new Array(5);
      this.yh = new Array(5);
    }
    Conrec.prototype.contour = function(d, ilb, iub, jlb, jub, x, y, nc, z) {
      var h = this.h, sh = this.sh, xh = this.xh, yh = this.yh;
      var drawContour = this.drawContour;
      this.contours = {};
      var xsect = function(p1, p2) {
        return (h[p2] * xh[p1] - h[p1] * xh[p2]) / (h[p2] - h[p1]);
      };
      var ysect = function(p1, p2) {
        return (h[p2] * yh[p1] - h[p1] * yh[p2]) / (h[p2] - h[p1]);
      };
      var m1;
      var m2;
      var m3;
      var case_value;
      var dmin;
      var dmax;
      var x1 = 0;
      var x2 = 0;
      var y1 = 0;
      var y2 = 0;
      var im = [0, 1, 1, 0];
      var jm = [0, 0, 1, 1];
      var castab = [
        [
          [0, 0, 8],
          [0, 2, 5],
          [7, 6, 9]
        ],
        [
          [0, 3, 4],
          [1, 3, 1],
          [4, 3, 0]
        ],
        [
          [9, 6, 7],
          [5, 2, 0],
          [8, 0, 0]
        ]
      ];
      for (var j = jub - 1; j >= jlb; j--) {
        for (var i2 = ilb; i2 <= iub - 1; i2++) {
          var temp1, temp2;
          temp1 = Math.min(d[i2][j], d[i2][j + 1]);
          temp2 = Math.min(d[i2 + 1][j], d[i2 + 1][j + 1]);
          dmin = Math.min(temp1, temp2);
          temp1 = Math.max(d[i2][j], d[i2][j + 1]);
          temp2 = Math.max(d[i2 + 1][j], d[i2 + 1][j + 1]);
          dmax = Math.max(temp1, temp2);
          if (dmax >= z[0] && dmin <= z[nc - 1]) {
            for (var k = 0; k < nc; k++) {
              if (z[k] >= dmin && z[k] <= dmax) {
                for (var m = 4; m >= 0; m--) {
                  if (m > 0) {
                    h[m] = d[i2 + im[m - 1]][j + jm[m - 1]] - z[k];
                    xh[m] = x[i2 + im[m - 1]];
                    yh[m] = y[j + jm[m - 1]];
                  } else {
                    h[0] = 0.25 * (h[1] + h[2] + h[3] + h[4]);
                    xh[0] = 0.5 * (x[i2] + x[i2 + 1]);
                    yh[0] = 0.5 * (y[j] + y[j + 1]);
                  }
                  if (h[m] > EPSILON) {
                    sh[m] = 1;
                  } else if (h[m] < -EPSILON) {
                    sh[m] = -1;
                  } else
                    sh[m] = 0;
                }
                for (m = 1; m <= 4; m++) {
                  m1 = m;
                  m2 = 0;
                  if (m != 4) {
                    m3 = m + 1;
                  } else {
                    m3 = 1;
                  }
                  case_value = castab[sh[m1] + 1][sh[m2] + 1][sh[m3] + 1];
                  if (case_value != 0) {
                    switch (case_value) {
                      case 1:
                        x1 = xh[m1];
                        y1 = yh[m1];
                        x2 = xh[m2];
                        y2 = yh[m2];
                        break;
                      case 2:
                        x1 = xh[m2];
                        y1 = yh[m2];
                        x2 = xh[m3];
                        y2 = yh[m3];
                        break;
                      case 3:
                        x1 = xh[m3];
                        y1 = yh[m3];
                        x2 = xh[m1];
                        y2 = yh[m1];
                        break;
                      case 4:
                        x1 = xh[m1];
                        y1 = yh[m1];
                        x2 = xsect(m2, m3);
                        y2 = ysect(m2, m3);
                        break;
                      case 5:
                        x1 = xh[m2];
                        y1 = yh[m2];
                        x2 = xsect(m3, m1);
                        y2 = ysect(m3, m1);
                        break;
                      case 6:
                        x1 = xh[m3];
                        y1 = yh[m3];
                        x2 = xsect(m1, m2);
                        y2 = ysect(m1, m2);
                        break;
                      case 7:
                        x1 = xsect(m1, m2);
                        y1 = ysect(m1, m2);
                        x2 = xsect(m2, m3);
                        y2 = ysect(m2, m3);
                        break;
                      case 8:
                        x1 = xsect(m2, m3);
                        y1 = ysect(m2, m3);
                        x2 = xsect(m3, m1);
                        y2 = ysect(m3, m1);
                        break;
                      case 9:
                        x1 = xsect(m3, m1);
                        y1 = ysect(m3, m1);
                        x2 = xsect(m1, m2);
                        y2 = ysect(m1, m2);
                        break;
                      default:
                        break;
                    }
                    drawContour(x1, y1, x2, y2, z[k], k);
                  }
                }
              }
            }
          }
        }
      }
    };
  }
});

// node_modules/turf-isolines/index.js
var require_turf_isolines = __commonJS({
  "node_modules/turf-isolines/index.js"(exports, module) {
    var tin = require_turf_tin();
    var inside = require_turf_inside();
    var grid = require_turf_grid();
    var bbox = require_turf_bbox();
    var planepoint = require_turf_planepoint();
    var featurecollection = require_turf_helpers().featureCollection;
    var linestring = require_turf_helpers().lineString;
    var square = require_turf_square();
    var Conrec = require_conrec();
    module.exports = function(points, z, resolution, breaks) {
      var tinResult = tin(points, z);
      var bboxBBox = bbox(points);
      var squareBBox = square(bboxBBox);
      var gridResult = grid(squareBBox, resolution);
      var data = [];
      for (var i2 = 0; i2 < gridResult.features.length; i2++) {
        var pt = gridResult.features[i2];
        for (var j = 0; j < tinResult.features.length; j++) {
          var triangle = tinResult.features[j];
          if (inside(pt, triangle)) {
            pt.properties = {};
            pt.properties[z] = planepoint(pt, triangle);
          }
        }
      }
      var depth = Math.sqrt(gridResult.features.length);
      for (var x = 0; x < depth; x++) {
        var xGroup = gridResult.features.slice(x * depth, (x + 1) * depth);
        var xFlat = [];
        for (var g = 0; g < xGroup.length; g++) {
          if (xGroup[g].properties) {
            xFlat.push(xGroup[g].properties[z]);
          } else {
            xFlat.push(0);
          }
        }
        data.push(xFlat);
      }
      var interval = (squareBBox[2] - squareBBox[0]) / depth;
      var xCoordinates = [];
      var yCoordinates = [];
      for (var d = 0; d < depth; d++) {
        xCoordinates.push(d * interval + squareBBox[0]);
        yCoordinates.push(d * interval + squareBBox[1]);
      }
      var c = new Conrec();
      c.contour(data, 0, resolution, 0, resolution, xCoordinates, yCoordinates, breaks.length, breaks);
      var contourList = c.contourList();
      var fc = featurecollection([]);
      contourList.forEach(function(c2) {
        if (c2.length > 2) {
          var polyCoordinates = [];
          c2.forEach(function(coord) {
            polyCoordinates.push([coord.x, coord.y]);
          });
          var poly = linestring(polyCoordinates);
          poly.properties = {};
          poly.properties[z] = c2.level;
          fc.features.push(poly);
        }
      });
      return fc;
    };
  }
});

// node_modules/convex-hull/lib/ch1d.js
var require_ch1d = __commonJS({
  "node_modules/convex-hull/lib/ch1d.js"(exports, module) {
    "use strict";
    module.exports = convexHull1d;
    function convexHull1d(points) {
      var lo = 0;
      var hi = 0;
      for (var i2 = 1; i2 < points.length; ++i2) {
        if (points[i2][0] < points[lo][0]) {
          lo = i2;
        }
        if (points[i2][0] > points[hi][0]) {
          hi = i2;
        }
      }
      if (lo < hi) {
        return [[lo], [hi]];
      } else if (lo > hi) {
        return [[hi], [lo]];
      } else {
        return [[lo]];
      }
    }
  }
});

// node_modules/two-product/two-product.js
var require_two_product = __commonJS({
  "node_modules/two-product/two-product.js"(exports, module) {
    "use strict";
    module.exports = twoProduct;
    var SPLITTER = +(Math.pow(2, 27) + 1);
    function twoProduct(a, b, result) {
      var x = a * b;
      var c = SPLITTER * a;
      var abig = c - a;
      var ahi = c - abig;
      var alo = a - ahi;
      var d = SPLITTER * b;
      var bbig = d - b;
      var bhi = d - bbig;
      var blo = b - bhi;
      var err1 = x - ahi * bhi;
      var err2 = err1 - alo * bhi;
      var err3 = err2 - ahi * blo;
      var y = alo * blo - err3;
      if (result) {
        result[0] = y;
        result[1] = x;
        return result;
      }
      return [y, x];
    }
  }
});

// node_modules/robust-sum/robust-sum.js
var require_robust_sum = __commonJS({
  "node_modules/robust-sum/robust-sum.js"(exports, module) {
    "use strict";
    module.exports = linearExpansionSum;
    function scalarScalar(a, b) {
      var x = a + b;
      var bv = x - a;
      var av = x - bv;
      var br = b - bv;
      var ar = a - av;
      var y = ar + br;
      if (y) {
        return [y, x];
      }
      return [x];
    }
    function linearExpansionSum(e, f) {
      var ne = e.length | 0;
      var nf = f.length | 0;
      if (ne === 1 && nf === 1) {
        return scalarScalar(e[0], f[0]);
      }
      var n = ne + nf;
      var g = new Array(n);
      var count = 0;
      var eptr = 0;
      var fptr = 0;
      var abs = Math.abs;
      var ei = e[eptr];
      var ea = abs(ei);
      var fi = f[fptr];
      var fa = abs(fi);
      var a, b;
      if (ea < fa) {
        b = ei;
        eptr += 1;
        if (eptr < ne) {
          ei = e[eptr];
          ea = abs(ei);
        }
      } else {
        b = fi;
        fptr += 1;
        if (fptr < nf) {
          fi = f[fptr];
          fa = abs(fi);
        }
      }
      if (eptr < ne && ea < fa || fptr >= nf) {
        a = ei;
        eptr += 1;
        if (eptr < ne) {
          ei = e[eptr];
          ea = abs(ei);
        }
      } else {
        a = fi;
        fptr += 1;
        if (fptr < nf) {
          fi = f[fptr];
          fa = abs(fi);
        }
      }
      var x = a + b;
      var bv = x - a;
      var y = b - bv;
      var q0 = y;
      var q1 = x;
      var _x, _bv, _av, _br, _ar;
      while (eptr < ne && fptr < nf) {
        if (ea < fa) {
          a = ei;
          eptr += 1;
          if (eptr < ne) {
            ei = e[eptr];
            ea = abs(ei);
          }
        } else {
          a = fi;
          fptr += 1;
          if (fptr < nf) {
            fi = f[fptr];
            fa = abs(fi);
          }
        }
        b = q0;
        x = a + b;
        bv = x - a;
        y = b - bv;
        if (y) {
          g[count++] = y;
        }
        _x = q1 + x;
        _bv = _x - q1;
        _av = _x - _bv;
        _br = x - _bv;
        _ar = q1 - _av;
        q0 = _ar + _br;
        q1 = _x;
      }
      while (eptr < ne) {
        a = ei;
        b = q0;
        x = a + b;
        bv = x - a;
        y = b - bv;
        if (y) {
          g[count++] = y;
        }
        _x = q1 + x;
        _bv = _x - q1;
        _av = _x - _bv;
        _br = x - _bv;
        _ar = q1 - _av;
        q0 = _ar + _br;
        q1 = _x;
        eptr += 1;
        if (eptr < ne) {
          ei = e[eptr];
        }
      }
      while (fptr < nf) {
        a = fi;
        b = q0;
        x = a + b;
        bv = x - a;
        y = b - bv;
        if (y) {
          g[count++] = y;
        }
        _x = q1 + x;
        _bv = _x - q1;
        _av = _x - _bv;
        _br = x - _bv;
        _ar = q1 - _av;
        q0 = _ar + _br;
        q1 = _x;
        fptr += 1;
        if (fptr < nf) {
          fi = f[fptr];
        }
      }
      if (q0) {
        g[count++] = q0;
      }
      if (q1) {
        g[count++] = q1;
      }
      if (!count) {
        g[count++] = 0;
      }
      g.length = count;
      return g;
    }
  }
});

// node_modules/two-sum/two-sum.js
var require_two_sum = __commonJS({
  "node_modules/two-sum/two-sum.js"(exports, module) {
    "use strict";
    module.exports = fastTwoSum;
    function fastTwoSum(a, b, result) {
      var x = a + b;
      var bv = x - a;
      var av = x - bv;
      var br = b - bv;
      var ar = a - av;
      if (result) {
        result[0] = ar + br;
        result[1] = x;
        return result;
      }
      return [ar + br, x];
    }
  }
});

// node_modules/robust-scale/robust-scale.js
var require_robust_scale = __commonJS({
  "node_modules/robust-scale/robust-scale.js"(exports, module) {
    "use strict";
    var twoProduct = require_two_product();
    var twoSum = require_two_sum();
    module.exports = scaleLinearExpansion;
    function scaleLinearExpansion(e, scale) {
      var n = e.length;
      if (n === 1) {
        var ts = twoProduct(e[0], scale);
        if (ts[0]) {
          return ts;
        }
        return [ts[1]];
      }
      var g = new Array(2 * n);
      var q = [0.1, 0.1];
      var t = [0.1, 0.1];
      var count = 0;
      twoProduct(e[0], scale, q);
      if (q[0]) {
        g[count++] = q[0];
      }
      for (var i2 = 1; i2 < n; ++i2) {
        twoProduct(e[i2], scale, t);
        var pq = q[1];
        twoSum(pq, t[0], q);
        if (q[0]) {
          g[count++] = q[0];
        }
        var a = t[1];
        var b = q[1];
        var x = a + b;
        var bv = x - a;
        var y = b - bv;
        q[1] = x;
        if (y) {
          g[count++] = y;
        }
      }
      if (q[1]) {
        g[count++] = q[1];
      }
      if (count === 0) {
        g[count++] = 0;
      }
      g.length = count;
      return g;
    }
  }
});

// node_modules/robust-subtract/robust-diff.js
var require_robust_diff = __commonJS({
  "node_modules/robust-subtract/robust-diff.js"(exports, module) {
    "use strict";
    module.exports = robustSubtract;
    function scalarScalar(a, b) {
      var x = a + b;
      var bv = x - a;
      var av = x - bv;
      var br = b - bv;
      var ar = a - av;
      var y = ar + br;
      if (y) {
        return [y, x];
      }
      return [x];
    }
    function robustSubtract(e, f) {
      var ne = e.length | 0;
      var nf = f.length | 0;
      if (ne === 1 && nf === 1) {
        return scalarScalar(e[0], -f[0]);
      }
      var n = ne + nf;
      var g = new Array(n);
      var count = 0;
      var eptr = 0;
      var fptr = 0;
      var abs = Math.abs;
      var ei = e[eptr];
      var ea = abs(ei);
      var fi = -f[fptr];
      var fa = abs(fi);
      var a, b;
      if (ea < fa) {
        b = ei;
        eptr += 1;
        if (eptr < ne) {
          ei = e[eptr];
          ea = abs(ei);
        }
      } else {
        b = fi;
        fptr += 1;
        if (fptr < nf) {
          fi = -f[fptr];
          fa = abs(fi);
        }
      }
      if (eptr < ne && ea < fa || fptr >= nf) {
        a = ei;
        eptr += 1;
        if (eptr < ne) {
          ei = e[eptr];
          ea = abs(ei);
        }
      } else {
        a = fi;
        fptr += 1;
        if (fptr < nf) {
          fi = -f[fptr];
          fa = abs(fi);
        }
      }
      var x = a + b;
      var bv = x - a;
      var y = b - bv;
      var q0 = y;
      var q1 = x;
      var _x, _bv, _av, _br, _ar;
      while (eptr < ne && fptr < nf) {
        if (ea < fa) {
          a = ei;
          eptr += 1;
          if (eptr < ne) {
            ei = e[eptr];
            ea = abs(ei);
          }
        } else {
          a = fi;
          fptr += 1;
          if (fptr < nf) {
            fi = -f[fptr];
            fa = abs(fi);
          }
        }
        b = q0;
        x = a + b;
        bv = x - a;
        y = b - bv;
        if (y) {
          g[count++] = y;
        }
        _x = q1 + x;
        _bv = _x - q1;
        _av = _x - _bv;
        _br = x - _bv;
        _ar = q1 - _av;
        q0 = _ar + _br;
        q1 = _x;
      }
      while (eptr < ne) {
        a = ei;
        b = q0;
        x = a + b;
        bv = x - a;
        y = b - bv;
        if (y) {
          g[count++] = y;
        }
        _x = q1 + x;
        _bv = _x - q1;
        _av = _x - _bv;
        _br = x - _bv;
        _ar = q1 - _av;
        q0 = _ar + _br;
        q1 = _x;
        eptr += 1;
        if (eptr < ne) {
          ei = e[eptr];
        }
      }
      while (fptr < nf) {
        a = fi;
        b = q0;
        x = a + b;
        bv = x - a;
        y = b - bv;
        if (y) {
          g[count++] = y;
        }
        _x = q1 + x;
        _bv = _x - q1;
        _av = _x - _bv;
        _br = x - _bv;
        _ar = q1 - _av;
        q0 = _ar + _br;
        q1 = _x;
        fptr += 1;
        if (fptr < nf) {
          fi = -f[fptr];
        }
      }
      if (q0) {
        g[count++] = q0;
      }
      if (q1) {
        g[count++] = q1;
      }
      if (!count) {
        g[count++] = 0;
      }
      g.length = count;
      return g;
    }
  }
});

// node_modules/robust-orientation/orientation.js
var require_orientation = __commonJS({
  "node_modules/robust-orientation/orientation.js"(exports, module) {
    "use strict";
    var twoProduct = require_two_product();
    var robustSum = require_robust_sum();
    var robustScale = require_robust_scale();
    var robustSubtract = require_robust_diff();
    var NUM_EXPAND = 5;
    var EPSILON = 11102230246251565e-32;
    var ERRBOUND3 = (3 + 16 * EPSILON) * EPSILON;
    var ERRBOUND4 = (7 + 56 * EPSILON) * EPSILON;
    function orientation_3(sum, prod, scale, sub) {
      return function orientation3Exact2(m0, m1, m2) {
        var p = sum(sum(prod(m1[1], m2[0]), prod(-m2[1], m1[0])), sum(prod(m0[1], m1[0]), prod(-m1[1], m0[0])));
        var n = sum(prod(m0[1], m2[0]), prod(-m2[1], m0[0]));
        var d = sub(p, n);
        return d[d.length - 1];
      };
    }
    function orientation_4(sum, prod, scale, sub) {
      return function orientation4Exact2(m0, m1, m2, m3) {
        var p = sum(sum(scale(sum(prod(m2[1], m3[0]), prod(-m3[1], m2[0])), m1[2]), sum(scale(sum(prod(m1[1], m3[0]), prod(-m3[1], m1[0])), -m2[2]), scale(sum(prod(m1[1], m2[0]), prod(-m2[1], m1[0])), m3[2]))), sum(scale(sum(prod(m1[1], m3[0]), prod(-m3[1], m1[0])), m0[2]), sum(scale(sum(prod(m0[1], m3[0]), prod(-m3[1], m0[0])), -m1[2]), scale(sum(prod(m0[1], m1[0]), prod(-m1[1], m0[0])), m3[2]))));
        var n = sum(sum(scale(sum(prod(m2[1], m3[0]), prod(-m3[1], m2[0])), m0[2]), sum(scale(sum(prod(m0[1], m3[0]), prod(-m3[1], m0[0])), -m2[2]), scale(sum(prod(m0[1], m2[0]), prod(-m2[1], m0[0])), m3[2]))), sum(scale(sum(prod(m1[1], m2[0]), prod(-m2[1], m1[0])), m0[2]), sum(scale(sum(prod(m0[1], m2[0]), prod(-m2[1], m0[0])), -m1[2]), scale(sum(prod(m0[1], m1[0]), prod(-m1[1], m0[0])), m2[2]))));
        var d = sub(p, n);
        return d[d.length - 1];
      };
    }
    function orientation_5(sum, prod, scale, sub) {
      return function orientation5Exact(m0, m1, m2, m3, m4) {
        var p = sum(sum(sum(scale(sum(scale(sum(prod(m3[1], m4[0]), prod(-m4[1], m3[0])), m2[2]), sum(scale(sum(prod(m2[1], m4[0]), prod(-m4[1], m2[0])), -m3[2]), scale(sum(prod(m2[1], m3[0]), prod(-m3[1], m2[0])), m4[2]))), m1[3]), sum(scale(sum(scale(sum(prod(m3[1], m4[0]), prod(-m4[1], m3[0])), m1[2]), sum(scale(sum(prod(m1[1], m4[0]), prod(-m4[1], m1[0])), -m3[2]), scale(sum(prod(m1[1], m3[0]), prod(-m3[1], m1[0])), m4[2]))), -m2[3]), scale(sum(scale(sum(prod(m2[1], m4[0]), prod(-m4[1], m2[0])), m1[2]), sum(scale(sum(prod(m1[1], m4[0]), prod(-m4[1], m1[0])), -m2[2]), scale(sum(prod(m1[1], m2[0]), prod(-m2[1], m1[0])), m4[2]))), m3[3]))), sum(scale(sum(scale(sum(prod(m2[1], m3[0]), prod(-m3[1], m2[0])), m1[2]), sum(scale(sum(prod(m1[1], m3[0]), prod(-m3[1], m1[0])), -m2[2]), scale(sum(prod(m1[1], m2[0]), prod(-m2[1], m1[0])), m3[2]))), -m4[3]), sum(scale(sum(scale(sum(prod(m3[1], m4[0]), prod(-m4[1], m3[0])), m1[2]), sum(scale(sum(prod(m1[1], m4[0]), prod(-m4[1], m1[0])), -m3[2]), scale(sum(prod(m1[1], m3[0]), prod(-m3[1], m1[0])), m4[2]))), m0[3]), scale(sum(scale(sum(prod(m3[1], m4[0]), prod(-m4[1], m3[0])), m0[2]), sum(scale(sum(prod(m0[1], m4[0]), prod(-m4[1], m0[0])), -m3[2]), scale(sum(prod(m0[1], m3[0]), prod(-m3[1], m0[0])), m4[2]))), -m1[3])))), sum(sum(scale(sum(scale(sum(prod(m1[1], m4[0]), prod(-m4[1], m1[0])), m0[2]), sum(scale(sum(prod(m0[1], m4[0]), prod(-m4[1], m0[0])), -m1[2]), scale(sum(prod(m0[1], m1[0]), prod(-m1[1], m0[0])), m4[2]))), m3[3]), sum(scale(sum(scale(sum(prod(m1[1], m3[0]), prod(-m3[1], m1[0])), m0[2]), sum(scale(sum(prod(m0[1], m3[0]), prod(-m3[1], m0[0])), -m1[2]), scale(sum(prod(m0[1], m1[0]), prod(-m1[1], m0[0])), m3[2]))), -m4[3]), scale(sum(scale(sum(prod(m2[1], m3[0]), prod(-m3[1], m2[0])), m1[2]), sum(scale(sum(prod(m1[1], m3[0]), prod(-m3[1], m1[0])), -m2[2]), scale(sum(prod(m1[1], m2[0]), prod(-m2[1], m1[0])), m3[2]))), m0[3]))), sum(scale(sum(scale(sum(prod(m2[1], m3[0]), prod(-m3[1], m2[0])), m0[2]), sum(scale(sum(prod(m0[1], m3[0]), prod(-m3[1], m0[0])), -m2[2]), scale(sum(prod(m0[1], m2[0]), prod(-m2[1], m0[0])), m3[2]))), -m1[3]), sum(scale(sum(scale(sum(prod(m1[1], m3[0]), prod(-m3[1], m1[0])), m0[2]), sum(scale(sum(prod(m0[1], m3[0]), prod(-m3[1], m0[0])), -m1[2]), scale(sum(prod(m0[1], m1[0]), prod(-m1[1], m0[0])), m3[2]))), m2[3]), scale(sum(scale(sum(prod(m1[1], m2[0]), prod(-m2[1], m1[0])), m0[2]), sum(scale(sum(prod(m0[1], m2[0]), prod(-m2[1], m0[0])), -m1[2]), scale(sum(prod(m0[1], m1[0]), prod(-m1[1], m0[0])), m2[2]))), -m3[3])))));
        var n = sum(sum(sum(scale(sum(scale(sum(prod(m3[1], m4[0]), prod(-m4[1], m3[0])), m2[2]), sum(scale(sum(prod(m2[1], m4[0]), prod(-m4[1], m2[0])), -m3[2]), scale(sum(prod(m2[1], m3[0]), prod(-m3[1], m2[0])), m4[2]))), m0[3]), scale(sum(scale(sum(prod(m3[1], m4[0]), prod(-m4[1], m3[0])), m0[2]), sum(scale(sum(prod(m0[1], m4[0]), prod(-m4[1], m0[0])), -m3[2]), scale(sum(prod(m0[1], m3[0]), prod(-m3[1], m0[0])), m4[2]))), -m2[3])), sum(scale(sum(scale(sum(prod(m2[1], m4[0]), prod(-m4[1], m2[0])), m0[2]), sum(scale(sum(prod(m0[1], m4[0]), prod(-m4[1], m0[0])), -m2[2]), scale(sum(prod(m0[1], m2[0]), prod(-m2[1], m0[0])), m4[2]))), m3[3]), scale(sum(scale(sum(prod(m2[1], m3[0]), prod(-m3[1], m2[0])), m0[2]), sum(scale(sum(prod(m0[1], m3[0]), prod(-m3[1], m0[0])), -m2[2]), scale(sum(prod(m0[1], m2[0]), prod(-m2[1], m0[0])), m3[2]))), -m4[3]))), sum(sum(scale(sum(scale(sum(prod(m2[1], m4[0]), prod(-m4[1], m2[0])), m1[2]), sum(scale(sum(prod(m1[1], m4[0]), prod(-m4[1], m1[0])), -m2[2]), scale(sum(prod(m1[1], m2[0]), prod(-m2[1], m1[0])), m4[2]))), m0[3]), scale(sum(scale(sum(prod(m2[1], m4[0]), prod(-m4[1], m2[0])), m0[2]), sum(scale(sum(prod(m0[1], m4[0]), prod(-m4[1], m0[0])), -m2[2]), scale(sum(prod(m0[1], m2[0]), prod(-m2[1], m0[0])), m4[2]))), -m1[3])), sum(scale(sum(scale(sum(prod(m1[1], m4[0]), prod(-m4[1], m1[0])), m0[2]), sum(scale(sum(prod(m0[1], m4[0]), prod(-m4[1], m0[0])), -m1[2]), scale(sum(prod(m0[1], m1[0]), prod(-m1[1], m0[0])), m4[2]))), m2[3]), scale(sum(scale(sum(prod(m1[1], m2[0]), prod(-m2[1], m1[0])), m0[2]), sum(scale(sum(prod(m0[1], m2[0]), prod(-m2[1], m0[0])), -m1[2]), scale(sum(prod(m0[1], m1[0]), prod(-m1[1], m0[0])), m2[2]))), -m4[3]))));
        var d = sub(p, n);
        return d[d.length - 1];
      };
    }
    function orientation(n) {
      var fn = n === 3 ? orientation_3 : n === 4 ? orientation_4 : orientation_5;
      return fn(robustSum, twoProduct, robustScale, robustSubtract);
    }
    var orientation3Exact = orientation(3);
    var orientation4Exact = orientation(4);
    var CACHED = [
      function orientation0() {
        return 0;
      },
      function orientation1() {
        return 0;
      },
      function orientation2(a, b) {
        return b[0] - a[0];
      },
      function orientation3(a, b, c) {
        var l = (a[1] - c[1]) * (b[0] - c[0]);
        var r = (a[0] - c[0]) * (b[1] - c[1]);
        var det = l - r;
        var s;
        if (l > 0) {
          if (r <= 0) {
            return det;
          } else {
            s = l + r;
          }
        } else if (l < 0) {
          if (r >= 0) {
            return det;
          } else {
            s = -(l + r);
          }
        } else {
          return det;
        }
        var tol = ERRBOUND3 * s;
        if (det >= tol || det <= -tol) {
          return det;
        }
        return orientation3Exact(a, b, c);
      },
      function orientation4(a, b, c, d) {
        var adx = a[0] - d[0];
        var bdx = b[0] - d[0];
        var cdx = c[0] - d[0];
        var ady = a[1] - d[1];
        var bdy = b[1] - d[1];
        var cdy = c[1] - d[1];
        var adz = a[2] - d[2];
        var bdz = b[2] - d[2];
        var cdz = c[2] - d[2];
        var bdxcdy = bdx * cdy;
        var cdxbdy = cdx * bdy;
        var cdxady = cdx * ady;
        var adxcdy = adx * cdy;
        var adxbdy = adx * bdy;
        var bdxady = bdx * ady;
        var det = adz * (bdxcdy - cdxbdy) + bdz * (cdxady - adxcdy) + cdz * (adxbdy - bdxady);
        var permanent = (Math.abs(bdxcdy) + Math.abs(cdxbdy)) * Math.abs(adz) + (Math.abs(cdxady) + Math.abs(adxcdy)) * Math.abs(bdz) + (Math.abs(adxbdy) + Math.abs(bdxady)) * Math.abs(cdz);
        var tol = ERRBOUND4 * permanent;
        if (det > tol || -det > tol) {
          return det;
        }
        return orientation4Exact(a, b, c, d);
      }
    ];
    function slowOrient(args) {
      var proc2 = CACHED[args.length];
      if (!proc2) {
        proc2 = CACHED[args.length] = orientation(args.length);
      }
      return proc2.apply(void 0, args);
    }
    function proc(slow, o0, o1, o2, o3, o4, o5) {
      return function getOrientation(a0, a1, a2, a3, a4) {
        switch (arguments.length) {
          case 0:
          case 1:
            return 0;
          case 2:
            return o2(a0, a1);
          case 3:
            return o3(a0, a1, a2);
          case 4:
            return o4(a0, a1, a2, a3);
          case 5:
            return o5(a0, a1, a2, a3, a4);
        }
        var s = new Array(arguments.length);
        for (var i2 = 0; i2 < arguments.length; ++i2) {
          s[i2] = arguments[i2];
        }
        return slow(s);
      };
    }
    function generateOrientationProc() {
      while (CACHED.length <= NUM_EXPAND) {
        CACHED.push(orientation(CACHED.length));
      }
      module.exports = proc.apply(void 0, [slowOrient].concat(CACHED));
      for (var i2 = 0; i2 <= NUM_EXPAND; ++i2) {
        module.exports[i2] = CACHED[i2];
      }
    }
    generateOrientationProc();
  }
});

// node_modules/monotone-convex-hull-2d/index.js
var require_monotone_convex_hull_2d = __commonJS({
  "node_modules/monotone-convex-hull-2d/index.js"(exports, module) {
    "use strict";
    module.exports = monotoneConvexHull2D;
    var orient = require_orientation()[3];
    function monotoneConvexHull2D(points) {
      var n = points.length;
      if (n < 3) {
        var result = new Array(n);
        for (var i2 = 0; i2 < n; ++i2) {
          result[i2] = i2;
        }
        if (n === 2 && points[0][0] === points[1][0] && points[0][1] === points[1][1]) {
          return [0];
        }
        return result;
      }
      var sorted = new Array(n);
      for (var i2 = 0; i2 < n; ++i2) {
        sorted[i2] = i2;
      }
      sorted.sort(function(a, b) {
        var d = points[a][0] - points[b][0];
        if (d) {
          return d;
        }
        return points[a][1] - points[b][1];
      });
      var lower = [sorted[0], sorted[1]];
      var upper = [sorted[0], sorted[1]];
      for (var i2 = 2; i2 < n; ++i2) {
        var idx = sorted[i2];
        var p = points[idx];
        var m = lower.length;
        while (m > 1 && orient(
          points[lower[m - 2]],
          points[lower[m - 1]],
          p
        ) <= 0) {
          m -= 1;
          lower.pop();
        }
        lower.push(idx);
        m = upper.length;
        while (m > 1 && orient(
          points[upper[m - 2]],
          points[upper[m - 1]],
          p
        ) >= 0) {
          m -= 1;
          upper.pop();
        }
        upper.push(idx);
      }
      var result = new Array(upper.length + lower.length - 2);
      var ptr = 0;
      for (var i2 = 0, nl = lower.length; i2 < nl; ++i2) {
        result[ptr++] = lower[i2];
      }
      for (var j = upper.length - 2; j > 0; --j) {
        result[ptr++] = upper[j];
      }
      return result;
    }
  }
});

// node_modules/convex-hull/lib/ch2d.js
var require_ch2d = __commonJS({
  "node_modules/convex-hull/lib/ch2d.js"(exports, module) {
    "use strict";
    module.exports = convexHull2D;
    var monotoneHull = require_monotone_convex_hull_2d();
    function convexHull2D(points) {
      var hull = monotoneHull(points);
      var h = hull.length;
      if (h <= 2) {
        return [];
      }
      var edges = new Array(h);
      var a = hull[h - 1];
      for (var i2 = 0; i2 < h; ++i2) {
        var b = hull[i2];
        edges[i2] = [a, b];
        a = b;
      }
      return edges;
    }
  }
});

// node_modules/bit-twiddle/twiddle.js
var require_twiddle = __commonJS({
  "node_modules/bit-twiddle/twiddle.js"(exports) {
    "use strict";
    "use restrict";
    var INT_BITS = 32;
    exports.INT_BITS = INT_BITS;
    exports.INT_MAX = 2147483647;
    exports.INT_MIN = -1 << INT_BITS - 1;
    exports.sign = function(v) {
      return (v > 0) - (v < 0);
    };
    exports.abs = function(v) {
      var mask = v >> INT_BITS - 1;
      return (v ^ mask) - mask;
    };
    exports.min = function(x, y) {
      return y ^ (x ^ y) & -(x < y);
    };
    exports.max = function(x, y) {
      return x ^ (x ^ y) & -(x < y);
    };
    exports.isPow2 = function(v) {
      return !(v & v - 1) && !!v;
    };
    exports.log2 = function(v) {
      var r, shift;
      r = (v > 65535) << 4;
      v >>>= r;
      shift = (v > 255) << 3;
      v >>>= shift;
      r |= shift;
      shift = (v > 15) << 2;
      v >>>= shift;
      r |= shift;
      shift = (v > 3) << 1;
      v >>>= shift;
      r |= shift;
      return r | v >> 1;
    };
    exports.log10 = function(v) {
      return v >= 1e9 ? 9 : v >= 1e8 ? 8 : v >= 1e7 ? 7 : v >= 1e6 ? 6 : v >= 1e5 ? 5 : v >= 1e4 ? 4 : v >= 1e3 ? 3 : v >= 100 ? 2 : v >= 10 ? 1 : 0;
    };
    exports.popCount = function(v) {
      v = v - (v >>> 1 & 1431655765);
      v = (v & 858993459) + (v >>> 2 & 858993459);
      return (v + (v >>> 4) & 252645135) * 16843009 >>> 24;
    };
    function countTrailingZeros(v) {
      var c = 32;
      v &= -v;
      if (v)
        c--;
      if (v & 65535)
        c -= 16;
      if (v & 16711935)
        c -= 8;
      if (v & 252645135)
        c -= 4;
      if (v & 858993459)
        c -= 2;
      if (v & 1431655765)
        c -= 1;
      return c;
    }
    exports.countTrailingZeros = countTrailingZeros;
    exports.nextPow2 = function(v) {
      v += v === 0;
      --v;
      v |= v >>> 1;
      v |= v >>> 2;
      v |= v >>> 4;
      v |= v >>> 8;
      v |= v >>> 16;
      return v + 1;
    };
    exports.prevPow2 = function(v) {
      v |= v >>> 1;
      v |= v >>> 2;
      v |= v >>> 4;
      v |= v >>> 8;
      v |= v >>> 16;
      return v - (v >>> 1);
    };
    exports.parity = function(v) {
      v ^= v >>> 16;
      v ^= v >>> 8;
      v ^= v >>> 4;
      v &= 15;
      return 27030 >>> v & 1;
    };
    var REVERSE_TABLE = new Array(256);
    (function(tab) {
      for (var i2 = 0; i2 < 256; ++i2) {
        var v = i2, r = i2, s = 7;
        for (v >>>= 1; v; v >>>= 1) {
          r <<= 1;
          r |= v & 1;
          --s;
        }
        tab[i2] = r << s & 255;
      }
    })(REVERSE_TABLE);
    exports.reverse = function(v) {
      return REVERSE_TABLE[v & 255] << 24 | REVERSE_TABLE[v >>> 8 & 255] << 16 | REVERSE_TABLE[v >>> 16 & 255] << 8 | REVERSE_TABLE[v >>> 24 & 255];
    };
    exports.interleave2 = function(x, y) {
      x &= 65535;
      x = (x | x << 8) & 16711935;
      x = (x | x << 4) & 252645135;
      x = (x | x << 2) & 858993459;
      x = (x | x << 1) & 1431655765;
      y &= 65535;
      y = (y | y << 8) & 16711935;
      y = (y | y << 4) & 252645135;
      y = (y | y << 2) & 858993459;
      y = (y | y << 1) & 1431655765;
      return x | y << 1;
    };
    exports.deinterleave2 = function(v, n) {
      v = v >>> n & 1431655765;
      v = (v | v >>> 1) & 858993459;
      v = (v | v >>> 2) & 252645135;
      v = (v | v >>> 4) & 16711935;
      v = (v | v >>> 16) & 65535;
      return v << 16 >> 16;
    };
    exports.interleave3 = function(x, y, z) {
      x &= 1023;
      x = (x | x << 16) & 4278190335;
      x = (x | x << 8) & 251719695;
      x = (x | x << 4) & 3272356035;
      x = (x | x << 2) & 1227133513;
      y &= 1023;
      y = (y | y << 16) & 4278190335;
      y = (y | y << 8) & 251719695;
      y = (y | y << 4) & 3272356035;
      y = (y | y << 2) & 1227133513;
      x |= y << 1;
      z &= 1023;
      z = (z | z << 16) & 4278190335;
      z = (z | z << 8) & 251719695;
      z = (z | z << 4) & 3272356035;
      z = (z | z << 2) & 1227133513;
      return x | z << 2;
    };
    exports.deinterleave3 = function(v, n) {
      v = v >>> n & 1227133513;
      v = (v | v >>> 2) & 3272356035;
      v = (v | v >>> 4) & 251719695;
      v = (v | v >>> 8) & 4278190335;
      v = (v | v >>> 16) & 1023;
      return v << 22 >> 22;
    };
    exports.nextCombination = function(v) {
      var t = v | v - 1;
      return t + 1 | (~t & -~t) - 1 >>> countTrailingZeros(v) + 1;
    };
  }
});

// node_modules/union-find/index.js
var require_union_find = __commonJS({
  "node_modules/union-find/index.js"(exports, module) {
    "use strict";
    "use restrict";
    module.exports = UnionFind;
    function UnionFind(count) {
      this.roots = new Array(count);
      this.ranks = new Array(count);
      for (var i2 = 0; i2 < count; ++i2) {
        this.roots[i2] = i2;
        this.ranks[i2] = 0;
      }
    }
    var proto = UnionFind.prototype;
    Object.defineProperty(proto, "length", {
      "get": function() {
        return this.roots.length;
      }
    });
    proto.makeSet = function() {
      var n = this.roots.length;
      this.roots.push(n);
      this.ranks.push(0);
      return n;
    };
    proto.find = function(x) {
      var x0 = x;
      var roots = this.roots;
      while (roots[x] !== x) {
        x = roots[x];
      }
      while (roots[x0] !== x) {
        var y = roots[x0];
        roots[x0] = x;
        x0 = y;
      }
      return x;
    };
    proto.link = function(x, y) {
      var xr = this.find(x), yr = this.find(y);
      if (xr === yr) {
        return;
      }
      var ranks = this.ranks, roots = this.roots, xd = ranks[xr], yd = ranks[yr];
      if (xd < yd) {
        roots[xr] = yr;
      } else if (yd < xd) {
        roots[yr] = xr;
      } else {
        roots[yr] = xr;
        ++ranks[xr];
      }
    };
  }
});

// node_modules/simplicial-complex/topology.js
var require_topology = __commonJS({
  "node_modules/simplicial-complex/topology.js"(exports) {
    "use strict";
    "use restrict";
    var bits = require_twiddle();
    var UnionFind = require_union_find();
    function dimension(cells) {
      var d = 0, max = Math.max;
      for (var i2 = 0, il = cells.length; i2 < il; ++i2) {
        d = max(d, cells[i2].length);
      }
      return d - 1;
    }
    exports.dimension = dimension;
    function countVertices(cells) {
      var vc = -1, max = Math.max;
      for (var i2 = 0, il = cells.length; i2 < il; ++i2) {
        var c = cells[i2];
        for (var j = 0, jl = c.length; j < jl; ++j) {
          vc = max(vc, c[j]);
        }
      }
      return vc + 1;
    }
    exports.countVertices = countVertices;
    function cloneCells(cells) {
      var ncells = new Array(cells.length);
      for (var i2 = 0, il = cells.length; i2 < il; ++i2) {
        ncells[i2] = cells[i2].slice(0);
      }
      return ncells;
    }
    exports.cloneCells = cloneCells;
    function compareCells(a, b) {
      var n = a.length, t = a.length - b.length, min = Math.min;
      if (t) {
        return t;
      }
      switch (n) {
        case 0:
          return 0;
        case 1:
          return a[0] - b[0];
        case 2:
          var d = a[0] + a[1] - b[0] - b[1];
          if (d) {
            return d;
          }
          return min(a[0], a[1]) - min(b[0], b[1]);
        case 3:
          var l1 = a[0] + a[1], m1 = b[0] + b[1];
          d = l1 + a[2] - (m1 + b[2]);
          if (d) {
            return d;
          }
          var l0 = min(a[0], a[1]), m0 = min(b[0], b[1]), d = min(l0, a[2]) - min(m0, b[2]);
          if (d) {
            return d;
          }
          return min(l0 + a[2], l1) - min(m0 + b[2], m1);
        default:
          var as = a.slice(0);
          as.sort();
          var bs = b.slice(0);
          bs.sort();
          for (var i2 = 0; i2 < n; ++i2) {
            t = as[i2] - bs[i2];
            if (t) {
              return t;
            }
          }
          return 0;
      }
    }
    exports.compareCells = compareCells;
    function compareZipped(a, b) {
      return compareCells(a[0], b[0]);
    }
    function normalize(cells, attr) {
      if (attr) {
        var len = cells.length;
        var zipped = new Array(len);
        for (var i2 = 0; i2 < len; ++i2) {
          zipped[i2] = [cells[i2], attr[i2]];
        }
        zipped.sort(compareZipped);
        for (var i2 = 0; i2 < len; ++i2) {
          cells[i2] = zipped[i2][0];
          attr[i2] = zipped[i2][1];
        }
        return cells;
      } else {
        cells.sort(compareCells);
        return cells;
      }
    }
    exports.normalize = normalize;
    function unique(cells) {
      if (cells.length === 0) {
        return [];
      }
      var ptr = 1, len = cells.length;
      for (var i2 = 1; i2 < len; ++i2) {
        var a = cells[i2];
        if (compareCells(a, cells[i2 - 1])) {
          if (i2 === ptr) {
            ptr++;
            continue;
          }
          cells[ptr++] = a;
        }
      }
      cells.length = ptr;
      return cells;
    }
    exports.unique = unique;
    function findCell(cells, c) {
      var lo = 0, hi = cells.length - 1, r = -1;
      while (lo <= hi) {
        var mid = lo + hi >> 1, s = compareCells(cells[mid], c);
        if (s <= 0) {
          if (s === 0) {
            r = mid;
          }
          lo = mid + 1;
        } else if (s > 0) {
          hi = mid - 1;
        }
      }
      return r;
    }
    exports.findCell = findCell;
    function incidence(from_cells, to_cells) {
      var index = new Array(from_cells.length);
      for (var i2 = 0, il = index.length; i2 < il; ++i2) {
        index[i2] = [];
      }
      var b = [];
      for (var i2 = 0, n = to_cells.length; i2 < n; ++i2) {
        var c = to_cells[i2];
        var cl = c.length;
        for (var k = 1, kn = 1 << cl; k < kn; ++k) {
          b.length = bits.popCount(k);
          var l = 0;
          for (var j = 0; j < cl; ++j) {
            if (k & 1 << j) {
              b[l++] = c[j];
            }
          }
          var idx = findCell(from_cells, b);
          if (idx < 0) {
            continue;
          }
          while (true) {
            index[idx++].push(i2);
            if (idx >= from_cells.length || compareCells(from_cells[idx], b) !== 0) {
              break;
            }
          }
        }
      }
      return index;
    }
    exports.incidence = incidence;
    function dual(cells, vertex_count) {
      if (!vertex_count) {
        return incidence(unique(skeleton(cells, 0)), cells, 0);
      }
      var res = new Array(vertex_count);
      for (var i2 = 0; i2 < vertex_count; ++i2) {
        res[i2] = [];
      }
      for (var i2 = 0, len = cells.length; i2 < len; ++i2) {
        var c = cells[i2];
        for (var j = 0, cl = c.length; j < cl; ++j) {
          res[c[j]].push(i2);
        }
      }
      return res;
    }
    exports.dual = dual;
    function explode(cells) {
      var result = [];
      for (var i2 = 0, il = cells.length; i2 < il; ++i2) {
        var c = cells[i2], cl = c.length | 0;
        for (var j = 1, jl = 1 << cl; j < jl; ++j) {
          var b = [];
          for (var k = 0; k < cl; ++k) {
            if (j >>> k & 1) {
              b.push(c[k]);
            }
          }
          result.push(b);
        }
      }
      return normalize(result);
    }
    exports.explode = explode;
    function skeleton(cells, n) {
      if (n < 0) {
        return [];
      }
      var result = [], k0 = (1 << n + 1) - 1;
      for (var i2 = 0; i2 < cells.length; ++i2) {
        var c = cells[i2];
        for (var k = k0; k < 1 << c.length; k = bits.nextCombination(k)) {
          var b = new Array(n + 1), l = 0;
          for (var j = 0; j < c.length; ++j) {
            if (k & 1 << j) {
              b[l++] = c[j];
            }
          }
          result.push(b);
        }
      }
      return normalize(result);
    }
    exports.skeleton = skeleton;
    function boundary(cells) {
      var res = [];
      for (var i2 = 0, il = cells.length; i2 < il; ++i2) {
        var c = cells[i2];
        for (var j = 0, cl = c.length; j < cl; ++j) {
          var b = new Array(c.length - 1);
          for (var k = 0, l = 0; k < cl; ++k) {
            if (k !== j) {
              b[l++] = c[k];
            }
          }
          res.push(b);
        }
      }
      return normalize(res);
    }
    exports.boundary = boundary;
    function connectedComponents_dense(cells, vertex_count) {
      var labels = new UnionFind(vertex_count);
      for (var i2 = 0; i2 < cells.length; ++i2) {
        var c = cells[i2];
        for (var j = 0; j < c.length; ++j) {
          for (var k = j + 1; k < c.length; ++k) {
            labels.link(c[j], c[k]);
          }
        }
      }
      var components = [], component_labels = labels.ranks;
      for (var i2 = 0; i2 < component_labels.length; ++i2) {
        component_labels[i2] = -1;
      }
      for (var i2 = 0; i2 < cells.length; ++i2) {
        var l = labels.find(cells[i2][0]);
        if (component_labels[l] < 0) {
          component_labels[l] = components.length;
          components.push([cells[i2].slice(0)]);
        } else {
          components[component_labels[l]].push(cells[i2].slice(0));
        }
      }
      return components;
    }
    function connectedComponents_sparse(cells) {
      var vertices = unique(normalize(skeleton(cells, 0))), labels = new UnionFind(vertices.length);
      for (var i2 = 0; i2 < cells.length; ++i2) {
        var c = cells[i2];
        for (var j = 0; j < c.length; ++j) {
          var vj = findCell(vertices, [c[j]]);
          for (var k = j + 1; k < c.length; ++k) {
            labels.link(vj, findCell(vertices, [c[k]]));
          }
        }
      }
      var components = [], component_labels = labels.ranks;
      for (var i2 = 0; i2 < component_labels.length; ++i2) {
        component_labels[i2] = -1;
      }
      for (var i2 = 0; i2 < cells.length; ++i2) {
        var l = labels.find(findCell(vertices, [cells[i2][0]]));
        if (component_labels[l] < 0) {
          component_labels[l] = components.length;
          components.push([cells[i2].slice(0)]);
        } else {
          components[component_labels[l]].push(cells[i2].slice(0));
        }
      }
      return components;
    }
    function connectedComponents(cells, vertex_count) {
      if (vertex_count) {
        return connectedComponents_dense(cells, vertex_count);
      }
      return connectedComponents_sparse(cells);
    }
    exports.connectedComponents = connectedComponents;
  }
});

// node_modules/incremental-convex-hull/ich.js
var require_ich = __commonJS({
  "node_modules/incremental-convex-hull/ich.js"(exports, module) {
    "use strict";
    module.exports = incrementalConvexHull;
    var orient = require_orientation();
    var compareCell = require_topology().compareCells;
    function Simplex(vertices, adjacent, boundary) {
      this.vertices = vertices;
      this.adjacent = adjacent;
      this.boundary = boundary;
      this.lastVisited = -1;
    }
    Simplex.prototype.flip = function() {
      var t = this.vertices[0];
      this.vertices[0] = this.vertices[1];
      this.vertices[1] = t;
      var u = this.adjacent[0];
      this.adjacent[0] = this.adjacent[1];
      this.adjacent[1] = u;
    };
    function GlueFacet(vertices, cell, index) {
      this.vertices = vertices;
      this.cell = cell;
      this.index = index;
    }
    function compareGlue(a, b) {
      return compareCell(a.vertices, b.vertices);
    }
    function bakeOrient(d) {
      var code = ["function orient(){var tuple=this.tuple;return test("];
      for (var i2 = 0; i2 <= d; ++i2) {
        if (i2 > 0) {
          code.push(",");
        }
        code.push("tuple[", i2, "]");
      }
      code.push(")}return orient");
      var proc = new Function("test", code.join(""));
      var test = orient[d + 1];
      if (!test) {
        test = orient;
      }
      return proc(test);
    }
    var BAKED = [];
    function Triangulation(dimension, vertices, simplices) {
      this.dimension = dimension;
      this.vertices = vertices;
      this.simplices = simplices;
      this.interior = simplices.filter(function(c) {
        return !c.boundary;
      });
      this.tuple = new Array(dimension + 1);
      for (var i2 = 0; i2 <= dimension; ++i2) {
        this.tuple[i2] = this.vertices[i2];
      }
      var o = BAKED[dimension];
      if (!o) {
        o = BAKED[dimension] = bakeOrient(dimension);
      }
      this.orient = o;
    }
    var proto = Triangulation.prototype;
    proto.handleBoundaryDegeneracy = function(cell, point) {
      var d = this.dimension;
      var n = this.vertices.length - 1;
      var tuple = this.tuple;
      var verts = this.vertices;
      var toVisit = [cell];
      cell.lastVisited = -n;
      while (toVisit.length > 0) {
        cell = toVisit.pop();
        var cellVerts = cell.vertices;
        var cellAdj = cell.adjacent;
        for (var i2 = 0; i2 <= d; ++i2) {
          var neighbor = cellAdj[i2];
          if (!neighbor.boundary || neighbor.lastVisited <= -n) {
            continue;
          }
          var nv = neighbor.vertices;
          for (var j = 0; j <= d; ++j) {
            var vv = nv[j];
            if (vv < 0) {
              tuple[j] = point;
            } else {
              tuple[j] = verts[vv];
            }
          }
          var o = this.orient();
          if (o > 0) {
            return neighbor;
          }
          neighbor.lastVisited = -n;
          if (o === 0) {
            toVisit.push(neighbor);
          }
        }
      }
      return null;
    };
    proto.walk = function(point, random) {
      var n = this.vertices.length - 1;
      var d = this.dimension;
      var verts = this.vertices;
      var tuple = this.tuple;
      var initIndex = random ? this.interior.length * Math.random() | 0 : this.interior.length - 1;
      var cell = this.interior[initIndex];
      outerLoop:
        while (!cell.boundary) {
          var cellVerts = cell.vertices;
          var cellAdj = cell.adjacent;
          for (var i2 = 0; i2 <= d; ++i2) {
            tuple[i2] = verts[cellVerts[i2]];
          }
          cell.lastVisited = n;
          for (var i2 = 0; i2 <= d; ++i2) {
            var neighbor = cellAdj[i2];
            if (neighbor.lastVisited >= n) {
              continue;
            }
            var prev = tuple[i2];
            tuple[i2] = point;
            var o = this.orient();
            tuple[i2] = prev;
            if (o < 0) {
              cell = neighbor;
              continue outerLoop;
            } else {
              if (!neighbor.boundary) {
                neighbor.lastVisited = n;
              } else {
                neighbor.lastVisited = -n;
              }
            }
          }
          return;
        }
      return cell;
    };
    proto.addPeaks = function(point, cell) {
      var n = this.vertices.length - 1;
      var d = this.dimension;
      var verts = this.vertices;
      var tuple = this.tuple;
      var interior = this.interior;
      var simplices = this.simplices;
      var tovisit = [cell];
      cell.lastVisited = n;
      cell.vertices[cell.vertices.indexOf(-1)] = n;
      cell.boundary = false;
      interior.push(cell);
      var glueFacets = [];
      while (tovisit.length > 0) {
        var cell = tovisit.pop();
        var cellVerts = cell.vertices;
        var cellAdj = cell.adjacent;
        var indexOfN = cellVerts.indexOf(n);
        if (indexOfN < 0) {
          continue;
        }
        for (var i2 = 0; i2 <= d; ++i2) {
          if (i2 === indexOfN) {
            continue;
          }
          var neighbor = cellAdj[i2];
          if (!neighbor.boundary || neighbor.lastVisited >= n) {
            continue;
          }
          var nv = neighbor.vertices;
          if (neighbor.lastVisited !== -n) {
            var indexOfNeg1 = 0;
            for (var j = 0; j <= d; ++j) {
              if (nv[j] < 0) {
                indexOfNeg1 = j;
                tuple[j] = point;
              } else {
                tuple[j] = verts[nv[j]];
              }
            }
            var o = this.orient();
            if (o > 0) {
              nv[indexOfNeg1] = n;
              neighbor.boundary = false;
              interior.push(neighbor);
              tovisit.push(neighbor);
              neighbor.lastVisited = n;
              continue;
            } else {
              neighbor.lastVisited = -n;
            }
          }
          var na = neighbor.adjacent;
          var vverts = cellVerts.slice();
          var vadj = cellAdj.slice();
          var ncell = new Simplex(vverts, vadj, true);
          simplices.push(ncell);
          var opposite = na.indexOf(cell);
          if (opposite < 0) {
            continue;
          }
          na[opposite] = ncell;
          vadj[indexOfN] = neighbor;
          vverts[i2] = -1;
          vadj[i2] = cell;
          cellAdj[i2] = ncell;
          ncell.flip();
          for (var j = 0; j <= d; ++j) {
            var uu = vverts[j];
            if (uu < 0 || uu === n) {
              continue;
            }
            var nface = new Array(d - 1);
            var nptr = 0;
            for (var k = 0; k <= d; ++k) {
              var vv = vverts[k];
              if (vv < 0 || k === j) {
                continue;
              }
              nface[nptr++] = vv;
            }
            glueFacets.push(new GlueFacet(nface, ncell, j));
          }
        }
      }
      glueFacets.sort(compareGlue);
      for (var i2 = 0; i2 + 1 < glueFacets.length; i2 += 2) {
        var a = glueFacets[i2];
        var b = glueFacets[i2 + 1];
        var ai = a.index;
        var bi = b.index;
        if (ai < 0 || bi < 0) {
          continue;
        }
        a.cell.adjacent[a.index] = b.cell;
        b.cell.adjacent[b.index] = a.cell;
      }
    };
    proto.insert = function(point, random) {
      var verts = this.vertices;
      verts.push(point);
      var cell = this.walk(point, random);
      if (!cell) {
        return;
      }
      var d = this.dimension;
      var tuple = this.tuple;
      for (var i2 = 0; i2 <= d; ++i2) {
        var vv = cell.vertices[i2];
        if (vv < 0) {
          tuple[i2] = point;
        } else {
          tuple[i2] = verts[vv];
        }
      }
      var o = this.orient(tuple);
      if (o < 0) {
        return;
      } else if (o === 0) {
        cell = this.handleBoundaryDegeneracy(cell, point);
        if (!cell) {
          return;
        }
      }
      this.addPeaks(point, cell);
    };
    proto.boundary = function() {
      var d = this.dimension;
      var boundary = [];
      var cells = this.simplices;
      var nc = cells.length;
      for (var i2 = 0; i2 < nc; ++i2) {
        var c = cells[i2];
        if (c.boundary) {
          var bcell = new Array(d);
          var cv = c.vertices;
          var ptr = 0;
          var parity = 0;
          for (var j = 0; j <= d; ++j) {
            if (cv[j] >= 0) {
              bcell[ptr++] = cv[j];
            } else {
              parity = j & 1;
            }
          }
          if (parity === (d & 1)) {
            var t = bcell[0];
            bcell[0] = bcell[1];
            bcell[1] = t;
          }
          boundary.push(bcell);
        }
      }
      return boundary;
    };
    function incrementalConvexHull(points, randomSearch) {
      var n = points.length;
      if (n === 0) {
        throw new Error("Must have at least d+1 points");
      }
      var d = points[0].length;
      if (n <= d) {
        throw new Error("Must input at least d+1 points");
      }
      var initialSimplex = points.slice(0, d + 1);
      var o = orient.apply(void 0, initialSimplex);
      if (o === 0) {
        throw new Error("Input not in general position");
      }
      var initialCoords = new Array(d + 1);
      for (var i2 = 0; i2 <= d; ++i2) {
        initialCoords[i2] = i2;
      }
      if (o < 0) {
        initialCoords[0] = 1;
        initialCoords[1] = 0;
      }
      var initialCell = new Simplex(initialCoords, new Array(d + 1), false);
      var boundary = initialCell.adjacent;
      var list = new Array(d + 2);
      for (var i2 = 0; i2 <= d; ++i2) {
        var verts = initialCoords.slice();
        for (var j = 0; j <= d; ++j) {
          if (j === i2) {
            verts[j] = -1;
          }
        }
        var t = verts[0];
        verts[0] = verts[1];
        verts[1] = t;
        var cell = new Simplex(verts, new Array(d + 1), true);
        boundary[i2] = cell;
        list[i2] = cell;
      }
      list[d + 1] = initialCell;
      for (var i2 = 0; i2 <= d; ++i2) {
        var verts = boundary[i2].vertices;
        var adj = boundary[i2].adjacent;
        for (var j = 0; j <= d; ++j) {
          var v = verts[j];
          if (v < 0) {
            adj[j] = initialCell;
            continue;
          }
          for (var k = 0; k <= d; ++k) {
            if (boundary[k].vertices.indexOf(v) < 0) {
              adj[j] = boundary[k];
            }
          }
        }
      }
      var triangles = new Triangulation(d, initialSimplex, list);
      var useRandom = !!randomSearch;
      for (var i2 = d + 1; i2 < n; ++i2) {
        triangles.insert(points[i2], useRandom);
      }
      return triangles.boundary();
    }
  }
});

// node_modules/affine-hull/aff.js
var require_aff = __commonJS({
  "node_modules/affine-hull/aff.js"(exports, module) {
    "use strict";
    module.exports = affineHull;
    var orient = require_orientation();
    function linearlyIndependent(points, d) {
      var nhull = new Array(d + 1);
      for (var i2 = 0; i2 < points.length; ++i2) {
        nhull[i2] = points[i2];
      }
      for (var i2 = 0; i2 <= points.length; ++i2) {
        for (var j = points.length; j <= d; ++j) {
          var x = new Array(d);
          for (var k = 0; k < d; ++k) {
            x[k] = Math.pow(j + 1 - i2, k);
          }
          nhull[j] = x;
        }
        var o = orient.apply(void 0, nhull);
        if (o) {
          return true;
        }
      }
      return false;
    }
    function affineHull(points) {
      var n = points.length;
      if (n === 0) {
        return [];
      }
      if (n === 1) {
        return [0];
      }
      var d = points[0].length;
      var frame = [points[0]];
      var index = [0];
      for (var i2 = 1; i2 < n; ++i2) {
        frame.push(points[i2]);
        if (!linearlyIndependent(frame, d)) {
          frame.pop();
          continue;
        }
        index.push(i2);
        if (index.length === d + 1) {
          return index;
        }
      }
      return index;
    }
  }
});

// node_modules/convex-hull/lib/chnd.js
var require_chnd = __commonJS({
  "node_modules/convex-hull/lib/chnd.js"(exports, module) {
    "use strict";
    module.exports = convexHullnD;
    var ich = require_ich();
    var aff = require_aff();
    function permute(points, front) {
      var n = points.length;
      var npoints = new Array(n);
      for (var i2 = 0; i2 < front.length; ++i2) {
        npoints[i2] = points[front[i2]];
      }
      var ptr = front.length;
      for (var i2 = 0; i2 < n; ++i2) {
        if (front.indexOf(i2) < 0) {
          npoints[ptr++] = points[i2];
        }
      }
      return npoints;
    }
    function invPermute(cells, front) {
      var nc = cells.length;
      var nf = front.length;
      for (var i2 = 0; i2 < nc; ++i2) {
        var c = cells[i2];
        for (var j = 0; j < c.length; ++j) {
          var x = c[j];
          if (x < nf) {
            c[j] = front[x];
          } else {
            x = x - nf;
            for (var k = 0; k < nf; ++k) {
              if (x >= front[k]) {
                x += 1;
              }
            }
            c[j] = x;
          }
        }
      }
      return cells;
    }
    function convexHullnD(points, d) {
      try {
        return ich(points, true);
      } catch (e) {
        var ah = aff(points);
        if (ah.length <= d) {
          return [];
        }
        var npoints = permute(points, ah);
        var nhull = ich(npoints, true);
        return invPermute(nhull, ah);
      }
    }
  }
});

// node_modules/convex-hull/ch.js
var require_ch = __commonJS({
  "node_modules/convex-hull/ch.js"(exports, module) {
    "use strict";
    var convexHull1d = require_ch1d();
    var convexHull2d = require_ch2d();
    var convexHullnd = require_chnd();
    module.exports = convexHull;
    function convexHull(points) {
      var n = points.length;
      if (n === 0) {
        return [];
      } else if (n === 1) {
        return [[0]];
      }
      var d = points[0].length;
      if (d === 0) {
        return [];
      } else if (d === 1) {
        return convexHull1d(points);
      } else if (d === 2) {
        return convexHull2d(points);
      }
      return convexHullnd(points, d);
    }
  }
});

// node_modules/turf-convex/index.js
var require_turf_convex = __commonJS({
  "node_modules/turf-convex/index.js"(exports, module) {
    var each = require_turf_meta().coordEach;
    var convexHull = require_ch();
    var polygon = require_turf_helpers().polygon;
    module.exports = function(featurecollection) {
      var points = [];
      each(featurecollection, function(coord) {
        points.push(coord);
      });
      var hull = convexHull(points);
      if (hull.length > 0) {
        var ring = [];
        for (var i2 = 0; i2 < hull.length; i2++) {
          ring.push(points[hull[i2][0]]);
        }
        ring.push(points[hull[hull.length - 1][1]]);
        return polygon([ring]);
      }
      return void 0;
    };
  }
});

// node_modules/turf-within/index.js
var require_turf_within = __commonJS({
  "node_modules/turf-within/index.js"(exports, module) {
    var inside = require_turf_inside();
    var featureCollection = require_turf_helpers().featureCollection;
    module.exports = function(points, polygons) {
      var pointsWithin = featureCollection([]);
      for (var i2 = 0; i2 < polygons.features.length; i2++) {
        for (var j = 0; j < points.features.length; j++) {
          var isInside = inside(points.features[j], polygons.features[i2]);
          if (isInside) {
            pointsWithin.features.push(points.features[j]);
          }
        }
      }
      return pointsWithin;
    };
  }
});

// node_modules/jsts/dist/jsts.min.js
var require_jsts_min = __commonJS({
  "node_modules/jsts/dist/jsts.min.js"(exports, module) {
    !function(t, e) {
      "object" == typeof exports && "undefined" != typeof module ? e(exports) : "function" == typeof define && define.amd ? define(["exports"], e) : e(t.jsts = t.jsts || {});
    }(exports, function(t) {
      "use strict";
      function e(t2, e2) {
        for (var n2 in e2)
          e2.hasOwnProperty(n2) && (t2[n2] = e2[n2]);
      }
      function n() {
      }
      function i2() {
      }
      function r() {
      }
      function s() {
      }
      function o() {
      }
      function a() {
      }
      function u() {
      }
      function l(t2) {
        this.message = t2;
      }
      function h(t2, e2) {
        t2.prototype = Object.create(e2.prototype), t2.prototype.constructor = t2;
      }
      function c() {
        if (0 === arguments.length)
          l.call(this);
        else if (1 === arguments.length) {
          var t2 = arguments[0];
          l.call(this, t2);
        }
      }
      function f() {
      }
      function g() {
        if (this.x = null, this.y = null, this.z = null, 0 === arguments.length)
          g.call(this, 0, 0);
        else if (1 === arguments.length) {
          var t2 = arguments[0];
          g.call(this, t2.x, t2.y, t2.z);
        } else if (2 === arguments.length) {
          var e2 = arguments[0], n2 = arguments[1];
          g.call(this, e2, n2, g.NULL_ORDINATE);
        } else if (3 === arguments.length) {
          var i3 = arguments[0], r2 = arguments[1], s2 = arguments[2];
          this.x = i3, this.y = r2, this.z = s2;
        }
      }
      function d() {
        if (this.dimensionsToTest = 2, 0 === arguments.length)
          d.call(this, 2);
        else if (1 === arguments.length) {
          var t2 = arguments[0];
          if (2 !== t2 && 3 !== t2)
            throw new i2("only 2 or 3 dimensions may be specified");
          this.dimensionsToTest = t2;
        }
      }
      function p() {
      }
      function v() {
      }
      function m(t2) {
        this.message = t2 || "";
      }
      function y() {
      }
      function x(t2) {
        this.message = t2 || "";
      }
      function E(t2) {
        this.message = t2 || "";
      }
      function I() {
        this.array_ = [], arguments[0] instanceof v && this.addAll(arguments[0]);
      }
      function N() {
        if (I.apply(this), 0 === arguments.length)
          ;
        else if (1 === arguments.length) {
          var t2 = arguments[0];
          this.ensureCapacity(t2.length), this.add(t2, true);
        } else if (2 === arguments.length) {
          var e2 = arguments[0], n2 = arguments[1];
          this.ensureCapacity(e2.length), this.add(e2, n2);
        }
      }
      function C() {
        if (this.minx = null, this.maxx = null, this.miny = null, this.maxy = null, 0 === arguments.length)
          this.init();
        else if (1 === arguments.length) {
          if (arguments[0] instanceof g) {
            var t2 = arguments[0];
            this.init(t2.x, t2.x, t2.y, t2.y);
          } else if (arguments[0] instanceof C) {
            var e2 = arguments[0];
            this.init(e2);
          }
        } else if (2 === arguments.length) {
          var n2 = arguments[0], i3 = arguments[1];
          this.init(n2.x, i3.x, n2.y, i3.y);
        } else if (4 === arguments.length) {
          var r2 = arguments[0], s2 = arguments[1], o2 = arguments[2], a2 = arguments[3];
          this.init(r2, s2, o2, a2);
        }
      }
      function S() {
      }
      function w() {
        S.call(this, "Projective point not representable on the Cartesian plane.");
      }
      function L() {
      }
      function R(t2, e2) {
        return t2.interfaces_ && t2.interfaces_().indexOf(e2) > -1;
      }
      function T() {
      }
      function P(t2) {
        this.str = t2;
      }
      function b(t2) {
        this.value = t2;
      }
      function O() {
      }
      function _() {
        if (this.hi = 0, this.lo = 0, 0 === arguments.length)
          this.init(0);
        else if (1 === arguments.length) {
          if ("number" == typeof arguments[0]) {
            var t2 = arguments[0];
            this.init(t2);
          } else if (arguments[0] instanceof _) {
            var e2 = arguments[0];
            this.init(e2);
          } else if ("string" == typeof arguments[0]) {
            var n2 = arguments[0];
            _.call(this, _.parse(n2));
          }
        } else if (2 === arguments.length) {
          var i3 = arguments[0], r2 = arguments[1];
          this.init(i3, r2);
        }
      }
      function M() {
      }
      function D() {
      }
      function A() {
      }
      function F() {
        if (this.x = null, this.y = null, this.w = null, 0 === arguments.length)
          this.x = 0, this.y = 0, this.w = 1;
        else if (1 === arguments.length) {
          var t2 = arguments[0];
          this.x = t2.x, this.y = t2.y, this.w = 1;
        } else if (2 === arguments.length) {
          if ("number" == typeof arguments[0] && "number" == typeof arguments[1]) {
            var e2 = arguments[0], n2 = arguments[1];
            this.x = e2, this.y = n2, this.w = 1;
          } else if (arguments[0] instanceof F && arguments[1] instanceof F) {
            var i3 = arguments[0], r2 = arguments[1];
            this.x = i3.y * r2.w - r2.y * i3.w, this.y = r2.x * i3.w - i3.x * r2.w, this.w = i3.x * r2.y - r2.x * i3.y;
          } else if (arguments[0] instanceof g && arguments[1] instanceof g) {
            var s2 = arguments[0], o2 = arguments[1];
            this.x = s2.y - o2.y, this.y = o2.x - s2.x, this.w = s2.x * o2.y - o2.x * s2.y;
          }
        } else if (3 === arguments.length) {
          var a2 = arguments[0], u2 = arguments[1], l2 = arguments[2];
          this.x = a2, this.y = u2, this.w = l2;
        } else if (4 === arguments.length) {
          var h2 = arguments[0], c2 = arguments[1], f2 = arguments[2], d2 = arguments[3], p2 = h2.y - c2.y, v2 = c2.x - h2.x, m2 = h2.x * c2.y - c2.x * h2.y, y2 = f2.y - d2.y, x2 = d2.x - f2.x, E2 = f2.x * d2.y - d2.x * f2.y;
          this.x = v2 * E2 - x2 * m2, this.y = y2 * m2 - p2 * E2, this.w = p2 * x2 - y2 * v2;
        }
      }
      function G() {
      }
      function q() {
      }
      function B() {
        this.envelope = null, this.factory = null, this.SRID = null, this.userData = null;
        var t2 = arguments[0];
        this.factory = t2, this.SRID = t2.getSRID();
      }
      function z() {
      }
      function V() {
      }
      function k() {
      }
      function Y() {
      }
      function U() {
      }
      function X() {
      }
      function H() {
      }
      function W() {
      }
      function j() {
      }
      function K() {
      }
      function Z() {
      }
      function Q() {
      }
      function J() {
        this.array_ = [], arguments[0] instanceof v && this.addAll(arguments[0]);
      }
      function $(t2) {
        return null == t2 ? $s : t2.color;
      }
      function tt(t2) {
        return null == t2 ? null : t2.parent;
      }
      function et(t2, e2) {
        null !== t2 && (t2.color = e2);
      }
      function nt(t2) {
        return null == t2 ? null : t2.left;
      }
      function it(t2) {
        return null == t2 ? null : t2.right;
      }
      function rt() {
        this.root_ = null, this.size_ = 0;
      }
      function st() {
      }
      function ot() {
      }
      function at() {
        this.array_ = [], arguments[0] instanceof v && this.addAll(arguments[0]);
      }
      function ut() {
      }
      function lt() {
      }
      function ht() {
      }
      function ct() {
      }
      function ft() {
        this.geometries = null;
        var t2 = arguments[0], e2 = arguments[1];
        if (B.call(this, e2), null === t2 && (t2 = []), B.hasNullElements(t2))
          throw new i2("geometries must not contain null elements");
        this.geometries = t2;
      }
      function gt() {
        var t2 = arguments[0], e2 = arguments[1];
        ft.call(this, t2, e2);
      }
      function dt() {
        if (this.geom = null, this.geomFact = null, this.bnRule = null, this.endpointMap = null, 1 === arguments.length) {
          var t2 = arguments[0];
          dt.call(this, t2, V.MOD2_BOUNDARY_RULE);
        } else if (2 === arguments.length) {
          var e2 = arguments[0], n2 = arguments[1];
          this.geom = e2, this.geomFact = e2.getFactory(), this.bnRule = n2;
        }
      }
      function pt() {
        this.count = null;
      }
      function vt() {
      }
      function mt() {
      }
      function yt() {
      }
      function xt() {
      }
      function Et() {
      }
      function It() {
      }
      function Nt() {
      }
      function Ct() {
      }
      function St() {
        this.points = null;
        var t2 = arguments[0], e2 = arguments[1];
        B.call(this, e2), this.init(t2);
      }
      function wt() {
      }
      function Lt() {
        this.coordinates = null;
        var t2 = arguments[0], e2 = arguments[1];
        B.call(this, e2), this.init(t2);
      }
      function Rt() {
      }
      function Tt() {
        this.shell = null, this.holes = null;
        var t2 = arguments[0], e2 = arguments[1], n2 = arguments[2];
        if (B.call(this, n2), null === t2 && (t2 = this.getFactory().createLinearRing()), null === e2 && (e2 = []), B.hasNullElements(e2))
          throw new i2("holes must not contain null elements");
        if (t2.isEmpty() && B.hasNonEmptyElements(e2))
          throw new i2("shell is empty but holes are not");
        this.shell = t2, this.holes = e2;
      }
      function Pt() {
        var t2 = arguments[0], e2 = arguments[1];
        ft.call(this, t2, e2);
      }
      function bt() {
        if (arguments[0] instanceof g && arguments[1] instanceof ie) {
          var t2 = arguments[0], e2 = arguments[1];
          bt.call(this, e2.getCoordinateSequenceFactory().create(t2), e2);
        } else if (R(arguments[0], D) && arguments[1] instanceof ie) {
          var n2 = arguments[0], i3 = arguments[1];
          St.call(this, n2, i3), this.validateConstruction();
        }
      }
      function Ot() {
        var t2 = arguments[0], e2 = arguments[1];
        ft.call(this, t2, e2);
      }
      function _t() {
        if (this.factory = null, this.isUserDataCopied = false, 0 === arguments.length)
          ;
        else if (1 === arguments.length) {
          var t2 = arguments[0];
          this.factory = t2;
        }
      }
      function Mt() {
      }
      function Dt() {
      }
      function At() {
      }
      function Ft() {
      }
      function Gt() {
        if (this.dimension = 3, this.coordinates = null, 1 === arguments.length) {
          if (arguments[0] instanceof Array) {
            var t2 = arguments[0];
            Gt.call(this, t2, 3);
          } else if (Number.isInteger(arguments[0])) {
            var e2 = arguments[0];
            this.coordinates = new Array(e2).fill(null);
            for (var n2 = 0; e2 > n2; n2++)
              this.coordinates[n2] = new g();
          } else if (R(arguments[0], D)) {
            var i3 = arguments[0];
            if (null === i3)
              return this.coordinates = new Array(0).fill(null), null;
            this.dimension = i3.getDimension(), this.coordinates = new Array(i3.size()).fill(null);
            for (var n2 = 0; n2 < this.coordinates.length; n2++)
              this.coordinates[n2] = i3.getCoordinateCopy(n2);
          }
        } else if (2 === arguments.length) {
          if (arguments[0] instanceof Array && Number.isInteger(arguments[1])) {
            var r2 = arguments[0], s2 = arguments[1];
            this.coordinates = r2, this.dimension = s2, null === r2 && (this.coordinates = new Array(0).fill(null));
          } else if (Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {
            var o2 = arguments[0], a2 = arguments[1];
            this.coordinates = new Array(o2).fill(null), this.dimension = a2;
            for (var n2 = 0; o2 > n2; n2++)
              this.coordinates[n2] = new g();
          }
        }
      }
      function qt() {
      }
      function Bt(t2, e2) {
        return t2 === e2 || t2 !== t2 && e2 !== e2;
      }
      function zt(t2, e2) {
        function n2(t3) {
          return this && this.constructor === n2 ? (this._keys = [], this._values = [], this._itp = [], this.objectOnly = e2, void (t3 && Vt.call(this, t3))) : new n2(t3);
        }
        return e2 || io(t2, "size", { get: Jt }), t2.constructor = n2, n2.prototype = t2, n2;
      }
      function Vt(t2) {
        this.add ? t2.forEach(this.add, this) : t2.forEach(function(t3) {
          this.set(t3[0], t3[1]);
        }, this);
      }
      function kt(t2) {
        return this.has(t2) && (this._keys.splice(no, 1), this._values.splice(no, 1), this._itp.forEach(function(t3) {
          no < t3[0] && t3[0]--;
        })), no > -1;
      }
      function Yt(t2) {
        return this.has(t2) ? this._values[no] : void 0;
      }
      function Ut(t2, e2) {
        if (this.objectOnly && e2 !== Object(e2))
          throw new TypeError("Invalid value used as weak collection key");
        if (e2 !== e2 || 0 === e2)
          for (no = t2.length; no-- && !Bt(t2[no], e2); )
            ;
        else
          no = t2.indexOf(e2);
        return no > -1;
      }
      function Xt(t2) {
        return Ut.call(this, this._keys, t2);
      }
      function Ht(t2, e2) {
        return this.has(t2) ? this._values[no] = e2 : this._values[this._keys.push(t2) - 1] = e2, this;
      }
      function Wt() {
        (this._keys || 0).length = this._values.length = 0;
      }
      function jt() {
        return Qt(this._itp, this._keys);
      }
      function Kt() {
        return Qt(this._itp, this._values);
      }
      function Zt() {
        return Qt(this._itp, this._keys, this._values);
      }
      function Qt(t2, e2, n2) {
        var i3 = [0], r2 = false;
        return t2.push(i3), { next: function() {
          var s2, o2 = i3[0];
          return !r2 && o2 < e2.length ? (s2 = n2 ? [e2[o2], n2[o2]] : e2[o2], i3[0]++) : (r2 = true, t2.splice(t2.indexOf(i3), 1)), { done: r2, value: s2 };
        } };
      }
      function Jt() {
        return this._values.length;
      }
      function $t(t2, e2) {
        for (var n2 = this.entries(); ; ) {
          var i3 = n2.next();
          if (i3.done)
            break;
          t2.call(e2, i3.value[1], i3.value[0], this);
        }
      }
      function te() {
        this.map_ = new so();
      }
      function ee() {
        if (this.modelType = null, this.scale = null, 0 === arguments.length)
          this.modelType = ee.FLOATING;
        else if (1 === arguments.length) {
          if (arguments[0] instanceof ne) {
            var t2 = arguments[0];
            this.modelType = t2, t2 === ee.FIXED && this.setScale(1);
          } else if ("number" == typeof arguments[0]) {
            var e2 = arguments[0];
            this.modelType = ee.FIXED, this.setScale(e2);
          } else if (arguments[0] instanceof ee) {
            var n2 = arguments[0];
            this.modelType = n2.modelType, this.scale = n2.scale;
          }
        }
      }
      function ne() {
        this.name = null;
        var t2 = arguments[0];
        this.name = t2, ne.nameToTypeMap.put(t2, this);
      }
      function ie() {
        if (this.precisionModel = null, this.coordinateSequenceFactory = null, this.SRID = null, 0 === arguments.length)
          ie.call(this, new ee(), 0);
        else if (1 === arguments.length) {
          if (R(arguments[0], G)) {
            var t2 = arguments[0];
            ie.call(this, new ee(), 0, t2);
          } else if (arguments[0] instanceof ee) {
            var e2 = arguments[0];
            ie.call(this, e2, 0, ie.getDefaultCoordinateSequenceFactory());
          }
        } else if (2 === arguments.length) {
          var n2 = arguments[0], i3 = arguments[1];
          ie.call(this, n2, i3, ie.getDefaultCoordinateSequenceFactory());
        } else if (3 === arguments.length) {
          var r2 = arguments[0], s2 = arguments[1], o2 = arguments[2];
          this.precisionModel = r2, this.coordinateSequenceFactory = o2, this.SRID = s2;
        }
      }
      function re(t2) {
        this.geometryFactory = t2 || new ie();
      }
      function se(t2) {
        this.parser = new re(t2);
      }
      function oe() {
        this.result = null, this.inputLines = Array(2).fill().map(function() {
          return Array(2);
        }), this.intPt = new Array(2).fill(null), this.intLineIndex = null, this._isProper = null, this.pa = null, this.pb = null, this.precisionModel = null, this.intPt[0] = new g(), this.intPt[1] = new g(), this.pa = this.intPt[0], this.pb = this.intPt[1], this.result = 0;
      }
      function ae() {
        oe.apply(this);
      }
      function ue() {
      }
      function le() {
        this.p = null, this.crossingCount = 0, this.isPointOnSegment = false;
        var t2 = arguments[0];
        this.p = t2;
      }
      function he() {
      }
      function ce() {
        if (this.p0 = null, this.p1 = null, 0 === arguments.length)
          ce.call(this, new g(), new g());
        else if (1 === arguments.length) {
          var t2 = arguments[0];
          ce.call(this, t2.p0, t2.p1);
        } else if (2 === arguments.length) {
          var e2 = arguments[0], n2 = arguments[1];
          this.p0 = e2, this.p1 = n2;
        } else if (4 === arguments.length) {
          var i3 = arguments[0], r2 = arguments[1], s2 = arguments[2], o2 = arguments[3];
          ce.call(this, new g(i3, r2), new g(s2, o2));
        }
      }
      function fe() {
        if (this.matrix = null, 0 === arguments.length)
          this.matrix = Array(3).fill().map(function() {
            return Array(3);
          }), this.setAll(lt.FALSE);
        else if (1 === arguments.length) {
          if ("string" == typeof arguments[0]) {
            var t2 = arguments[0];
            fe.call(this), this.set(t2);
          } else if (arguments[0] instanceof fe) {
            var e2 = arguments[0];
            fe.call(this), this.matrix[L.INTERIOR][L.INTERIOR] = e2.matrix[L.INTERIOR][L.INTERIOR], this.matrix[L.INTERIOR][L.BOUNDARY] = e2.matrix[L.INTERIOR][L.BOUNDARY], this.matrix[L.INTERIOR][L.EXTERIOR] = e2.matrix[L.INTERIOR][L.EXTERIOR], this.matrix[L.BOUNDARY][L.INTERIOR] = e2.matrix[L.BOUNDARY][L.INTERIOR], this.matrix[L.BOUNDARY][L.BOUNDARY] = e2.matrix[L.BOUNDARY][L.BOUNDARY], this.matrix[L.BOUNDARY][L.EXTERIOR] = e2.matrix[L.BOUNDARY][L.EXTERIOR], this.matrix[L.EXTERIOR][L.INTERIOR] = e2.matrix[L.EXTERIOR][L.INTERIOR], this.matrix[L.EXTERIOR][L.BOUNDARY] = e2.matrix[L.EXTERIOR][L.BOUNDARY], this.matrix[L.EXTERIOR][L.EXTERIOR] = e2.matrix[L.EXTERIOR][L.EXTERIOR];
          }
        }
      }
      function ge() {
        this.areaBasePt = null, this.triangleCent3 = new g(), this.areasum2 = 0, this.cg3 = new g(), this.lineCentSum = new g(), this.totalLength = 0, this.ptCount = 0, this.ptCentSum = new g();
        var t2 = arguments[0];
        this.areaBasePt = null, this.add(t2);
      }
      function de(t2) {
        this.message = t2 || "";
      }
      function pe() {
        this.array_ = [];
      }
      function ve() {
        this.treeSet = new at(), this.list = new I();
      }
      function me() {
        if (this.geomFactory = null, this.inputPts = null, 1 === arguments.length) {
          var t2 = arguments[0];
          me.call(this, me.extractCoordinates(t2), t2.getFactory());
        } else if (2 === arguments.length) {
          var e2 = arguments[0], n2 = arguments[1];
          this.inputPts = ve.filterCoordinates(e2), this.geomFactory = n2;
        }
      }
      function ye() {
        this.origin = null;
        var t2 = arguments[0];
        this.origin = t2;
      }
      function xe() {
        this.inputGeom = null, this.factory = null, this.pruneEmptyGeometry = true, this.preserveGeometryCollectionType = true, this.preserveCollections = false, this.preserveType = false;
      }
      function Ee() {
        if (this.snapTolerance = 0, this.srcPts = null, this.seg = new ce(), this.allowSnappingToSourceVertices = false, this._isClosed = false, arguments[0] instanceof St && "number" == typeof arguments[1]) {
          var t2 = arguments[0], e2 = arguments[1];
          Ee.call(this, t2.getCoordinates(), e2);
        } else if (arguments[0] instanceof Array && "number" == typeof arguments[1]) {
          var n2 = arguments[0], i3 = arguments[1];
          this.srcPts = n2, this._isClosed = Ee.isClosed(n2), this.snapTolerance = i3;
        }
      }
      function Ie() {
        this.srcGeom = null;
        var t2 = arguments[0];
        this.srcGeom = t2;
      }
      function Ne() {
        if (xe.apply(this), this.snapTolerance = null, this.snapPts = null, this.isSelfSnap = false, 2 === arguments.length) {
          var t2 = arguments[0], e2 = arguments[1];
          this.snapTolerance = t2, this.snapPts = e2;
        } else if (3 === arguments.length) {
          var n2 = arguments[0], i3 = arguments[1], r2 = arguments[2];
          this.snapTolerance = n2, this.snapPts = i3, this.isSelfSnap = r2;
        }
      }
      function Ce() {
        this.isFirst = true, this.commonMantissaBitsCount = 53, this.commonBits = 0, this.commonSignExp = null;
      }
      function Se() {
        this.commonCoord = null, this.ccFilter = new we();
      }
      function we() {
        this.commonBitsX = new Ce(), this.commonBitsY = new Ce();
      }
      function Le() {
        this.trans = null;
        var t2 = arguments[0];
        this.trans = t2;
      }
      function Re() {
        this.parent = null, this.atStart = null, this.max = null, this.index = null, this.subcollectionIterator = null;
        var t2 = arguments[0];
        this.parent = t2, this.atStart = true, this.index = 0, this.max = t2.getNumGeometries();
      }
      function Te() {
        if (this.boundaryRule = V.OGC_SFS_BOUNDARY_RULE, this.isIn = null, this.numBoundaries = null, 0 === arguments.length)
          ;
        else if (1 === arguments.length) {
          var t2 = arguments[0];
          if (null === t2)
            throw new i2("Rule must be non-null");
          this.boundaryRule = t2;
        }
      }
      function Pe() {
      }
      function be() {
      }
      function Oe() {
        this.pts = null, this.data = null;
        var t2 = arguments[0], e2 = arguments[1];
        this.pts = t2, this.data = e2;
      }
      function _e() {
      }
      function Me() {
        this.bounds = null, this.item = null;
        var t2 = arguments[0], e2 = arguments[1];
        this.bounds = t2, this.item = e2;
      }
      function De() {
        this._size = null, this.items = null, this._size = 0, this.items = new I(), this.items.add(null);
      }
      function Ae() {
      }
      function Fe() {
      }
      function Ge() {
        if (this.childBoundables = new I(), this.bounds = null, this.level = null, 0 === arguments.length)
          ;
        else if (1 === arguments.length) {
          var t2 = arguments[0];
          this.level = t2;
        }
      }
      function qe() {
        this.boundable1 = null, this.boundable2 = null, this._distance = null, this.itemDistance = null;
        var t2 = arguments[0], e2 = arguments[1], n2 = arguments[2];
        this.boundable1 = t2, this.boundable2 = e2, this.itemDistance = n2, this._distance = this.distance();
      }
      function Be() {
        if (this.root = null, this.built = false, this.itemBoundables = new I(), this.nodeCapacity = null, 0 === arguments.length)
          Be.call(this, Be.DEFAULT_NODE_CAPACITY);
        else if (1 === arguments.length) {
          var t2 = arguments[0];
          f.isTrue(t2 > 1, "Node capacity must be greater than 1"), this.nodeCapacity = t2;
        }
      }
      function ze() {
      }
      function Ve() {
      }
      function ke() {
        if (0 === arguments.length)
          ke.call(this, ke.DEFAULT_NODE_CAPACITY);
        else if (1 === arguments.length) {
          var t2 = arguments[0];
          Be.call(this, t2);
        }
      }
      function Ye() {
        var t2 = arguments[0];
        Ge.call(this, t2);
      }
      function Ue() {
      }
      function Xe() {
        this.segString = null, this.coord = null, this.segmentIndex = null, this.segmentOctant = null, this._isInterior = null;
        var t2 = arguments[0], e2 = arguments[1], n2 = arguments[2], i3 = arguments[3];
        this.segString = t2, this.coord = new g(e2), this.segmentIndex = n2, this.segmentOctant = i3, this._isInterior = !e2.equals2D(t2.getCoordinate(n2));
      }
      function He() {
        this.nodeMap = new rt(), this.edge = null;
        var t2 = arguments[0];
        this.edge = t2;
      }
      function We() {
        this.nodeList = null, this.edge = null, this.nodeIt = null, this.currNode = null, this.nextNode = null, this.currSegIndex = 0;
        var t2 = arguments[0];
        this.nodeList = t2, this.edge = t2.getEdge(), this.nodeIt = t2.iterator(), this.readNextNode();
      }
      function je() {
      }
      function Ke() {
        this.nodeList = new He(this), this.pts = null, this.data = null;
        var t2 = arguments[0], e2 = arguments[1];
        this.pts = t2, this.data = e2;
      }
      function Ze() {
        this.tempEnv1 = new C(), this.tempEnv2 = new C(), this.overlapSeg1 = new ce(), this.overlapSeg2 = new ce();
      }
      function Qe() {
        this.pts = null, this.start = null, this.end = null, this.env = null, this.context = null, this.id = null;
        var t2 = arguments[0], e2 = arguments[1], n2 = arguments[2], i3 = arguments[3];
        this.pts = t2, this.start = e2, this.end = n2, this.context = i3;
      }
      function Je() {
      }
      function $e() {
      }
      function tn() {
      }
      function en() {
        if (this.segInt = null, 0 === arguments.length)
          ;
        else if (1 === arguments.length) {
          var t2 = arguments[0];
          this.setSegmentIntersector(t2);
        }
      }
      function nn() {
        if (this.monoChains = new I(), this.index = new ke(), this.idCounter = 0, this.nodedSegStrings = null, this.nOverlaps = 0, 0 === arguments.length)
          ;
        else if (1 === arguments.length) {
          var t2 = arguments[0];
          en.call(this, t2);
        }
      }
      function rn() {
        Ze.apply(this), this.si = null;
        var t2 = arguments[0];
        this.si = t2;
      }
      function sn() {
        if (this.pt = null, 1 === arguments.length) {
          var t2 = arguments[0];
          l.call(this, t2);
        } else if (2 === arguments.length) {
          var e2 = arguments[0], n2 = arguments[1];
          l.call(this, sn.msgWithCoord(e2, n2)), this.pt = new g(n2);
        }
      }
      function on() {
      }
      function an() {
        this.findAllIntersections = false, this.isCheckEndSegmentsOnly = false, this.li = null, this.interiorIntersection = null, this.intSegments = null, this.intersections = new I(), this.intersectionCount = 0, this.keepIntersections = true;
        var t2 = arguments[0];
        this.li = t2, this.interiorIntersection = null;
      }
      function un() {
        this.li = new ae(), this.segStrings = null, this.findAllIntersections = false, this.segInt = null, this._isValid = true;
        var t2 = arguments[0];
        this.segStrings = t2;
      }
      function ln() {
        this.nv = null;
        var t2 = arguments[0];
        this.nv = new un(ln.toSegmentStrings(t2));
      }
      function hn() {
        this.mapOp = null;
        var t2 = arguments[0];
        this.mapOp = t2;
      }
      function cn() {
      }
      function fn() {
        if (this.location = null, 1 === arguments.length) {
          if (arguments[0] instanceof Array) {
            var t2 = arguments[0];
            this.init(t2.length);
          } else if (Number.isInteger(arguments[0])) {
            var e2 = arguments[0];
            this.init(1), this.location[cn.ON] = e2;
          } else if (arguments[0] instanceof fn) {
            var n2 = arguments[0];
            if (this.init(n2.location.length), null !== n2)
              for (var i3 = 0; i3 < this.location.length; i3++)
                this.location[i3] = n2.location[i3];
          }
        } else if (3 === arguments.length) {
          var r2 = arguments[0], s2 = arguments[1], o2 = arguments[2];
          this.init(3), this.location[cn.ON] = r2, this.location[cn.LEFT] = s2, this.location[cn.RIGHT] = o2;
        }
      }
      function gn() {
        if (this.elt = new Array(2).fill(null), 1 === arguments.length) {
          if (Number.isInteger(arguments[0])) {
            var t2 = arguments[0];
            this.elt[0] = new fn(t2), this.elt[1] = new fn(t2);
          } else if (arguments[0] instanceof gn) {
            var e2 = arguments[0];
            this.elt[0] = new fn(e2.elt[0]), this.elt[1] = new fn(e2.elt[1]);
          }
        } else if (2 === arguments.length) {
          var n2 = arguments[0], i3 = arguments[1];
          this.elt[0] = new fn(L.NONE), this.elt[1] = new fn(L.NONE), this.elt[n2].setLocation(i3);
        } else if (3 === arguments.length) {
          var r2 = arguments[0], s2 = arguments[1], o2 = arguments[2];
          this.elt[0] = new fn(r2, s2, o2), this.elt[1] = new fn(r2, s2, o2);
        } else if (4 === arguments.length) {
          var a2 = arguments[0], u2 = arguments[1], l2 = arguments[2], h2 = arguments[3];
          this.elt[0] = new fn(L.NONE, L.NONE, L.NONE), this.elt[1] = new fn(L.NONE, L.NONE, L.NONE), this.elt[a2].setLocations(u2, l2, h2);
        }
      }
      function dn() {
        this.startDe = null, this.maxNodeDegree = -1, this.edges = new I(), this.pts = new I(), this.label = new gn(L.NONE), this.ring = null, this._isHole = null, this.shell = null, this.holes = new I(), this.geometryFactory = null;
        var t2 = arguments[0], e2 = arguments[1];
        this.geometryFactory = e2, this.computePoints(t2), this.computeRing();
      }
      function pn() {
        var t2 = arguments[0], e2 = arguments[1];
        dn.call(this, t2, e2);
      }
      function vn() {
        var t2 = arguments[0], e2 = arguments[1];
        dn.call(this, t2, e2);
      }
      function mn() {
        if (this.label = null, this._isInResult = false, this._isCovered = false, this._isCoveredSet = false, this._isVisited = false, 0 === arguments.length)
          ;
        else if (1 === arguments.length) {
          var t2 = arguments[0];
          this.label = t2;
        }
      }
      function yn() {
        mn.apply(this), this.coord = null, this.edges = null;
        var t2 = arguments[0], e2 = arguments[1];
        this.coord = t2, this.edges = e2, this.label = new gn(0, L.NONE);
      }
      function xn() {
        this.nodeMap = new rt(), this.nodeFact = null;
        var t2 = arguments[0];
        this.nodeFact = t2;
      }
      function En() {
        if (this.edge = null, this.label = null, this.node = null, this.p0 = null, this.p1 = null, this.dx = null, this.dy = null, this.quadrant = null, 1 === arguments.length) {
          var t2 = arguments[0];
          this.edge = t2;
        } else if (3 === arguments.length) {
          var e2 = arguments[0], n2 = arguments[1], i3 = arguments[2];
          En.call(this, e2, n2, i3, null);
        } else if (4 === arguments.length) {
          var r2 = arguments[0], s2 = arguments[1], o2 = arguments[2], a2 = arguments[3];
          En.call(this, r2), this.init(s2, o2), this.label = a2;
        }
      }
      function In() {
        this._isForward = null, this._isInResult = false, this._isVisited = false, this.sym = null, this.next = null, this.nextMin = null, this.edgeRing = null, this.minEdgeRing = null, this.depth = [0, -999, -999];
        var t2 = arguments[0], e2 = arguments[1];
        if (En.call(this, t2), this._isForward = e2, e2)
          this.init(t2.getCoordinate(0), t2.getCoordinate(1));
        else {
          var n2 = t2.getNumPoints() - 1;
          this.init(t2.getCoordinate(n2), t2.getCoordinate(n2 - 1));
        }
        this.computeDirectedLabel();
      }
      function Nn() {
      }
      function Cn() {
        if (this.edges = new I(), this.nodes = null, this.edgeEndList = new I(), 0 === arguments.length)
          this.nodes = new xn(new Nn());
        else if (1 === arguments.length) {
          var t2 = arguments[0];
          this.nodes = new xn(t2);
        }
      }
      function Sn() {
        this.geometryFactory = null, this.shellList = new I();
        var t2 = arguments[0];
        this.geometryFactory = t2;
      }
      function wn() {
        this.op = null, this.geometryFactory = null, this.ptLocator = null, this.lineEdgesList = new I(), this.resultLineList = new I();
        var t2 = arguments[0], e2 = arguments[1], n2 = arguments[2];
        this.op = t2, this.geometryFactory = e2, this.ptLocator = n2;
      }
      function Ln() {
        this.op = null, this.geometryFactory = null, this.resultPointList = new I();
        var t2 = arguments[0], e2 = arguments[1];
        arguments[2];
        this.op = t2, this.geometryFactory = e2;
      }
      function Rn() {
      }
      function Tn() {
        this.geom = null;
        var t2 = arguments[0];
        this.geom = t2;
      }
      function Pn() {
        this.edgeMap = new rt(), this.edgeList = null, this.ptInAreaLocation = [L.NONE, L.NONE];
      }
      function bn() {
        Pn.apply(this), this.resultAreaEdgeList = null, this.label = null, this.SCANNING_FOR_INCOMING = 1, this.LINKING_TO_OUTGOING = 2;
      }
      function On() {
        Nn.apply(this);
      }
      function _n() {
        this.mce = null, this.chainIndex = null;
        var t2 = arguments[0], e2 = arguments[1];
        this.mce = t2, this.chainIndex = e2;
      }
      function Mn() {
        if (this.label = null, this.xValue = null, this.eventType = null, this.insertEvent = null, this.deleteEventIndex = null, this.obj = null, 2 === arguments.length) {
          var t2 = arguments[0], e2 = arguments[1];
          this.eventType = Mn.DELETE, this.xValue = t2, this.insertEvent = e2;
        } else if (3 === arguments.length) {
          var n2 = arguments[0], i3 = arguments[1], r2 = arguments[2];
          this.eventType = Mn.INSERT, this.label = n2, this.xValue = i3, this.obj = r2;
        }
      }
      function Dn() {
      }
      function An() {
        this._hasIntersection = false, this.hasProper = false, this.hasProperInterior = false, this.properIntersectionPoint = null, this.li = null, this.includeProper = null, this.recordIsolated = null, this.isSelfIntersection = null, this.numIntersections = 0, this.numTests = 0, this.bdyNodes = null, this._isDone = false, this.isDoneWhenProperInt = false;
        var t2 = arguments[0], e2 = arguments[1], n2 = arguments[2];
        this.li = t2, this.includeProper = e2, this.recordIsolated = n2;
      }
      function Fn() {
        Dn.apply(this), this.events = new I(), this.nOverlaps = null;
      }
      function Gn() {
        this.min = r.POSITIVE_INFINITY, this.max = r.NEGATIVE_INFINITY;
      }
      function qn() {
      }
      function Bn() {
        Gn.apply(this), this.item = null;
        var t2 = arguments[0], e2 = arguments[1], n2 = arguments[2];
        this.min = t2, this.max = e2, this.item = n2;
      }
      function zn() {
        Gn.apply(this), this.node1 = null, this.node2 = null;
        var t2 = arguments[0], e2 = arguments[1];
        this.node1 = t2, this.node2 = e2, this.buildExtent(this.node1, this.node2);
      }
      function Vn() {
        this.leaves = new I(), this.root = null, this.level = 0;
      }
      function kn() {
        if (this.lines = null, this.isForcedToLineString = false, 1 === arguments.length) {
          var t2 = arguments[0];
          this.lines = t2;
        } else if (2 === arguments.length) {
          var e2 = arguments[0], n2 = arguments[1];
          this.lines = e2, this.isForcedToLineString = n2;
        }
      }
      function Yn() {
        this.items = new I();
      }
      function Un() {
        this.index = null;
        var t2 = arguments[0];
        if (!R(t2, Rt))
          throw new i2("Argument must be Polygonal");
        this.index = new Hn(t2);
      }
      function Xn() {
        this.counter = null;
        var t2 = arguments[0];
        this.counter = t2;
      }
      function Hn() {
        this.index = new Vn();
        var t2 = arguments[0];
        this.init(t2);
      }
      function Wn() {
        this.coord = null, this.segmentIndex = null, this.dist = null;
        var t2 = arguments[0], e2 = arguments[1], n2 = arguments[2];
        this.coord = new g(t2), this.segmentIndex = e2, this.dist = n2;
      }
      function jn() {
        this.nodeMap = new rt(), this.edge = null;
        var t2 = arguments[0];
        this.edge = t2;
      }
      function Kn() {
      }
      function Zn() {
        this.e = null, this.pts = null, this.startIndex = null, this.env1 = new C(), this.env2 = new C();
        var t2 = arguments[0];
        this.e = t2, this.pts = t2.getCoordinates();
        var e2 = new Kn();
        this.startIndex = e2.getChainStartIndices(this.pts);
      }
      function Qn() {
        this.depth = Array(2).fill().map(function() {
          return Array(3);
        });
        for (var t2 = 0; 2 > t2; t2++)
          for (var e2 = 0; 3 > e2; e2++)
            this.depth[t2][e2] = Qn.NULL_VALUE;
      }
      function Jn() {
        if (mn.apply(this), this.pts = null, this.env = null, this.eiList = new jn(this), this.name = null, this.mce = null, this._isIsolated = true, this.depth = new Qn(), this.depthDelta = 0, 1 === arguments.length) {
          var t2 = arguments[0];
          Jn.call(this, t2, null);
        } else if (2 === arguments.length) {
          var e2 = arguments[0], n2 = arguments[1];
          this.pts = e2, this.label = n2;
        }
      }
      function $n() {
        if (Cn.apply(this), this.parentGeom = null, this.lineEdgeMap = new te(), this.boundaryNodeRule = null, this.useBoundaryDeterminationRule = true, this.argIndex = null, this.boundaryNodes = null, this._hasTooFewPoints = false, this.invalidPoint = null, this.areaPtLocator = null, this.ptLocator = new Te(), 2 === arguments.length) {
          var t2 = arguments[0], e2 = arguments[1];
          $n.call(this, t2, e2, V.OGC_SFS_BOUNDARY_RULE);
        } else if (3 === arguments.length) {
          var n2 = arguments[0], i3 = arguments[1], r2 = arguments[2];
          this.argIndex = n2, this.parentGeom = i3, this.boundaryNodeRule = r2, null !== i3 && this.add(i3);
        }
      }
      function ti() {
        if (this.li = new ae(), this.resultPrecisionModel = null, this.arg = null, 1 === arguments.length) {
          var t2 = arguments[0];
          this.setComputationPrecision(t2.getPrecisionModel()), this.arg = new Array(1).fill(null), this.arg[0] = new $n(0, t2);
        } else if (2 === arguments.length) {
          var e2 = arguments[0], n2 = arguments[1];
          ti.call(this, e2, n2, V.OGC_SFS_BOUNDARY_RULE);
        } else if (3 === arguments.length) {
          var i3 = arguments[0], r2 = arguments[1], s2 = arguments[2];
          i3.getPrecisionModel().compareTo(r2.getPrecisionModel()) >= 0 ? this.setComputationPrecision(i3.getPrecisionModel()) : this.setComputationPrecision(r2.getPrecisionModel()), this.arg = new Array(2).fill(null), this.arg[0] = new $n(0, i3, s2), this.arg[1] = new $n(1, r2, s2);
        }
      }
      function ei() {
        this.pts = null, this._orientation = null;
        var t2 = arguments[0];
        this.pts = t2, this._orientation = ei.orientation(t2);
      }
      function ni() {
        this.edges = new I(), this.ocaMap = new rt();
      }
      function ii() {
        this.ptLocator = new Te(), this.geomFact = null, this.resultGeom = null, this.graph = null, this.edgeList = new ni(), this.resultPolyList = new I(), this.resultLineList = new I(), this.resultPointList = new I();
        var t2 = arguments[0], e2 = arguments[1];
        ti.call(this, t2, e2), this.graph = new Cn(new On()), this.geomFact = t2.getFactory();
      }
      function ri() {
        this.geom = new Array(2).fill(null), this.snapTolerance = null, this.cbr = null;
        var t2 = arguments[0], e2 = arguments[1];
        this.geom[0] = t2, this.geom[1] = e2, this.computeSnapTolerance();
      }
      function si() {
        this.geom = new Array(2).fill(null);
        var t2 = arguments[0], e2 = arguments[1];
        this.geom[0] = t2, this.geom[1] = e2;
      }
      function oi() {
        this.factory = null, this.interiorPoint = null, this.maxWidth = 0;
        var t2 = arguments[0];
        this.factory = t2.getFactory(), this.add(t2);
      }
      function ai() {
        this.poly = null, this.centreY = null, this.hiY = r.MAX_VALUE, this.loY = -r.MAX_VALUE;
        var t2 = arguments[0];
        this.poly = t2, this.hiY = t2.getEnvelopeInternal().getMaxY(), this.loY = t2.getEnvelopeInternal().getMinY(), this.centreY = oi.avg(this.loY, this.hiY);
      }
      function ui() {
        this.centroid = null, this.minDistance = r.MAX_VALUE, this.interiorPoint = null;
        var t2 = arguments[0];
        this.centroid = t2.getCentroid().getCoordinate(), this.addInterior(t2), null === this.interiorPoint && this.addEndpoints(t2);
      }
      function li() {
        this.centroid = null, this.minDistance = r.MAX_VALUE, this.interiorPoint = null;
        var t2 = arguments[0];
        this.centroid = t2.getCentroid().getCoordinate(), this.add(t2);
      }
      function hi() {
      }
      function ci() {
        this.p0 = null, this.p1 = null, this.p2 = null;
        var t2 = arguments[0], e2 = arguments[1], n2 = arguments[2];
        this.p0 = t2, this.p1 = e2, this.p2 = n2;
      }
      function fi() {
        this.input = null, this.extremalPts = null, this.centre = null, this.radius = 0;
        var t2 = arguments[0];
        this.input = t2;
      }
      function gi() {
        if (this.inputGeom = null, this.isConvex = null, this.convexHullPts = null, this.minBaseSeg = new ce(), this.minWidthPt = null, this.minPtIndex = null, this.minWidth = 0, 1 === arguments.length) {
          var t2 = arguments[0];
          gi.call(this, t2, false);
        } else if (2 === arguments.length) {
          var e2 = arguments[0], n2 = arguments[1];
          this.inputGeom = e2, this.isConvex = n2;
        }
      }
      function di() {
        this.inputGeom = null, this.distanceTolerance = null;
        var t2 = arguments[0];
        this.inputGeom = t2;
      }
      function pi() {
        xe.apply(this), this.distanceTolerance = null;
        var t2 = arguments[0];
        this.distanceTolerance = t2;
      }
      function vi() {
        this._orig = null, this._sym = null, this._next = null;
        var t2 = arguments[0];
        this._orig = t2;
      }
      function mi() {
        this._isMarked = false;
        var t2 = arguments[0];
        vi.call(this, t2);
      }
      function yi() {
        this.vertexMap = new te();
      }
      function xi() {
        this._isStart = false;
        var t2 = arguments[0];
        mi.call(this, t2);
      }
      function Ei() {
        yi.apply(this);
      }
      function Ii() {
        this.result = null, this.factory = null, this.graph = null, this.lines = new I(), this.nodeEdgeStack = new pe(), this.ringStartEdge = null, this.graph = new Ei();
      }
      function Ni() {
        this.items = new I(), this.subnode = new Array(4).fill(null);
      }
      function Ci() {
      }
      function Si(t2, e2) {
        var n2, i3, r2, s2, o2 = { 32: { d: 127, c: 128, b: 0, a: 0 }, 64: { d: 32752, c: 0, b: 0, a: 0 } }, a2 = { 32: 8, 64: 11 }[t2];
        if (s2 || (n2 = 0 > e2 || 0 > 1 / e2, isFinite(e2) || (s2 = o2[t2], n2 && (s2.d += 1 << t2 / 4 - 1), i3 = Math.pow(2, a2) - 1, r2 = 0)), !s2) {
          for (i3 = { 32: 127, 64: 1023 }[t2], r2 = Math.abs(e2); r2 >= 2; )
            i3++, r2 /= 2;
          for (; 1 > r2 && i3 > 0; )
            i3--, r2 *= 2;
          0 >= i3 && (r2 /= 2), 32 === t2 && i3 > 254 && (s2 = { d: n2 ? 255 : 127, c: 128, b: 0, a: 0 }, i3 = Math.pow(2, a2) - 1, r2 = 0);
        }
        return i3;
      }
      function wi() {
        this.pt = new g(), this.level = 0, this.env = null;
        var t2 = arguments[0];
        this.computeKey(t2);
      }
      function Li() {
        Ni.apply(this), this.env = null, this.centrex = null, this.centrey = null, this.level = null;
        var t2 = arguments[0], e2 = arguments[1];
        this.env = t2, this.level = e2, this.centrex = (t2.getMinX() + t2.getMaxX()) / 2, this.centrey = (t2.getMinY() + t2.getMaxY()) / 2;
      }
      function Ri() {
      }
      function Ti() {
        Ni.apply(this);
      }
      function Pi() {
        this.root = null, this.minExtent = 1, this.root = new Ti();
      }
      function bi(t2) {
        this.geometryFactory = t2 || new ie();
      }
      function Oi(t2) {
        this.geometryFactory = t2 || new ie(), this.precisionModel = this.geometryFactory.getPrecisionModel(), this.parser = new bi(this.geometryFactory);
      }
      function _i() {
        this.parser = new bi(this.geometryFactory);
      }
      function Mi(t2) {
        this.geometryFactory = t2 || new ie(), this.precisionModel = this.geometryFactory.getPrecisionModel(), this.parser = new re(this.geometryFactory);
      }
      function Di(t2) {
        return [t2.x, t2.y];
      }
      function Ai(t2) {
        this.geometryFactory = t2 || new ie();
      }
      function Fi() {
        if (this.noder = null, this.scaleFactor = null, this.offsetX = null, this.offsetY = null, this.isScaled = false, 2 === arguments.length) {
          var t2 = arguments[0], e2 = arguments[1];
          Fi.call(this, t2, e2, 0, 0);
        } else if (4 === arguments.length) {
          var n2 = arguments[0], i3 = arguments[1];
          arguments[2], arguments[3];
          this.noder = n2, this.scaleFactor = i3, this.isScaled = !this.isIntegerPrecision();
        }
      }
      function Gi() {
        if (this.inputGeom = null, this.isClosedEndpointsInInterior = true, this.nonSimpleLocation = null, 1 === arguments.length) {
          var t2 = arguments[0];
          this.inputGeom = t2;
        } else if (2 === arguments.length) {
          var e2 = arguments[0], n2 = arguments[1];
          this.inputGeom = e2, this.isClosedEndpointsInInterior = !n2.isInBoundary(2);
        }
      }
      function qi() {
        this.pt = null, this.isClosed = null, this.degree = null;
        var t2 = arguments[0];
        this.pt = t2, this.isClosed = false, this.degree = 0;
      }
      function Bi() {
        if (this.quadrantSegments = Bi.DEFAULT_QUADRANT_SEGMENTS, this.endCapStyle = Bi.CAP_ROUND, this.joinStyle = Bi.JOIN_ROUND, this.mitreLimit = Bi.DEFAULT_MITRE_LIMIT, this._isSingleSided = false, this.simplifyFactor = Bi.DEFAULT_SIMPLIFY_FACTOR, 0 === arguments.length)
          ;
        else if (1 === arguments.length) {
          var t2 = arguments[0];
          this.setQuadrantSegments(t2);
        } else if (2 === arguments.length) {
          var e2 = arguments[0], n2 = arguments[1];
          this.setQuadrantSegments(e2), this.setEndCapStyle(n2);
        } else if (4 === arguments.length) {
          var i3 = arguments[0], r2 = arguments[1], s2 = arguments[2], o2 = arguments[3];
          this.setQuadrantSegments(i3), this.setEndCapStyle(r2), this.setJoinStyle(s2), this.setMitreLimit(o2);
        }
      }
      function zi() {
        this.minIndex = -1, this.minCoord = null, this.minDe = null, this.orientedDe = null;
      }
      function Vi() {
        this.array_ = [];
      }
      function ki() {
        this.finder = null, this.dirEdgeList = new I(), this.nodes = new I(), this.rightMostCoord = null, this.env = null, this.finder = new zi();
      }
      function Yi() {
        this.inputLine = null, this.distanceTol = null, this.isDeleted = null, this.angleOrientation = he.COUNTERCLOCKWISE;
        var t2 = arguments[0];
        this.inputLine = t2;
      }
      function Ui() {
        this.ptList = null, this.precisionModel = null, this.minimimVertexDistance = 0, this.ptList = new I();
      }
      function Xi() {
        this.maxCurveSegmentError = 0, this.filletAngleQuantum = null, this.closingSegLengthFactor = 1, this.segList = null, this.distance = 0, this.precisionModel = null, this.bufParams = null, this.li = null, this.s0 = null, this.s1 = null, this.s2 = null, this.seg0 = new ce(), this.seg1 = new ce(), this.offset0 = new ce(), this.offset1 = new ce(), this.side = 0, this._hasNarrowConcaveAngle = false;
        var t2 = arguments[0], e2 = arguments[1], n2 = arguments[2];
        this.precisionModel = t2, this.bufParams = e2, this.li = new ae(), this.filletAngleQuantum = Math.PI / 2 / e2.getQuadrantSegments(), e2.getQuadrantSegments() >= 8 && e2.getJoinStyle() === Bi.JOIN_ROUND && (this.closingSegLengthFactor = Xi.MAX_CLOSING_SEG_LEN_FACTOR), this.init(n2);
      }
      function Hi() {
        this.distance = 0, this.precisionModel = null, this.bufParams = null;
        var t2 = arguments[0], e2 = arguments[1];
        this.precisionModel = t2, this.bufParams = e2;
      }
      function Wi() {
        this.subgraphs = null, this.seg = new ce(), this.cga = new he();
        var t2 = arguments[0];
        this.subgraphs = t2;
      }
      function ji() {
        this.upwardSeg = null, this.leftDepth = null;
        var t2 = arguments[0], e2 = arguments[1];
        this.upwardSeg = new ce(t2), this.leftDepth = e2;
      }
      function Ki() {
        this.inputGeom = null, this.distance = null, this.curveBuilder = null, this.curveList = new I();
        var t2 = arguments[0], e2 = arguments[1], n2 = arguments[2];
        this.inputGeom = t2, this.distance = e2, this.curveBuilder = n2;
      }
      function Zi() {
        this._hasIntersection = false, this.hasProper = false, this.hasProperInterior = false, this.hasInterior = false, this.properIntersectionPoint = null, this.li = null, this.isSelfIntersection = null, this.numIntersections = 0, this.numInteriorIntersections = 0, this.numProperIntersections = 0, this.numTests = 0;
        var t2 = arguments[0];
        this.li = t2;
      }
      function Qi() {
        this.bufParams = null, this.workingPrecisionModel = null, this.workingNoder = null, this.geomFact = null, this.graph = null, this.edgeList = new ni();
        var t2 = arguments[0];
        this.bufParams = t2;
      }
      function Ji() {
        this.li = new ae(), this.segStrings = null;
        var t2 = arguments[0];
        this.segStrings = t2;
      }
      function $i() {
        this.li = null, this.pt = null, this.originalPt = null, this.ptScaled = null, this.p0Scaled = null, this.p1Scaled = null, this.scaleFactor = null, this.minx = null, this.maxx = null, this.miny = null, this.maxy = null, this.corner = new Array(4).fill(null), this.safeEnv = null;
        var t2 = arguments[0], e2 = arguments[1], n2 = arguments[2];
        if (this.originalPt = t2, this.pt = t2, this.scaleFactor = e2, this.li = n2, 0 >= e2)
          throw new i2("Scale factor must be non-zero");
        1 !== e2 && (this.pt = new g(this.scale(t2.x), this.scale(t2.y)), this.p0Scaled = new g(), this.p1Scaled = new g()), this.initCorners(this.pt);
      }
      function tr() {
        this.tempEnv1 = new C(), this.selectedSegment = new ce();
      }
      function er() {
        this.index = null;
        var t2 = arguments[0];
        this.index = t2;
      }
      function nr() {
        tr.apply(this), this.hotPixel = null, this.parentEdge = null, this.hotPixelVertexIndex = null, this._isNodeAdded = false;
        var t2 = arguments[0], e2 = arguments[1], n2 = arguments[2];
        this.hotPixel = t2, this.parentEdge = e2, this.hotPixelVertexIndex = n2;
      }
      function ir() {
        this.li = null, this.interiorIntersections = null;
        var t2 = arguments[0];
        this.li = t2, this.interiorIntersections = new I();
      }
      function rr() {
        this.pm = null, this.li = null, this.scaleFactor = null, this.noder = null, this.pointSnapper = null, this.nodedSegStrings = null;
        var t2 = arguments[0];
        this.pm = t2, this.li = new ae(), this.li.setPrecisionModel(t2), this.scaleFactor = t2.getScale();
      }
      function sr() {
        if (this.argGeom = null, this.distance = null, this.bufParams = new Bi(), this.resultGeometry = null, this.saveException = null, 1 === arguments.length) {
          var t2 = arguments[0];
          this.argGeom = t2;
        } else if (2 === arguments.length) {
          var e2 = arguments[0], n2 = arguments[1];
          this.argGeom = e2, this.bufParams = n2;
        }
      }
      function or() {
        this.comps = null;
        var t2 = arguments[0];
        this.comps = t2;
      }
      function ar() {
        if (this.component = null, this.segIndex = null, this.pt = null, 2 === arguments.length) {
          var t2 = arguments[0], e2 = arguments[1];
          ar.call(this, t2, ar.INSIDE_AREA, e2);
        } else if (3 === arguments.length) {
          var n2 = arguments[0], i3 = arguments[1], r2 = arguments[2];
          this.component = n2, this.segIndex = i3, this.pt = r2;
        }
      }
      function ur() {
        this.pts = null;
        var t2 = arguments[0];
        this.pts = t2;
      }
      function lr() {
        this.locations = null;
        var t2 = arguments[0];
        this.locations = t2;
      }
      function hr() {
        if (this.geom = null, this.terminateDistance = 0, this.ptLocator = new Te(), this.minDistanceLocation = null, this.minDistance = r.MAX_VALUE, 2 === arguments.length) {
          var t2 = arguments[0], e2 = arguments[1];
          hr.call(this, t2, e2, 0);
        } else if (3 === arguments.length) {
          var n2 = arguments[0], i3 = arguments[1], s2 = arguments[2];
          this.geom = new Array(2).fill(null), this.geom[0] = n2, this.geom[1] = i3, this.terminateDistance = s2;
        }
      }
      function cr() {
        this.factory = null, this.directedEdges = new I(), this.coordinates = null;
        var t2 = arguments[0];
        this.factory = t2;
      }
      function fr() {
        this._isMarked = false, this._isVisited = false, this.data = null;
      }
      function gr() {
        fr.apply(this), this.parentEdge = null, this.from = null, this.to = null, this.p0 = null, this.p1 = null, this.sym = null, this.edgeDirection = null, this.quadrant = null, this.angle = null;
        var t2 = arguments[0], e2 = arguments[1], n2 = arguments[2], i3 = arguments[3];
        this.from = t2, this.to = e2, this.edgeDirection = i3, this.p0 = t2.getCoordinate(), this.p1 = n2;
        var r2 = this.p1.x - this.p0.x, s2 = this.p1.y - this.p0.y;
        this.quadrant = Je.quadrant(r2, s2), this.angle = Math.atan2(s2, r2);
      }
      function dr() {
        var t2 = arguments[0], e2 = arguments[1], n2 = arguments[2], i3 = arguments[3];
        gr.call(this, t2, e2, n2, i3);
      }
      function pr() {
        if (fr.apply(this), this.dirEdge = null, 0 === arguments.length)
          ;
        else if (2 === arguments.length) {
          var t2 = arguments[0], e2 = arguments[1];
          this.setDirectedEdges(t2, e2);
        }
      }
      function vr() {
        this.outEdges = new I(), this.sorted = false;
      }
      function mr() {
        if (fr.apply(this), this.pt = null, this.deStar = null, 1 === arguments.length) {
          var t2 = arguments[0];
          mr.call(this, t2, new vr());
        } else if (2 === arguments.length) {
          var e2 = arguments[0], n2 = arguments[1];
          this.pt = e2, this.deStar = n2;
        }
      }
      function yr() {
        pr.apply(this), this.line = null;
        var t2 = arguments[0];
        this.line = t2;
      }
      function xr() {
        this.nodeMap = new rt();
      }
      function Er() {
        this.edges = new J(), this.dirEdges = new J(), this.nodeMap = new xr();
      }
      function Ir() {
        Er.apply(this);
      }
      function Nr() {
        this.graph = new Ir(), this.mergedLineStrings = null, this.factory = null, this.edgeStrings = null;
      }
      function Cr() {
        this.edgeRing = null, this.next = null, this.label = -1;
        var t2 = arguments[0], e2 = arguments[1], n2 = arguments[2], i3 = arguments[3];
        gr.call(this, t2, e2, n2, i3);
      }
      function Sr() {
        pr.apply(this), this.line = null;
        var t2 = arguments[0];
        this.line = t2;
      }
      function wr() {
        this.factory = null, this.deList = new I(), this.lowestEdge = null, this.ring = null, this.ringPts = null, this.holes = null, this.shell = null, this._isHole = null, this._isProcessed = false, this._isIncludedSet = false, this._isIncluded = false;
        var t2 = arguments[0];
        this.factory = t2;
      }
      function Lr() {
      }
      function Rr() {
        Er.apply(this), this.factory = null;
        var t2 = arguments[0];
        this.factory = t2;
      }
      function Tr() {
        if (this.lineStringAdder = new Pr(this), this.graph = null, this.dangles = new I(), this.cutEdges = new I(), this.invalidRingLines = new I(), this.holeList = null, this.shellList = null, this.polyList = null, this.isCheckingRingsValid = true, this.extractOnlyPolygonal = null, this.geomFactory = null, 0 === arguments.length)
          Tr.call(this, false);
        else if (1 === arguments.length) {
          var t2 = arguments[0];
          this.extractOnlyPolygonal = t2;
        }
      }
      function Pr() {
        this.p = null;
        var t2 = arguments[0];
        this.p = t2;
      }
      function br() {
      }
      function Or() {
        if (this.edgeEnds = new I(), 1 === arguments.length) {
          var t2 = arguments[0];
          Or.call(this, null, t2);
        } else if (2 === arguments.length) {
          var e2 = (arguments[0], arguments[1]);
          En.call(this, e2.getEdge(), e2.getCoordinate(), e2.getDirectedCoordinate(), new gn(e2.getLabel())), this.insert(e2);
        }
      }
      function _r() {
        Pn.apply(this);
      }
      function Mr() {
        var t2 = arguments[0], e2 = arguments[1];
        yn.call(this, t2, e2);
      }
      function Dr() {
        Nn.apply(this);
      }
      function Ar() {
        this.li = new ae(), this.ptLocator = new Te(), this.arg = null, this.nodes = new xn(new Dr()), this.im = null, this.isolatedEdges = new I(), this.invalidPoint = null;
        var t2 = arguments[0];
        this.arg = t2;
      }
      function Fr() {
        this.rectEnv = null;
        var t2 = arguments[0];
        this.rectEnv = t2.getEnvelopeInternal();
      }
      function Gr() {
        this.li = new ae(), this.rectEnv = null, this.diagUp0 = null, this.diagUp1 = null, this.diagDown0 = null, this.diagDown1 = null;
        var t2 = arguments[0];
        this.rectEnv = t2, this.diagUp0 = new g(t2.getMinX(), t2.getMinY()), this.diagUp1 = new g(t2.getMaxX(), t2.getMaxY()), this.diagDown0 = new g(t2.getMinX(), t2.getMaxY()), this.diagDown1 = new g(t2.getMaxX(), t2.getMinY());
      }
      function qr() {
        this._isDone = false;
      }
      function Br() {
        this.rectangle = null, this.rectEnv = null;
        var t2 = arguments[0];
        this.rectangle = t2, this.rectEnv = t2.getEnvelopeInternal();
      }
      function zr() {
        qr.apply(this), this.rectEnv = null, this._intersects = false;
        var t2 = arguments[0];
        this.rectEnv = t2;
      }
      function Vr() {
        qr.apply(this), this.rectSeq = null, this.rectEnv = null, this._containsPoint = false;
        var t2 = arguments[0];
        this.rectSeq = t2.getExteriorRing().getCoordinateSequence(), this.rectEnv = t2.getEnvelopeInternal();
      }
      function kr() {
        qr.apply(this), this.rectEnv = null, this.rectIntersector = null, this.hasIntersection = false, this.p0 = new g(), this.p1 = new g();
        var t2 = arguments[0];
        this.rectEnv = t2.getEnvelopeInternal(), this.rectIntersector = new Gr(this.rectEnv);
      }
      function Yr() {
        if (this._relate = null, 2 === arguments.length) {
          var t2 = arguments[0], e2 = arguments[1];
          ti.call(this, t2, e2), this._relate = new Ar(this.arg);
        } else if (3 === arguments.length) {
          var n2 = arguments[0], i3 = arguments[1], r2 = arguments[2];
          ti.call(this, n2, i3, r2), this._relate = new Ar(this.arg);
        }
      }
      function Ur() {
        this.geomFactory = null, this.skipEmpty = false, this.inputGeoms = null;
        var t2 = arguments[0];
        this.geomFactory = Ur.extractFactory(t2), this.inputGeoms = t2;
      }
      function Xr() {
        this.pointGeom = null, this.otherGeom = null, this.geomFact = null;
        var t2 = arguments[0], e2 = arguments[1];
        this.pointGeom = t2, this.otherGeom = e2, this.geomFact = e2.getFactory();
      }
      function Hr() {
        this.sortIndex = -1, this.comps = null;
        var t2 = arguments[0], e2 = arguments[1];
        this.sortIndex = t2, this.comps = e2;
      }
      function Wr() {
        this.inputPolys = null, this.geomFactory = null;
        var t2 = arguments[0];
        this.inputPolys = t2, null === this.inputPolys && (this.inputPolys = new I());
      }
      function jr() {
        if (this.polygons = new I(), this.lines = new I(), this.points = new I(), this.geomFact = null, 1 === arguments.length) {
          if (R(arguments[0], v)) {
            var t2 = arguments[0];
            this.extract(t2);
          } else if (arguments[0] instanceof B) {
            var e2 = arguments[0];
            this.extract(e2);
          }
        } else if (2 === arguments.length) {
          var n2 = arguments[0], i3 = arguments[1];
          this.geomFact = i3, this.extract(n2);
        }
      }
      function Kr() {
        this.geometryFactory = new ie(), this.geomGraph = null, this.disconnectedRingcoord = null;
        var t2 = arguments[0];
        this.geomGraph = t2;
      }
      function Zr() {
        this.items = new I(), this.subnode = [null, null];
      }
      function Qr() {
        if (this.min = null, this.max = null, 0 === arguments.length)
          this.min = 0, this.max = 0;
        else if (1 === arguments.length) {
          var t2 = arguments[0];
          this.init(t2.min, t2.max);
        } else if (2 === arguments.length) {
          var e2 = arguments[0], n2 = arguments[1];
          this.init(e2, n2);
        }
      }
      function Jr() {
        this.pt = 0, this.level = 0, this.interval = null;
        var t2 = arguments[0];
        this.computeKey(t2);
      }
      function $r() {
        Zr.apply(this), this.interval = null, this.centre = null, this.level = null;
        var t2 = arguments[0], e2 = arguments[1];
        this.interval = t2, this.level = e2, this.centre = (t2.getMin() + t2.getMax()) / 2;
      }
      function ts() {
        Zr.apply(this);
      }
      function es() {
        this.root = null, this.minExtent = 1, this.root = new ts();
      }
      function ns() {
      }
      function is() {
        this.ring = null, this.tree = null, this.crossings = 0, this.interval = new Qr();
        var t2 = arguments[0];
        this.ring = t2, this.buildIndex();
      }
      function rs() {
        tr.apply(this), this.mcp = null, this.p = null;
        var t2 = arguments[0], e2 = arguments[1];
        this.mcp = t2, this.p = e2;
      }
      function ss() {
        this.nodes = new xn(new Dr());
      }
      function os() {
        this.li = new ae(), this.geomGraph = null, this.nodeGraph = new ss(), this.invalidPoint = null;
        var t2 = arguments[0];
        this.geomGraph = t2;
      }
      function as() {
        this.graph = null, this.rings = new I(), this.totalEnv = new C(), this.index = null, this.nestedPt = null;
        var t2 = arguments[0];
        this.graph = t2;
      }
      function us() {
        if (this.errorType = null, this.pt = null, 1 === arguments.length) {
          var t2 = arguments[0];
          us.call(this, t2, null);
        } else if (2 === arguments.length) {
          var e2 = arguments[0], n2 = arguments[1];
          this.errorType = e2, null !== n2 && (this.pt = n2.copy());
        }
      }
      function ls() {
        this.parentGeometry = null, this.isSelfTouchingRingFormingHoleValid = false, this.validErr = null;
        var t2 = arguments[0];
        this.parentGeometry = t2;
      }
      function hs() {
        _t.CoordinateOperation.apply(this), this.targetPM = null, this.removeCollapsed = true;
        var t2 = arguments[0], e2 = arguments[1];
        this.targetPM = t2, this.removeCollapsed = e2;
      }
      function cs() {
        this.targetPM = null, this.removeCollapsed = true, this.changePrecisionModel = false, this.isPointwise = false;
        var t2 = arguments[0];
        this.targetPM = t2;
      }
      function fs() {
        this.pts = null, this.usePt = null, this.distanceTolerance = null, this.seg = new ce();
        var t2 = arguments[0];
        this.pts = t2;
      }
      function gs() {
        this.inputGeom = null, this.distanceTolerance = null, this.isEnsureValidTopology = true;
        var t2 = arguments[0];
        this.inputGeom = t2;
      }
      function ds() {
        xe.apply(this), this.isEnsureValidTopology = true, this.distanceTolerance = null;
        var t2 = arguments[0], e2 = arguments[1];
        this.isEnsureValidTopology = t2, this.distanceTolerance = e2;
      }
      function ps() {
        if (this.parent = null, this.index = null, 2 === arguments.length) {
          var t2 = arguments[0], e2 = arguments[1];
          ps.call(this, t2, e2, null, -1);
        } else if (4 === arguments.length) {
          var n2 = arguments[0], i3 = arguments[1], r2 = arguments[2], s2 = arguments[3];
          ce.call(this, n2, i3), this.parent = r2, this.index = s2;
        }
      }
      function vs() {
        if (this.parentLine = null, this.segs = null, this.resultSegs = new I(), this.minimumSize = null, 1 === arguments.length) {
          var t2 = arguments[0];
          vs.call(this, t2, 2);
        } else if (2 === arguments.length) {
          var e2 = arguments[0], n2 = arguments[1];
          this.parentLine = e2, this.minimumSize = n2, this.init();
        }
      }
      function ms() {
        this.index = new Pi();
      }
      function ys() {
        this.querySeg = null, this.items = new I();
        var t2 = arguments[0];
        this.querySeg = t2;
      }
      function xs() {
        this.li = new ae(), this.inputIndex = new ms(), this.outputIndex = new ms(), this.line = null, this.linePts = null, this.distanceTolerance = 0;
        var t2 = arguments[0], e2 = arguments[1];
        this.inputIndex = t2, this.outputIndex = e2;
      }
      function Es() {
        this.inputIndex = new ms(), this.outputIndex = new ms(), this.distanceTolerance = 0;
      }
      function Is() {
        this.inputGeom = null, this.lineSimplifier = new Es(), this.linestringMap = null;
        var t2 = arguments[0];
        this.inputGeom = t2;
      }
      function Ns() {
        xe.apply(this), this.linestringMap = null;
        var t2 = arguments[0];
        this.linestringMap = t2;
      }
      function Cs() {
        this.tps = null;
        var t2 = arguments[0];
        this.tps = t2;
      }
      function Ss() {
        this.seg = null, this.segLen = null, this.splitPt = null, this.minimumLen = 0;
        var t2 = arguments[0];
        this.seg = t2, this.segLen = t2.getLength();
      }
      function ws() {
      }
      function Ls() {
      }
      function Rs() {
      }
      function Ts() {
        if (this.p = null, 1 === arguments.length) {
          var t2 = arguments[0];
          this.p = new g(t2);
        } else if (2 === arguments.length) {
          var e2 = arguments[0], n2 = arguments[1];
          this.p = new g(e2, n2);
        } else if (3 === arguments.length) {
          var i3 = arguments[0], r2 = arguments[1], s2 = arguments[2];
          this.p = new g(i3, r2, s2);
        }
      }
      function Ps() {
        this._isOnConstraint = null, this.constraint = null;
        var t2 = arguments[0];
        Ts.call(this, t2);
      }
      function bs() {
        this._rot = null, this.vertex = null, this.next = null, this.data = null;
      }
      function Os() {
        this.subdiv = null, this.isUsingTolerance = false;
        var t2 = arguments[0];
        this.subdiv = t2, this.isUsingTolerance = t2.getTolerance() > 0;
      }
      function _s() {
      }
      function Ms() {
        this.subdiv = null, this.lastEdge = null;
        var t2 = arguments[0];
        this.subdiv = t2, this.init();
      }
      function Ds() {
        if (this.seg = null, 1 === arguments.length) {
          if ("string" == typeof arguments[0]) {
            var t2 = arguments[0];
            l.call(this, t2);
          } else if (arguments[0] instanceof ce) {
            var e2 = arguments[0];
            l.call(this, "Locate failed to converge (at edge: " + e2 + ").  Possible causes include invalid Subdivision topology or very close sites"), this.seg = new ce(e2);
          }
        } else if (2 === arguments.length) {
          var n2 = arguments[0], i3 = arguments[1];
          l.call(this, Ds.msgWithSpatial(n2, i3)), this.seg = new ce(i3);
        }
      }
      function As() {
      }
      function Fs() {
        this.visitedKey = 0, this.quadEdges = new I(), this.startingEdge = null, this.tolerance = null, this.edgeCoincidenceTolerance = null, this.frameVertex = new Array(3).fill(null), this.frameEnv = null, this.locator = null, this.seg = new ce(), this.triEdges = new Array(3).fill(null);
        var t2 = arguments[0], e2 = arguments[1];
        this.tolerance = e2, this.edgeCoincidenceTolerance = e2 / Fs.EDGE_COINCIDENCE_TOL_FACTOR, this.createFrame(t2), this.startingEdge = this.initSubdiv(), this.locator = new Ms(this);
      }
      function Gs() {
      }
      function qs() {
        this.triList = new I();
      }
      function Bs() {
        this.triList = new I();
      }
      function zs() {
        this.coordList = new N(), this.triCoords = new I();
      }
      function Vs() {
        if (this.ls = null, this.data = null, 2 === arguments.length) {
          var t2 = arguments[0], e2 = arguments[1];
          this.ls = new ce(t2, e2);
        } else if (3 === arguments.length) {
          var n2 = arguments[0], i3 = arguments[1], r2 = arguments[2];
          this.ls = new ce(n2, i3), this.data = r2;
        } else if (6 === arguments.length) {
          var s2 = arguments[0], o2 = arguments[1], a2 = arguments[2], u2 = arguments[3], l2 = arguments[4], h2 = arguments[5];
          Vs.call(this, new g(s2, o2, a2), new g(u2, l2, h2));
        } else if (7 === arguments.length) {
          var c2 = arguments[0], f2 = arguments[1], d2 = arguments[2], p2 = arguments[3], v2 = arguments[4], m2 = arguments[5], y2 = arguments[6];
          Vs.call(this, new g(c2, f2, d2), new g(p2, v2, m2), y2);
        }
      }
      function ks() {
      }
      function Ys() {
        if (this.p = null, this.data = null, this.left = null, this.right = null, this.count = null, 2 === arguments.length) {
          var t2 = arguments[0], e2 = arguments[1];
          this.p = new g(t2), this.left = null, this.right = null, this.count = 1, this.data = e2;
        } else if (3 === arguments.length) {
          var n2 = arguments[0], i3 = arguments[1], r2 = arguments[2];
          this.p = new g(n2, i3), this.left = null, this.right = null, this.count = 1, this.data = r2;
        }
      }
      function Us() {
        if (this.root = null, this.numberOfNodes = null, this.tolerance = null, 0 === arguments.length)
          Us.call(this, 0);
        else if (1 === arguments.length) {
          var t2 = arguments[0];
          this.tolerance = t2;
        }
      }
      function Xs() {
        this.tolerance = null, this.matchNode = null, this.matchDist = 0, this.p = null;
        var t2 = arguments[0], e2 = arguments[1];
        this.p = t2, this.tolerance = e2;
      }
      function Hs() {
        this.initialVertices = null, this.segVertices = null, this.segments = new I(), this.subdiv = null, this.incDel = null, this.convexHull = null, this.splitFinder = new Ls(), this.kdt = null, this.vertexFactory = null, this.computeAreaEnv = null, this.splitPt = null, this.tolerance = null;
        var t2 = arguments[0], e2 = arguments[1];
        this.initialVertices = new I(t2), this.tolerance = e2, this.kdt = new Us(e2);
      }
      function Ws() {
        this.siteCoords = null, this.tolerance = 0, this.subdiv = null;
      }
      function js() {
        this.siteCoords = null, this.constraintLines = null, this.tolerance = 0, this.subdiv = null, this.constraintVertexMap = new rt();
      }
      function Ks() {
        this.siteCoords = null, this.tolerance = 0, this.subdiv = null, this.clipEnv = null, this.diagramEnv = null;
      }
      function Zs() {
      }
      Array.prototype.fill || (Array.prototype.fill = function(t2) {
        for (var e2 = Object(this), n2 = parseInt(e2.length, 10), i3 = arguments[1], r2 = parseInt(i3, 10) || 0, s2 = 0 > r2 ? Math.max(n2 + r2, 0) : Math.min(r2, n2), o2 = arguments[2], a2 = void 0 === o2 ? n2 : parseInt(o2, 10) || 0, u2 = 0 > a2 ? Math.max(n2 + a2, 0) : Math.min(a2, n2); u2 > s2; s2++)
          e2[s2] = t2;
        return e2;
      }), Number.isFinite = Number.isFinite || function(t2) {
        return "number" == typeof t2 && isFinite(t2);
      }, Number.isInteger = Number.isInteger || function(t2) {
        return "number" == typeof t2 && isFinite(t2) && Math.floor(t2) === t2;
      }, Number.parseFloat = Number.parseFloat || parseFloat, Number.isNaN = Number.isNaN || function(t2) {
        return t2 !== t2;
      }, Math.trunc = Math.trunc || function(t2) {
        return 0 > t2 ? Math.ceil(t2) : Math.floor(t2);
      }, e(n.prototype, { interfaces_: function() {
        return [];
      }, getClass: function() {
        return n;
      } }), n.equalsWithTolerance = function(t2, e2, n2) {
        return Math.abs(t2 - e2) <= n2;
      }, r.isNaN = function(t2) {
        return Number.isNaN(t2);
      }, r.doubleToLongBits = function(t2) {
        return t2;
      }, r.longBitsToDouble = function(t2) {
        return t2;
      }, r.isInfinite = function(t2) {
        return !Number.isFinite(t2);
      }, r.MAX_VALUE = Number.MAX_VALUE, h(c, l), e(c.prototype, { interfaces_: function() {
        return [];
      }, getClass: function() {
        return c;
      } }), e(f.prototype, { interfaces_: function() {
        return [];
      }, getClass: function() {
        return f;
      } }), f.shouldNeverReachHere = function() {
        if (0 === arguments.length)
          f.shouldNeverReachHere(null);
        else if (1 === arguments.length) {
          var t2 = arguments[0];
          throw new c("Should never reach here" + (null !== t2 ? ": " + t2 : ""));
        }
      }, f.isTrue = function() {
        if (1 === arguments.length) {
          var t2 = arguments[0];
          f.isTrue(t2, null);
        } else if (2 === arguments.length) {
          var e2 = arguments[0], n2 = arguments[1];
          if (!e2)
            throw null === n2 ? new c() : new c(n2);
        }
      }, f.equals = function() {
        if (2 === arguments.length) {
          var t2 = arguments[0], e2 = arguments[1];
          f.equals(t2, e2, null);
        } else if (3 === arguments.length) {
          var n2 = arguments[0], i3 = arguments[1], r2 = arguments[2];
          if (!i3.equals(n2))
            throw new c("Expected " + n2 + " but encountered " + i3 + (null !== r2 ? ": " + r2 : ""));
        }
      }, e(g.prototype, { setOrdinate: function(t2, e2) {
        switch (t2) {
          case g.X:
            this.x = e2;
            break;
          case g.Y:
            this.y = e2;
            break;
          case g.Z:
            this.z = e2;
            break;
          default:
            throw new i2("Invalid ordinate index: " + t2);
        }
      }, equals2D: function() {
        if (1 === arguments.length) {
          var t2 = arguments[0];
          return this.x !== t2.x ? false : this.y === t2.y;
        }
        if (2 === arguments.length) {
          var e2 = arguments[0], i3 = arguments[1];
          return n.equalsWithTolerance(this.x, e2.x, i3) ? !!n.equalsWithTolerance(this.y, e2.y, i3) : false;
        }
      }, getOrdinate: function(t2) {
        switch (t2) {
          case g.X:
            return this.x;
          case g.Y:
            return this.y;
          case g.Z:
            return this.z;
        }
        throw new i2("Invalid ordinate index: " + t2);
      }, equals3D: function(t2) {
        return this.x === t2.x && this.y === t2.y && (this.z === t2.z || r.isNaN(this.z) && r.isNaN(t2.z));
      }, equals: function(t2) {
        return t2 instanceof g ? this.equals2D(t2) : false;
      }, equalInZ: function(t2, e2) {
        return n.equalsWithTolerance(this.z, t2.z, e2);
      }, compareTo: function(t2) {
        var e2 = t2;
        return this.x < e2.x ? -1 : this.x > e2.x ? 1 : this.y < e2.y ? -1 : this.y > e2.y ? 1 : 0;
      }, clone: function() {
        try {
          var t2 = null;
          return t2;
        } catch (t3) {
          if (t3 instanceof CloneNotSupportedException)
            return f.shouldNeverReachHere("this shouldn't happen because this class is Cloneable"), null;
          throw t3;
        } finally {
        }
      }, copy: function() {
        return new g(this);
      }, toString: function() {
        return "(" + this.x + ", " + this.y + ", " + this.z + ")";
      }, distance3D: function(t2) {
        var e2 = this.x - t2.x, n2 = this.y - t2.y, i3 = this.z - t2.z;
        return Math.sqrt(e2 * e2 + n2 * n2 + i3 * i3);
      }, distance: function(t2) {
        var e2 = this.x - t2.x, n2 = this.y - t2.y;
        return Math.sqrt(e2 * e2 + n2 * n2);
      }, hashCode: function() {
        var t2 = 17;
        return t2 = 37 * t2 + g.hashCode(this.x), t2 = 37 * t2 + g.hashCode(this.y);
      }, setCoordinate: function(t2) {
        this.x = t2.x, this.y = t2.y, this.z = t2.z;
      }, interfaces_: function() {
        return [s, o, u];
      }, getClass: function() {
        return g;
      } }), g.hashCode = function() {
        if (1 === arguments.length) {
          var t2 = arguments[0], e2 = r.doubleToLongBits(t2);
          return Math.trunc(e2 ^ e2 >>> 32);
        }
      }, e(d.prototype, { compare: function(t2, e2) {
        var n2 = t2, i3 = e2, r2 = d.compare(n2.x, i3.x);
        if (0 !== r2)
          return r2;
        var s2 = d.compare(n2.y, i3.y);
        if (0 !== s2)
          return s2;
        if (this.dimensionsToTest <= 2)
          return 0;
        var o2 = d.compare(n2.z, i3.z);
        return o2;
      }, interfaces_: function() {
        return [a];
      }, getClass: function() {
        return d;
      } }), d.compare = function(t2, e2) {
        return e2 > t2 ? -1 : t2 > e2 ? 1 : r.isNaN(t2) ? r.isNaN(e2) ? 0 : -1 : r.isNaN(e2) ? 1 : 0;
      }, g.DimensionalComparator = d, g.serialVersionUID = 6683108902428367e3, g.NULL_ORDINATE = r.NaN, g.X = 0, g.Y = 1, g.Z = 2, p.prototype.hasNext = function() {
      }, p.prototype.next = function() {
      }, p.prototype.remove = function() {
      }, v.prototype.add = function() {
      }, v.prototype.addAll = function() {
      }, v.prototype.isEmpty = function() {
      }, v.prototype.iterator = function() {
      }, v.prototype.size = function() {
      }, v.prototype.toArray = function() {
      }, v.prototype.remove = function() {
      }, m.prototype = new Error(), m.prototype.name = "IndexOutOfBoundsException", y.prototype = Object.create(v.prototype), y.prototype.constructor = y, y.prototype.get = function() {
      }, y.prototype.set = function() {
      }, y.prototype.isEmpty = function() {
      }, x.prototype = new Error(), x.prototype.name = "NoSuchElementException", E.prototype = new Error(), E.prototype.name = "OperationNotSupported", I.prototype = Object.create(y.prototype), I.prototype.constructor = I, I.prototype.ensureCapacity = function() {
      }, I.prototype.interfaces_ = function() {
        return [y, v];
      }, I.prototype.add = function(t2) {
        return this.array_.push(t2), true;
      }, I.prototype.clear = function() {
        this.array_ = [];
      }, I.prototype.addAll = function(t2) {
        for (var e2 = t2.iterator(); e2.hasNext(); )
          this.add(e2.next());
        return true;
      }, I.prototype.set = function(t2, e2) {
        var n2 = this.array_[t2];
        return this.array_[t2] = e2, n2;
      }, I.prototype.iterator = function() {
        return new Qs(this);
      }, I.prototype.get = function(t2) {
        if (0 > t2 || t2 >= this.size())
          throw new m();
        return this.array_[t2];
      }, I.prototype.isEmpty = function() {
        return 0 === this.array_.length;
      }, I.prototype.size = function() {
        return this.array_.length;
      }, I.prototype.toArray = function() {
        for (var t2 = [], e2 = 0, n2 = this.array_.length; n2 > e2; e2++)
          t2.push(this.array_[e2]);
        return t2;
      }, I.prototype.remove = function(t2) {
        for (var e2 = false, n2 = 0, i3 = this.array_.length; i3 > n2; n2++)
          if (this.array_[n2] === t2) {
            this.array_.splice(n2, 1), e2 = true;
            break;
          }
        return e2;
      };
      var Qs = function(t2) {
        this.arrayList_ = t2, this.position_ = 0;
      };
      Qs.prototype.next = function() {
        if (this.position_ === this.arrayList_.size())
          throw new x();
        return this.arrayList_.get(this.position_++);
      }, Qs.prototype.hasNext = function() {
        return this.position_ < this.arrayList_.size();
      }, Qs.prototype.set = function(t2) {
        return this.arrayList_.set(this.position_ - 1, t2);
      }, Qs.prototype.remove = function() {
        throw new E();
      }, h(N, I), e(N.prototype, { getCoordinate: function(t2) {
        return this.get(t2);
      }, addAll: function() {
        if (2 === arguments.length) {
          for (var t2 = arguments[0], e2 = arguments[1], n2 = false, i3 = t2.iterator(); i3.hasNext(); )
            this.add(i3.next(), e2), n2 = true;
          return n2;
        }
        return I.prototype.addAll.apply(this, arguments);
      }, clone: function t2() {
        for (var t3 = I.prototype.clone.call(this), e2 = 0; e2 < this.size(); e2++)
          t3.add(e2, this.get(e2).copy());
        return t3;
      }, toCoordinateArray: function() {
        return this.toArray(N.coordArrayType);
      }, add: function() {
        if (1 === arguments.length) {
          var t2 = arguments[0];
          I.prototype.add.call(this, t2);
        } else if (2 === arguments.length) {
          if (arguments[0] instanceof Array && "boolean" == typeof arguments[1]) {
            var e2 = arguments[0], n2 = arguments[1];
            return this.add(e2, n2, true), true;
          }
          if (arguments[0] instanceof g && "boolean" == typeof arguments[1]) {
            var i3 = arguments[0], r2 = arguments[1];
            if (!r2 && this.size() >= 1) {
              var s2 = this.get(this.size() - 1);
              if (s2.equals2D(i3))
                return null;
            }
            I.prototype.add.call(this, i3);
          } else if (arguments[0] instanceof Object && "boolean" == typeof arguments[1]) {
            var o2 = arguments[0], a2 = arguments[1];
            return this.add(o2, a2), true;
          }
        } else if (3 === arguments.length) {
          if ("boolean" == typeof arguments[2] && arguments[0] instanceof Array && "boolean" == typeof arguments[1]) {
            var u2 = arguments[0], l2 = arguments[1], h2 = arguments[2];
            if (h2)
              for (var c2 = 0; c2 < u2.length; c2++)
                this.add(u2[c2], l2);
            else
              for (var c2 = u2.length - 1; c2 >= 0; c2--)
                this.add(u2[c2], l2);
            return true;
          }
          if ("boolean" == typeof arguments[2] && Number.isInteger(arguments[0]) && arguments[1] instanceof g) {
            var f2 = arguments[0], d2 = arguments[1], p2 = arguments[2];
            if (!p2) {
              var v2 = this.size();
              if (v2 > 0) {
                if (f2 > 0) {
                  var m2 = this.get(f2 - 1);
                  if (m2.equals2D(d2))
                    return null;
                }
                if (v2 > f2) {
                  var y2 = this.get(f2);
                  if (y2.equals2D(d2))
                    return null;
                }
              }
            }
            I.prototype.add.call(this, f2, d2);
          }
        } else if (4 === arguments.length) {
          var x2 = arguments[0], E2 = arguments[1], N2 = arguments[2], C2 = arguments[3], S2 = 1;
          N2 > C2 && (S2 = -1);
          for (var c2 = N2; c2 !== C2; c2 += S2)
            this.add(x2[c2], E2);
          return true;
        }
      }, closeRing: function() {
        this.size() > 0 && this.add(new g(this.get(0)), false);
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return N;
      } }), N.coordArrayType = new Array(0).fill(null), e(C.prototype, { getArea: function() {
        return this.getWidth() * this.getHeight();
      }, equals: function(t2) {
        if (!(t2 instanceof C))
          return false;
        var e2 = t2;
        return this.isNull() ? e2.isNull() : this.maxx === e2.getMaxX() && this.maxy === e2.getMaxY() && this.minx === e2.getMinX() && this.miny === e2.getMinY();
      }, intersection: function(t2) {
        if (this.isNull() || t2.isNull() || !this.intersects(t2))
          return new C();
        var e2 = this.minx > t2.minx ? this.minx : t2.minx, n2 = this.miny > t2.miny ? this.miny : t2.miny, i3 = this.maxx < t2.maxx ? this.maxx : t2.maxx, r2 = this.maxy < t2.maxy ? this.maxy : t2.maxy;
        return new C(e2, i3, n2, r2);
      }, isNull: function() {
        return this.maxx < this.minx;
      }, getMaxX: function() {
        return this.maxx;
      }, covers: function() {
        if (1 === arguments.length) {
          if (arguments[0] instanceof g) {
            var t2 = arguments[0];
            return this.covers(t2.x, t2.y);
          }
          if (arguments[0] instanceof C) {
            var e2 = arguments[0];
            return this.isNull() || e2.isNull() ? false : e2.getMinX() >= this.minx && e2.getMaxX() <= this.maxx && e2.getMinY() >= this.miny && e2.getMaxY() <= this.maxy;
          }
        } else if (2 === arguments.length) {
          var n2 = arguments[0], i3 = arguments[1];
          return this.isNull() ? false : n2 >= this.minx && n2 <= this.maxx && i3 >= this.miny && i3 <= this.maxy;
        }
      }, intersects: function() {
        if (1 === arguments.length) {
          if (arguments[0] instanceof C) {
            var t2 = arguments[0];
            return this.isNull() || t2.isNull() ? false : !(t2.minx > this.maxx || t2.maxx < this.minx || t2.miny > this.maxy || t2.maxy < this.miny);
          }
          if (arguments[0] instanceof g) {
            var e2 = arguments[0];
            return this.intersects(e2.x, e2.y);
          }
        } else if (2 === arguments.length) {
          var n2 = arguments[0], i3 = arguments[1];
          return this.isNull() ? false : !(n2 > this.maxx || n2 < this.minx || i3 > this.maxy || i3 < this.miny);
        }
      }, getMinY: function() {
        return this.miny;
      }, getMinX: function() {
        return this.minx;
      }, expandToInclude: function() {
        if (1 === arguments.length) {
          if (arguments[0] instanceof g) {
            var t2 = arguments[0];
            this.expandToInclude(t2.x, t2.y);
          } else if (arguments[0] instanceof C) {
            var e2 = arguments[0];
            if (e2.isNull())
              return null;
            this.isNull() ? (this.minx = e2.getMinX(), this.maxx = e2.getMaxX(), this.miny = e2.getMinY(), this.maxy = e2.getMaxY()) : (e2.minx < this.minx && (this.minx = e2.minx), e2.maxx > this.maxx && (this.maxx = e2.maxx), e2.miny < this.miny && (this.miny = e2.miny), e2.maxy > this.maxy && (this.maxy = e2.maxy));
          }
        } else if (2 === arguments.length) {
          var n2 = arguments[0], i3 = arguments[1];
          this.isNull() ? (this.minx = n2, this.maxx = n2, this.miny = i3, this.maxy = i3) : (n2 < this.minx && (this.minx = n2), n2 > this.maxx && (this.maxx = n2), i3 < this.miny && (this.miny = i3), i3 > this.maxy && (this.maxy = i3));
        }
      }, minExtent: function() {
        if (this.isNull())
          return 0;
        var t2 = this.getWidth(), e2 = this.getHeight();
        return e2 > t2 ? t2 : e2;
      }, getWidth: function() {
        return this.isNull() ? 0 : this.maxx - this.minx;
      }, compareTo: function(t2) {
        var e2 = t2;
        return this.isNull() ? e2.isNull() ? 0 : -1 : e2.isNull() ? 1 : this.minx < e2.minx ? -1 : this.minx > e2.minx ? 1 : this.miny < e2.miny ? -1 : this.miny > e2.miny ? 1 : this.maxx < e2.maxx ? -1 : this.maxx > e2.maxx ? 1 : this.maxy < e2.maxy ? -1 : this.maxy > e2.maxy ? 1 : 0;
      }, translate: function(t2, e2) {
        return this.isNull() ? null : void this.init(this.getMinX() + t2, this.getMaxX() + t2, this.getMinY() + e2, this.getMaxY() + e2);
      }, toString: function() {
        return "Env[" + this.minx + " : " + this.maxx + ", " + this.miny + " : " + this.maxy + "]";
      }, setToNull: function() {
        this.minx = 0, this.maxx = -1, this.miny = 0, this.maxy = -1;
      }, getHeight: function() {
        return this.isNull() ? 0 : this.maxy - this.miny;
      }, maxExtent: function() {
        if (this.isNull())
          return 0;
        var t2 = this.getWidth(), e2 = this.getHeight();
        return t2 > e2 ? t2 : e2;
      }, expandBy: function() {
        if (1 === arguments.length) {
          var t2 = arguments[0];
          this.expandBy(t2, t2);
        } else if (2 === arguments.length) {
          var e2 = arguments[0], n2 = arguments[1];
          if (this.isNull())
            return null;
          this.minx -= e2, this.maxx += e2, this.miny -= n2, this.maxy += n2, (this.minx > this.maxx || this.miny > this.maxy) && this.setToNull();
        }
      }, contains: function() {
        if (1 === arguments.length) {
          if (arguments[0] instanceof C) {
            var t2 = arguments[0];
            return this.covers(t2);
          }
          if (arguments[0] instanceof g) {
            var e2 = arguments[0];
            return this.covers(e2);
          }
        } else if (2 === arguments.length) {
          var n2 = arguments[0], i3 = arguments[1];
          return this.covers(n2, i3);
        }
      }, centre: function() {
        return this.isNull() ? null : new g((this.getMinX() + this.getMaxX()) / 2, (this.getMinY() + this.getMaxY()) / 2);
      }, init: function() {
        if (0 === arguments.length)
          this.setToNull();
        else if (1 === arguments.length) {
          if (arguments[0] instanceof g) {
            var t2 = arguments[0];
            this.init(t2.x, t2.x, t2.y, t2.y);
          } else if (arguments[0] instanceof C) {
            var e2 = arguments[0];
            this.minx = e2.minx, this.maxx = e2.maxx, this.miny = e2.miny, this.maxy = e2.maxy;
          }
        } else if (2 === arguments.length) {
          var n2 = arguments[0], i3 = arguments[1];
          this.init(n2.x, i3.x, n2.y, i3.y);
        } else if (4 === arguments.length) {
          var r2 = arguments[0], s2 = arguments[1], o2 = arguments[2], a2 = arguments[3];
          s2 > r2 ? (this.minx = r2, this.maxx = s2) : (this.minx = s2, this.maxx = r2), a2 > o2 ? (this.miny = o2, this.maxy = a2) : (this.miny = a2, this.maxy = o2);
        }
      }, getMaxY: function() {
        return this.maxy;
      }, distance: function(t2) {
        if (this.intersects(t2))
          return 0;
        var e2 = 0;
        this.maxx < t2.minx ? e2 = t2.minx - this.maxx : this.minx > t2.maxx && (e2 = this.minx - t2.maxx);
        var n2 = 0;
        return this.maxy < t2.miny ? n2 = t2.miny - this.maxy : this.miny > t2.maxy && (n2 = this.miny - t2.maxy), 0 === e2 ? n2 : 0 === n2 ? e2 : Math.sqrt(e2 * e2 + n2 * n2);
      }, hashCode: function() {
        var t2 = 17;
        return t2 = 37 * t2 + g.hashCode(this.minx), t2 = 37 * t2 + g.hashCode(this.maxx), t2 = 37 * t2 + g.hashCode(this.miny), t2 = 37 * t2 + g.hashCode(this.maxy);
      }, interfaces_: function() {
        return [s, u];
      }, getClass: function() {
        return C;
      } }), C.intersects = function() {
        if (3 === arguments.length) {
          var t2 = arguments[0], e2 = arguments[1], n2 = arguments[2];
          return n2.x >= (t2.x < e2.x ? t2.x : e2.x) && n2.x <= (t2.x > e2.x ? t2.x : e2.x) && n2.y >= (t2.y < e2.y ? t2.y : e2.y) && n2.y <= (t2.y > e2.y ? t2.y : e2.y);
        }
        if (4 === arguments.length) {
          var i3 = arguments[0], r2 = arguments[1], s2 = arguments[2], o2 = arguments[3], a2 = Math.min(s2.x, o2.x), u2 = Math.max(s2.x, o2.x), l2 = Math.min(i3.x, r2.x), h2 = Math.max(i3.x, r2.x);
          return l2 > u2 ? false : a2 > h2 ? false : (a2 = Math.min(s2.y, o2.y), u2 = Math.max(s2.y, o2.y), l2 = Math.min(i3.y, r2.y), h2 = Math.max(i3.y, r2.y), l2 > u2 ? false : !(a2 > h2));
        }
      }, C.serialVersionUID = 5873921885273102e3, h(w, S), e(w.prototype, { interfaces_: function() {
        return [];
      }, getClass: function() {
        return w;
      } }), e(L.prototype, { interfaces_: function() {
        return [];
      }, getClass: function() {
        return L;
      } }), L.toLocationSymbol = function(t2) {
        switch (t2) {
          case L.EXTERIOR:
            return "e";
          case L.BOUNDARY:
            return "b";
          case L.INTERIOR:
            return "i";
          case L.NONE:
            return "-";
        }
        throw new i2("Unknown location value: " + t2);
      }, L.INTERIOR = 0, L.BOUNDARY = 1, L.EXTERIOR = 2, L.NONE = -1, e(T.prototype, { interfaces_: function() {
        return [];
      }, getClass: function() {
        return T;
      } }), T.log10 = function(t2) {
        var e2 = Math.log(t2);
        return r.isInfinite(e2) ? e2 : r.isNaN(e2) ? e2 : e2 / T.LOG_10;
      }, T.min = function(t2, e2, n2, i3) {
        var r2 = t2;
        return r2 > e2 && (r2 = e2), r2 > n2 && (r2 = n2), r2 > i3 && (r2 = i3), r2;
      }, T.clamp = function() {
        if ("number" == typeof arguments[2] && "number" == typeof arguments[0] && "number" == typeof arguments[1]) {
          var t2 = arguments[0], e2 = arguments[1], n2 = arguments[2];
          return e2 > t2 ? e2 : t2 > n2 ? n2 : t2;
        }
        if (Number.isInteger(arguments[2]) && Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {
          var i3 = arguments[0], r2 = arguments[1], s2 = arguments[2];
          return r2 > i3 ? r2 : i3 > s2 ? s2 : i3;
        }
      }, T.wrap = function(t2, e2) {
        return 0 > t2 ? e2 - -t2 % e2 : t2 % e2;
      }, T.max = function() {
        if (3 === arguments.length) {
          var t2 = arguments[0], e2 = arguments[1], n2 = arguments[2], i3 = t2;
          return e2 > i3 && (i3 = e2), n2 > i3 && (i3 = n2), i3;
        }
        if (4 === arguments.length) {
          var r2 = arguments[0], s2 = arguments[1], o2 = arguments[2], a2 = arguments[3], i3 = r2;
          return s2 > i3 && (i3 = s2), o2 > i3 && (i3 = o2), a2 > i3 && (i3 = a2), i3;
        }
      }, T.average = function(t2, e2) {
        return (t2 + e2) / 2;
      }, T.LOG_10 = Math.log(10), P.prototype.append = function(t2) {
        this.str += t2;
      }, P.prototype.setCharAt = function(t2, e2) {
        return this.str.substr(0, t2) + e2 + this.str.substr(t2 + 1);
      }, P.prototype.toString = function(t2) {
        return this.str;
      }, b.prototype.intValue = function() {
        return this.value;
      }, b.prototype.compareTo = function(t2) {
        return this.value < t2 ? -1 : this.value > t2 ? 1 : 0;
      }, b.isNaN = function(t2) {
        return Number.isNaN(t2);
      }, O.isWhitespace = function(t2) {
        return 32 >= t2 && t2 >= 0 || 127 == t2;
      }, O.toUpperCase = function(t2) {
        return t2.toUpperCase();
      }, e(_.prototype, { le: function(t2) {
        return this.hi < t2.hi || this.hi === t2.hi && this.lo <= t2.lo;
      }, extractSignificantDigits: function(t2, e2) {
        var n2 = this.abs(), i3 = _.magnitude(n2.hi), r2 = _.TEN.pow(i3);
        n2 = n2.divide(r2), n2.gt(_.TEN) ? (n2 = n2.divide(_.TEN), i3 += 1) : n2.lt(_.ONE) && (n2 = n2.multiply(_.TEN), i3 -= 1);
        for (var s2 = i3 + 1, o2 = new P(), a2 = _.MAX_PRINT_DIGITS - 1, u2 = 0; a2 >= u2; u2++) {
          t2 && u2 === s2 && o2.append(".");
          var l2 = Math.trunc(n2.hi);
          if (0 > l2)
            break;
          var h2 = false, c2 = 0;
          l2 > 9 ? (h2 = true, c2 = "9") : c2 = "0" + l2, o2.append(c2), n2 = n2.subtract(_.valueOf(l2)).multiply(_.TEN), h2 && n2.selfAdd(_.TEN);
          var f2 = true, g2 = _.magnitude(n2.hi);
          if (0 > g2 && Math.abs(g2) >= a2 - u2 && (f2 = false), !f2)
            break;
        }
        return e2[0] = i3, o2.toString();
      }, sqr: function() {
        return this.multiply(this);
      }, doubleValue: function() {
        return this.hi + this.lo;
      }, subtract: function() {
        if (arguments[0] instanceof _) {
          var t2 = arguments[0];
          return this.add(t2.negate());
        }
        if ("number" == typeof arguments[0]) {
          var e2 = arguments[0];
          return this.add(-e2);
        }
      }, equals: function() {
        if (1 === arguments.length) {
          var t2 = arguments[0];
          return this.hi === t2.hi && this.lo === t2.lo;
        }
      }, isZero: function() {
        return 0 === this.hi && 0 === this.lo;
      }, selfSubtract: function() {
        if (arguments[0] instanceof _) {
          var t2 = arguments[0];
          return this.isNaN() ? this : this.selfAdd(-t2.hi, -t2.lo);
        }
        if ("number" == typeof arguments[0]) {
          var e2 = arguments[0];
          return this.isNaN() ? this : this.selfAdd(-e2, 0);
        }
      }, getSpecialNumberString: function() {
        return this.isZero() ? "0.0" : this.isNaN() ? "NaN " : null;
      }, min: function(t2) {
        return this.le(t2) ? this : t2;
      }, selfDivide: function() {
        if (1 === arguments.length) {
          if (arguments[0] instanceof _) {
            var t2 = arguments[0];
            return this.selfDivide(t2.hi, t2.lo);
          }
          if ("number" == typeof arguments[0]) {
            var e2 = arguments[0];
            return this.selfDivide(e2, 0);
          }
        } else if (2 === arguments.length) {
          var n2 = arguments[0], i3 = arguments[1], r2 = null, s2 = null, o2 = null, a2 = null, u2 = null, l2 = null, h2 = null, c2 = null;
          return u2 = this.hi / n2, l2 = _.SPLIT * u2, r2 = l2 - u2, c2 = _.SPLIT * n2, r2 = l2 - r2, s2 = u2 - r2, o2 = c2 - n2, h2 = u2 * n2, o2 = c2 - o2, a2 = n2 - o2, c2 = r2 * o2 - h2 + r2 * a2 + s2 * o2 + s2 * a2, l2 = (this.hi - h2 - c2 + this.lo - u2 * i3) / n2, c2 = u2 + l2, this.hi = c2, this.lo = u2 - c2 + l2, this;
        }
      }, dump: function() {
        return "DD<" + this.hi + ", " + this.lo + ">";
      }, divide: function() {
        if (arguments[0] instanceof _) {
          var t2 = arguments[0], e2 = null, n2 = null, i3 = null, s2 = null, o2 = null, a2 = null, u2 = null, l2 = null;
          o2 = this.hi / t2.hi, a2 = _.SPLIT * o2, e2 = a2 - o2, l2 = _.SPLIT * t2.hi, e2 = a2 - e2, n2 = o2 - e2, i3 = l2 - t2.hi, u2 = o2 * t2.hi, i3 = l2 - i3, s2 = t2.hi - i3, l2 = e2 * i3 - u2 + e2 * s2 + n2 * i3 + n2 * s2, a2 = (this.hi - u2 - l2 + this.lo - o2 * t2.lo) / t2.hi, l2 = o2 + a2;
          var h2 = l2, c2 = o2 - l2 + a2;
          return new _(h2, c2);
        }
        if ("number" == typeof arguments[0]) {
          var f2 = arguments[0];
          return r.isNaN(f2) ? _.createNaN() : _.copy(this).selfDivide(f2, 0);
        }
      }, ge: function(t2) {
        return this.hi > t2.hi || this.hi === t2.hi && this.lo >= t2.lo;
      }, pow: function(t2) {
        if (0 === t2)
          return _.valueOf(1);
        var e2 = new _(this), n2 = _.valueOf(1), i3 = Math.abs(t2);
        if (i3 > 1)
          for (; i3 > 0; )
            i3 % 2 === 1 && n2.selfMultiply(e2), i3 /= 2, i3 > 0 && (e2 = e2.sqr());
        else
          n2 = e2;
        return 0 > t2 ? n2.reciprocal() : n2;
      }, ceil: function() {
        if (this.isNaN())
          return _.NaN;
        var t2 = Math.ceil(this.hi), e2 = 0;
        return t2 === this.hi && (e2 = Math.ceil(this.lo)), new _(t2, e2);
      }, compareTo: function(t2) {
        var e2 = t2;
        return this.hi < e2.hi ? -1 : this.hi > e2.hi ? 1 : this.lo < e2.lo ? -1 : this.lo > e2.lo ? 1 : 0;
      }, rint: function() {
        if (this.isNaN())
          return this;
        var t2 = this.add(0.5);
        return t2.floor();
      }, setValue: function() {
        if (arguments[0] instanceof _) {
          var t2 = arguments[0];
          return this.init(t2), this;
        }
        if ("number" == typeof arguments[0]) {
          var e2 = arguments[0];
          return this.init(e2), this;
        }
      }, max: function(t2) {
        return this.ge(t2) ? this : t2;
      }, sqrt: function() {
        if (this.isZero())
          return _.valueOf(0);
        if (this.isNegative())
          return _.NaN;
        var t2 = 1 / Math.sqrt(this.hi), e2 = this.hi * t2, n2 = _.valueOf(e2), i3 = this.subtract(n2.sqr()), r2 = i3.hi * (0.5 * t2);
        return n2.add(r2);
      }, selfAdd: function() {
        if (1 === arguments.length) {
          if (arguments[0] instanceof _) {
            var t2 = arguments[0];
            return this.selfAdd(t2.hi, t2.lo);
          }
          if ("number" == typeof arguments[0]) {
            var e2 = arguments[0], n2 = null, i3 = null, r2 = null, s2 = null, o2 = null, a2 = null;
            return r2 = this.hi + e2, o2 = r2 - this.hi, s2 = r2 - o2, s2 = e2 - o2 + (this.hi - s2), a2 = s2 + this.lo, n2 = r2 + a2, i3 = a2 + (r2 - n2), this.hi = n2 + i3, this.lo = i3 + (n2 - this.hi), this;
          }
        } else if (2 === arguments.length) {
          var u2 = arguments[0], l2 = arguments[1], n2 = null, i3 = null, h2 = null, c2 = null, r2 = null, s2 = null, o2 = null, a2 = null;
          r2 = this.hi + u2, h2 = this.lo + l2, o2 = r2 - this.hi, a2 = h2 - this.lo, s2 = r2 - o2, c2 = h2 - a2, s2 = u2 - o2 + (this.hi - s2), c2 = l2 - a2 + (this.lo - c2), o2 = s2 + h2, n2 = r2 + o2, i3 = o2 + (r2 - n2), o2 = c2 + i3;
          var f2 = n2 + o2, g2 = o2 + (n2 - f2);
          return this.hi = f2, this.lo = g2, this;
        }
      }, selfMultiply: function() {
        if (1 === arguments.length) {
          if (arguments[0] instanceof _) {
            var t2 = arguments[0];
            return this.selfMultiply(t2.hi, t2.lo);
          }
          if ("number" == typeof arguments[0]) {
            var e2 = arguments[0];
            return this.selfMultiply(e2, 0);
          }
        } else if (2 === arguments.length) {
          var n2 = arguments[0], i3 = arguments[1], r2 = null, s2 = null, o2 = null, a2 = null, u2 = null, l2 = null;
          u2 = _.SPLIT * this.hi, r2 = u2 - this.hi, l2 = _.SPLIT * n2, r2 = u2 - r2, s2 = this.hi - r2, o2 = l2 - n2, u2 = this.hi * n2, o2 = l2 - o2, a2 = n2 - o2, l2 = r2 * o2 - u2 + r2 * a2 + s2 * o2 + s2 * a2 + (this.hi * i3 + this.lo * n2);
          var h2 = u2 + l2;
          r2 = u2 - h2;
          var c2 = l2 + r2;
          return this.hi = h2, this.lo = c2, this;
        }
      }, selfSqr: function() {
        return this.selfMultiply(this);
      }, floor: function() {
        if (this.isNaN())
          return _.NaN;
        var t2 = Math.floor(this.hi), e2 = 0;
        return t2 === this.hi && (e2 = Math.floor(this.lo)), new _(t2, e2);
      }, negate: function() {
        return this.isNaN() ? this : new _(-this.hi, -this.lo);
      }, clone: function() {
        try {
          return null;
        } catch (t2) {
          if (t2 instanceof CloneNotSupportedException)
            return null;
          throw t2;
        } finally {
        }
      }, multiply: function() {
        if (arguments[0] instanceof _) {
          var t2 = arguments[0];
          return t2.isNaN() ? _.createNaN() : _.copy(this).selfMultiply(t2);
        }
        if ("number" == typeof arguments[0]) {
          var e2 = arguments[0];
          return r.isNaN(e2) ? _.createNaN() : _.copy(this).selfMultiply(e2, 0);
        }
      }, isNaN: function() {
        return r.isNaN(this.hi);
      }, intValue: function() {
        return Math.trunc(this.hi);
      }, toString: function() {
        var t2 = _.magnitude(this.hi);
        return t2 >= -3 && 20 >= t2 ? this.toStandardNotation() : this.toSciNotation();
      }, toStandardNotation: function() {
        var t2 = this.getSpecialNumberString();
        if (null !== t2)
          return t2;
        var e2 = new Array(1).fill(null), n2 = this.extractSignificantDigits(true, e2), i3 = e2[0] + 1, r2 = n2;
        if ("." === n2.charAt(0))
          r2 = "0" + n2;
        else if (0 > i3)
          r2 = "0." + _.stringOfChar("0", -i3) + n2;
        else if (-1 === n2.indexOf(".")) {
          var s2 = i3 - n2.length, o2 = _.stringOfChar("0", s2);
          r2 = n2 + o2 + ".0";
        }
        return this.isNegative() ? "-" + r2 : r2;
      }, reciprocal: function() {
        var t2 = null, e2 = null, n2 = null, i3 = null, r2 = null, s2 = null, o2 = null, a2 = null;
        r2 = 1 / this.hi, s2 = _.SPLIT * r2, t2 = s2 - r2, a2 = _.SPLIT * this.hi, t2 = s2 - t2, e2 = r2 - t2, n2 = a2 - this.hi, o2 = r2 * this.hi, n2 = a2 - n2, i3 = this.hi - n2, a2 = t2 * n2 - o2 + t2 * i3 + e2 * n2 + e2 * i3, s2 = (1 - o2 - a2 - r2 * this.lo) / this.hi;
        var u2 = r2 + s2, l2 = r2 - u2 + s2;
        return new _(u2, l2);
      }, toSciNotation: function() {
        if (this.isZero())
          return _.SCI_NOT_ZERO;
        var t2 = this.getSpecialNumberString();
        if (null !== t2)
          return t2;
        var e2 = new Array(1).fill(null), n2 = this.extractSignificantDigits(false, e2), i3 = _.SCI_NOT_EXPONENT_CHAR + e2[0];
        if ("0" === n2.charAt(0))
          throw new IllegalStateException("Found leading zero: " + n2);
        var r2 = "";
        n2.length > 1 && (r2 = n2.substring(1));
        var s2 = n2.charAt(0) + "." + r2;
        return this.isNegative() ? "-" + s2 + i3 : s2 + i3;
      }, abs: function() {
        return this.isNaN() ? _.NaN : this.isNegative() ? this.negate() : new _(this);
      }, isPositive: function() {
        return this.hi > 0 || 0 === this.hi && this.lo > 0;
      }, lt: function(t2) {
        return this.hi < t2.hi || this.hi === t2.hi && this.lo < t2.lo;
      }, add: function() {
        if (arguments[0] instanceof _) {
          var t2 = arguments[0];
          return _.copy(this).selfAdd(t2);
        }
        if ("number" == typeof arguments[0]) {
          var e2 = arguments[0];
          return _.copy(this).selfAdd(e2);
        }
      }, init: function() {
        if (1 === arguments.length) {
          if ("number" == typeof arguments[0]) {
            var t2 = arguments[0];
            this.hi = t2, this.lo = 0;
          } else if (arguments[0] instanceof _) {
            var e2 = arguments[0];
            this.hi = e2.hi, this.lo = e2.lo;
          }
        } else if (2 === arguments.length) {
          var n2 = arguments[0], i3 = arguments[1];
          this.hi = n2, this.lo = i3;
        }
      }, gt: function(t2) {
        return this.hi > t2.hi || this.hi === t2.hi && this.lo > t2.lo;
      }, isNegative: function() {
        return this.hi < 0 || 0 === this.hi && this.lo < 0;
      }, trunc: function() {
        return this.isNaN() ? _.NaN : this.isPositive() ? this.floor() : this.ceil();
      }, signum: function() {
        return this.hi > 0 ? 1 : this.hi < 0 ? -1 : this.lo > 0 ? 1 : this.lo < 0 ? -1 : 0;
      }, interfaces_: function() {
        return [u, s, o];
      }, getClass: function() {
        return _;
      } }), _.sqr = function(t2) {
        return _.valueOf(t2).selfMultiply(t2);
      }, _.valueOf = function() {
        if ("string" == typeof arguments[0]) {
          var t2 = arguments[0];
          return _.parse(t2);
        }
        if ("number" == typeof arguments[0]) {
          var e2 = arguments[0];
          return new _(e2);
        }
      }, _.sqrt = function(t2) {
        return _.valueOf(t2).sqrt();
      }, _.parse = function(t2) {
        for (var e2 = 0, n2 = t2.length; O.isWhitespace(t2.charAt(e2)); )
          e2++;
        var i3 = false;
        if (n2 > e2) {
          var r2 = t2.charAt(e2);
          "-" !== r2 && "+" !== r2 || (e2++, "-" === r2 && (i3 = true));
        }
        for (var s2 = new _(), o2 = 0, a2 = 0, u2 = 0; ; ) {
          if (e2 >= n2)
            break;
          var l2 = t2.charAt(e2);
          if (e2++, O.isDigit(l2)) {
            var h2 = l2 - "0";
            s2.selfMultiply(_.TEN), s2.selfAdd(h2), o2++;
          } else {
            if ("." !== l2) {
              if ("e" === l2 || "E" === l2) {
                var c2 = t2.substring(e2);
                try {
                  u2 = b.parseInt(c2);
                } catch (e3) {
                  throw e3 instanceof NumberFormatException ? new NumberFormatException("Invalid exponent " + c2 + " in string " + t2) : e3;
                } finally {
                }
                break;
              }
              throw new NumberFormatException("Unexpected character '" + l2 + "' at position " + e2 + " in string " + t2);
            }
            a2 = o2;
          }
        }
        var f2 = s2, g2 = o2 - a2 - u2;
        if (0 === g2)
          f2 = s2;
        else if (g2 > 0) {
          var d2 = _.TEN.pow(g2);
          f2 = s2.divide(d2);
        } else if (0 > g2) {
          var d2 = _.TEN.pow(-g2);
          f2 = s2.multiply(d2);
        }
        return i3 ? f2.negate() : f2;
      }, _.createNaN = function() {
        return new _(r.NaN, r.NaN);
      }, _.copy = function(t2) {
        return new _(t2);
      }, _.magnitude = function(t2) {
        var e2 = Math.abs(t2), n2 = Math.log(e2) / Math.log(10), i3 = Math.trunc(Math.floor(n2)), r2 = Math.pow(10, i3);
        return e2 >= 10 * r2 && (i3 += 1), i3;
      }, _.stringOfChar = function(t2, e2) {
        for (var n2 = new P(), i3 = 0; e2 > i3; i3++)
          n2.append(t2);
        return n2.toString();
      }, _.PI = new _(3.141592653589793, 12246467991473532e-32), _.TWO_PI = new _(6.283185307179586, 24492935982947064e-32), _.PI_2 = new _(1.5707963267948966, 6123233995736766e-32), _.E = new _(2.718281828459045, 14456468917292502e-32), _.NaN = new _(r.NaN, r.NaN), _.EPS = 123259516440783e-46, _.SPLIT = 134217729, _.MAX_PRINT_DIGITS = 32, _.TEN = _.valueOf(10), _.ONE = _.valueOf(1), _.SCI_NOT_EXPONENT_CHAR = "E", _.SCI_NOT_ZERO = "0.0E0", e(M.prototype, { interfaces_: function() {
        return [];
      }, getClass: function() {
        return M;
      } }), M.orientationIndex = function(t2, e2, n2) {
        var i3 = M.orientationIndexFilter(t2, e2, n2);
        if (1 >= i3)
          return i3;
        var r2 = _.valueOf(e2.x).selfAdd(-t2.x), s2 = _.valueOf(e2.y).selfAdd(-t2.y), o2 = _.valueOf(n2.x).selfAdd(-e2.x), a2 = _.valueOf(n2.y).selfAdd(-e2.y);
        return r2.selfMultiply(a2).selfSubtract(s2.selfMultiply(o2)).signum();
      }, M.signOfDet2x2 = function(t2, e2, n2, i3) {
        var r2 = t2.multiply(i3).selfSubtract(e2.multiply(n2));
        return r2.signum();
      }, M.intersection = function(t2, e2, n2, i3) {
        var r2 = _.valueOf(i3.y).selfSubtract(n2.y).selfMultiply(_.valueOf(e2.x).selfSubtract(t2.x)), s2 = _.valueOf(i3.x).selfSubtract(n2.x).selfMultiply(_.valueOf(e2.y).selfSubtract(t2.y)), o2 = r2.subtract(s2), a2 = _.valueOf(i3.x).selfSubtract(n2.x).selfMultiply(_.valueOf(t2.y).selfSubtract(n2.y)), u2 = _.valueOf(i3.y).selfSubtract(n2.y).selfMultiply(_.valueOf(t2.x).selfSubtract(n2.x)), l2 = a2.subtract(u2), h2 = l2.selfDivide(o2).doubleValue(), c2 = _.valueOf(t2.x).selfAdd(_.valueOf(e2.x).selfSubtract(t2.x).selfMultiply(h2)).doubleValue(), f2 = _.valueOf(e2.x).selfSubtract(t2.x).selfMultiply(_.valueOf(t2.y).selfSubtract(n2.y)), d2 = _.valueOf(e2.y).selfSubtract(t2.y).selfMultiply(_.valueOf(t2.x).selfSubtract(n2.x)), p2 = f2.subtract(d2), v2 = p2.selfDivide(o2).doubleValue(), m2 = _.valueOf(n2.y).selfAdd(_.valueOf(i3.y).selfSubtract(n2.y).selfMultiply(v2)).doubleValue();
        return new g(c2, m2);
      }, M.orientationIndexFilter = function(t2, e2, n2) {
        var i3 = null, r2 = (t2.x - n2.x) * (e2.y - n2.y), s2 = (t2.y - n2.y) * (e2.x - n2.x), o2 = r2 - s2;
        if (r2 > 0) {
          if (0 >= s2)
            return M.signum(o2);
          i3 = r2 + s2;
        } else {
          if (!(0 > r2))
            return M.signum(o2);
          if (s2 >= 0)
            return M.signum(o2);
          i3 = -r2 - s2;
        }
        var a2 = M.DP_SAFE_EPSILON * i3;
        return o2 >= a2 || -o2 >= a2 ? M.signum(o2) : 2;
      }, M.signum = function(t2) {
        return t2 > 0 ? 1 : 0 > t2 ? -1 : 0;
      }, M.DP_SAFE_EPSILON = 1e-15, e(D.prototype, { setOrdinate: function(t2, e2, n2) {
      }, size: function() {
      }, getOrdinate: function(t2, e2) {
      }, getCoordinate: function() {
        if (1 === arguments.length) {
          arguments[0];
        } else if (2 === arguments.length) {
          arguments[0], arguments[1];
        }
      }, getCoordinateCopy: function(t2) {
      }, getDimension: function() {
      }, getX: function(t2) {
      }, clone: function() {
      }, expandEnvelope: function(t2) {
      }, copy: function() {
      }, getY: function(t2) {
      }, toCoordinateArray: function() {
      }, interfaces_: function() {
        return [o];
      }, getClass: function() {
        return D;
      } }), D.X = 0, D.Y = 1, D.Z = 2, D.M = 3, A.arraycopy = function(t2, e2, n2, i3, r2) {
        for (var s2 = 0, o2 = e2; e2 + r2 > o2; o2++)
          n2[i3 + s2] = t2[o2], s2++;
      }, A.getProperty = function(t2) {
        return { "line.separator": "\n" }[t2];
      }, e(F.prototype, { getY: function() {
        var t2 = this.y / this.w;
        if (r.isNaN(t2) || r.isInfinite(t2))
          throw new w();
        return t2;
      }, getX: function() {
        var t2 = this.x / this.w;
        if (r.isNaN(t2) || r.isInfinite(t2))
          throw new w();
        return t2;
      }, getCoordinate: function() {
        var t2 = new g();
        return t2.x = this.getX(), t2.y = this.getY(), t2;
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return F;
      } }), F.intersection = function(t2, e2, n2, i3) {
        var s2 = t2.y - e2.y, o2 = e2.x - t2.x, a2 = t2.x * e2.y - e2.x * t2.y, u2 = n2.y - i3.y, l2 = i3.x - n2.x, h2 = n2.x * i3.y - i3.x * n2.y, c2 = o2 * h2 - l2 * a2, f2 = u2 * a2 - s2 * h2, d2 = s2 * l2 - u2 * o2, p2 = c2 / d2, v2 = f2 / d2;
        if (r.isNaN(p2) || r.isInfinite(p2) || r.isNaN(v2) || r.isInfinite(v2))
          throw new w();
        return new g(p2, v2);
      }, e(G.prototype, { create: function() {
        if (1 === arguments.length) {
          if (arguments[0] instanceof Array) {
            arguments[0];
          } else if (R(arguments[0], D)) {
            arguments[0];
          }
        } else if (2 === arguments.length) {
          arguments[0], arguments[1];
        }
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return G;
      } }), e(q.prototype, { filter: function(t2) {
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return q;
      } }), e(B.prototype, { isGeometryCollection: function() {
        return this.getSortIndex() === B.SORTINDEX_GEOMETRYCOLLECTION;
      }, getFactory: function() {
        return this.factory;
      }, getGeometryN: function(t2) {
        return this;
      }, getArea: function() {
        return 0;
      }, isRectangle: function() {
        return false;
      }, equals: function() {
        if (1 === arguments.length) {
          if (arguments[0] instanceof B) {
            var t2 = arguments[0];
            return null === t2 ? false : this.equalsTopo(t2);
          }
          if (arguments[0] instanceof Object) {
            var e2 = arguments[0];
            if (!(e2 instanceof B))
              return false;
            var n2 = e2;
            return this.equalsExact(n2);
          }
        }
      }, equalsExact: function(t2) {
        return this === t2 || this.equalsExact(t2, 0);
      }, geometryChanged: function() {
        this.apply(B.geometryChangedFilter);
      }, geometryChangedAction: function() {
        this.envelope = null;
      }, equalsNorm: function(t2) {
        return null === t2 ? false : this.norm().equalsExact(t2.norm());
      }, getLength: function() {
        return 0;
      }, getNumGeometries: function() {
        return 1;
      }, compareTo: function() {
        if (1 === arguments.length) {
          var t2 = arguments[0], e2 = t2;
          return this.getSortIndex() !== e2.getSortIndex() ? this.getSortIndex() - e2.getSortIndex() : this.isEmpty() && e2.isEmpty() ? 0 : this.isEmpty() ? -1 : e2.isEmpty() ? 1 : this.compareToSameClass(t2);
        }
        if (2 === arguments.length) {
          var n2 = arguments[0], i3 = arguments[1], e2 = n2;
          return this.getSortIndex() !== e2.getSortIndex() ? this.getSortIndex() - e2.getSortIndex() : this.isEmpty() && e2.isEmpty() ? 0 : this.isEmpty() ? -1 : e2.isEmpty() ? 1 : this.compareToSameClass(n2, i3);
        }
      }, getUserData: function() {
        return this.userData;
      }, getSRID: function() {
        return this.SRID;
      }, getEnvelope: function() {
        return this.getFactory().toGeometry(this.getEnvelopeInternal());
      }, checkNotGeometryCollection: function(t2) {
        if (t2.getSortIndex() === B.SORTINDEX_GEOMETRYCOLLECTION)
          throw new i2("This method does not support GeometryCollection arguments");
      }, equal: function(t2, e2, n2) {
        return 0 === n2 ? t2.equals(e2) : t2.distance(e2) <= n2;
      }, norm: function() {
        var t2 = this.copy();
        return t2.normalize(), t2;
      }, getPrecisionModel: function() {
        return this.factory.getPrecisionModel();
      }, getEnvelopeInternal: function() {
        return null === this.envelope && (this.envelope = this.computeEnvelopeInternal()), new C(this.envelope);
      }, setSRID: function(t2) {
        this.SRID = t2;
      }, setUserData: function(t2) {
        this.userData = t2;
      }, compare: function(t2, e2) {
        for (var n2 = t2.iterator(), i3 = e2.iterator(); n2.hasNext() && i3.hasNext(); ) {
          var r2 = n2.next(), s2 = i3.next(), o2 = r2.compareTo(s2);
          if (0 !== o2)
            return o2;
        }
        return n2.hasNext() ? 1 : i3.hasNext() ? -1 : 0;
      }, hashCode: function() {
        return this.getEnvelopeInternal().hashCode();
      }, isGeometryCollectionOrDerived: function() {
        return this.getSortIndex() === B.SORTINDEX_GEOMETRYCOLLECTION || this.getSortIndex() === B.SORTINDEX_MULTIPOINT || this.getSortIndex() === B.SORTINDEX_MULTILINESTRING || this.getSortIndex() === B.SORTINDEX_MULTIPOLYGON;
      }, interfaces_: function() {
        return [o, s, u];
      }, getClass: function() {
        return B;
      } }), B.hasNonEmptyElements = function(t2) {
        for (var e2 = 0; e2 < t2.length; e2++)
          if (!t2[e2].isEmpty())
            return true;
        return false;
      }, B.hasNullElements = function(t2) {
        for (var e2 = 0; e2 < t2.length; e2++)
          if (null === t2[e2])
            return true;
        return false;
      }, B.serialVersionUID = 8763622679187377e3, B.SORTINDEX_POINT = 0, B.SORTINDEX_MULTIPOINT = 1, B.SORTINDEX_LINESTRING = 2, B.SORTINDEX_LINEARRING = 3, B.SORTINDEX_MULTILINESTRING = 4, B.SORTINDEX_POLYGON = 5, B.SORTINDEX_MULTIPOLYGON = 6, B.SORTINDEX_GEOMETRYCOLLECTION = 7, B.geometryChangedFilter = { interfaces_: function() {
        return [q];
      }, filter: function(t2) {
        t2.geometryChangedAction();
      } }, e(z.prototype, { filter: function(t2) {
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return z;
      } }), e(V.prototype, { isInBoundary: function(t2) {
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return V;
      } }), e(k.prototype, { isInBoundary: function(t2) {
        return t2 % 2 === 1;
      }, interfaces_: function() {
        return [V];
      }, getClass: function() {
        return k;
      } }), e(Y.prototype, { isInBoundary: function(t2) {
        return t2 > 0;
      }, interfaces_: function() {
        return [V];
      }, getClass: function() {
        return Y;
      } }), e(U.prototype, { isInBoundary: function(t2) {
        return t2 > 1;
      }, interfaces_: function() {
        return [V];
      }, getClass: function() {
        return U;
      } }), e(X.prototype, { isInBoundary: function(t2) {
        return 1 === t2;
      }, interfaces_: function() {
        return [V];
      }, getClass: function() {
        return X;
      } }), V.Mod2BoundaryNodeRule = k, V.EndPointBoundaryNodeRule = Y, V.MultiValentEndPointBoundaryNodeRule = U, V.MonoValentEndPointBoundaryNodeRule = X, V.MOD2_BOUNDARY_RULE = new k(), V.ENDPOINT_BOUNDARY_RULE = new Y(), V.MULTIVALENT_ENDPOINT_BOUNDARY_RULE = new U(), V.MONOVALENT_ENDPOINT_BOUNDARY_RULE = new X(), V.OGC_SFS_BOUNDARY_RULE = V.MOD2_BOUNDARY_RULE, e(H.prototype, { interfaces_: function() {
        return [];
      }, getClass: function() {
        return H;
      } }), H.isRing = function(t2) {
        return t2.length < 4 ? false : !!t2[0].equals2D(t2[t2.length - 1]);
      }, H.ptNotInList = function(t2, e2) {
        for (var n2 = 0; n2 < t2.length; n2++) {
          var i3 = t2[n2];
          if (H.indexOf(i3, e2) < 0)
            return i3;
        }
        return null;
      }, H.scroll = function(t2, e2) {
        var n2 = H.indexOf(e2, t2);
        if (0 > n2)
          return null;
        var i3 = new Array(t2.length).fill(null);
        A.arraycopy(t2, n2, i3, 0, t2.length - n2), A.arraycopy(t2, 0, i3, t2.length - n2, n2), A.arraycopy(i3, 0, t2, 0, t2.length);
      }, H.equals = function() {
        if (2 === arguments.length) {
          var t2 = arguments[0], e2 = arguments[1];
          if (t2 === e2)
            return true;
          if (null === t2 || null === e2)
            return false;
          if (t2.length !== e2.length)
            return false;
          for (var n2 = 0; n2 < t2.length; n2++)
            if (!t2[n2].equals(e2[n2]))
              return false;
          return true;
        }
        if (3 === arguments.length) {
          var i3 = arguments[0], r2 = arguments[1], s2 = arguments[2];
          if (i3 === r2)
            return true;
          if (null === i3 || null === r2)
            return false;
          if (i3.length !== r2.length)
            return false;
          for (var n2 = 0; n2 < i3.length; n2++)
            if (0 !== s2.compare(i3[n2], r2[n2]))
              return false;
          return true;
        }
      }, H.intersection = function(t2, e2) {
        for (var n2 = new N(), i3 = 0; i3 < t2.length; i3++)
          e2.intersects(t2[i3]) && n2.add(t2[i3], true);
        return n2.toCoordinateArray();
      }, H.hasRepeatedPoints = function(t2) {
        for (var e2 = 1; e2 < t2.length; e2++)
          if (t2[e2 - 1].equals(t2[e2]))
            return true;
        return false;
      }, H.removeRepeatedPoints = function(t2) {
        if (!H.hasRepeatedPoints(t2))
          return t2;
        var e2 = new N(t2, false);
        return e2.toCoordinateArray();
      }, H.reverse = function(t2) {
        for (var e2 = t2.length - 1, n2 = Math.trunc(e2 / 2), i3 = 0; n2 >= i3; i3++) {
          var r2 = t2[i3];
          t2[i3] = t2[e2 - i3], t2[e2 - i3] = r2;
        }
      }, H.removeNull = function(t2) {
        for (var e2 = 0, n2 = 0; n2 < t2.length; n2++)
          null !== t2[n2] && e2++;
        var i3 = new Array(e2).fill(null);
        if (0 === e2)
          return i3;
        for (var r2 = 0, n2 = 0; n2 < t2.length; n2++)
          null !== t2[n2] && (i3[r2++] = t2[n2]);
        return i3;
      }, H.copyDeep = function() {
        if (1 === arguments.length) {
          for (var t2 = arguments[0], e2 = new Array(t2.length).fill(null), n2 = 0; n2 < t2.length; n2++)
            e2[n2] = new g(t2[n2]);
          return e2;
        }
        if (5 === arguments.length)
          for (var i3 = arguments[0], r2 = arguments[1], s2 = arguments[2], o2 = arguments[3], a2 = arguments[4], n2 = 0; a2 > n2; n2++)
            s2[o2 + n2] = new g(i3[r2 + n2]);
      }, H.isEqualReversed = function(t2, e2) {
        for (var n2 = 0; n2 < t2.length; n2++) {
          var i3 = t2[n2], r2 = e2[t2.length - n2 - 1];
          if (0 !== i3.compareTo(r2))
            return false;
        }
        return true;
      }, H.envelope = function(t2) {
        for (var e2 = new C(), n2 = 0; n2 < t2.length; n2++)
          e2.expandToInclude(t2[n2]);
        return e2;
      }, H.toCoordinateArray = function(t2) {
        return t2.toArray(H.coordArrayType);
      }, H.atLeastNCoordinatesOrNothing = function(t2, e2) {
        return e2.length >= t2 ? e2 : [];
      }, H.indexOf = function(t2, e2) {
        for (var n2 = 0; n2 < e2.length; n2++)
          if (t2.equals(e2[n2]))
            return n2;
        return -1;
      }, H.increasingDirection = function(t2) {
        for (var e2 = 0; e2 < Math.trunc(t2.length / 2); e2++) {
          var n2 = t2.length - 1 - e2, i3 = t2[e2].compareTo(t2[n2]);
          if (0 !== i3)
            return i3;
        }
        return 1;
      }, H.compare = function(t2, e2) {
        for (var n2 = 0; n2 < t2.length && n2 < e2.length; ) {
          var i3 = t2[n2].compareTo(e2[n2]);
          if (0 !== i3)
            return i3;
          n2++;
        }
        return n2 < e2.length ? -1 : n2 < t2.length ? 1 : 0;
      }, H.minCoordinate = function(t2) {
        for (var e2 = null, n2 = 0; n2 < t2.length; n2++)
          (null === e2 || e2.compareTo(t2[n2]) > 0) && (e2 = t2[n2]);
        return e2;
      }, H.extract = function(t2, e2, n2) {
        e2 = T.clamp(e2, 0, t2.length), n2 = T.clamp(n2, -1, t2.length);
        var i3 = n2 - e2 + 1;
        0 > n2 && (i3 = 0), e2 >= t2.length && (i3 = 0), e2 > n2 && (i3 = 0);
        var r2 = new Array(i3).fill(null);
        if (0 === i3)
          return r2;
        for (var s2 = 0, o2 = e2; n2 >= o2; o2++)
          r2[s2++] = t2[o2];
        return r2;
      }, e(W.prototype, { compare: function(t2, e2) {
        var n2 = t2, i3 = e2;
        return H.compare(n2, i3);
      }, interfaces_: function() {
        return [a];
      }, getClass: function() {
        return W;
      } }), e(j.prototype, { compare: function(t2, e2) {
        var n2 = t2, i3 = e2;
        if (n2.length < i3.length)
          return -1;
        if (n2.length > i3.length)
          return 1;
        if (0 === n2.length)
          return 0;
        var r2 = H.compare(n2, i3), s2 = H.isEqualReversed(n2, i3);
        return s2 ? 0 : r2;
      }, OLDcompare: function(t2, e2) {
        var n2 = t2, i3 = e2;
        if (n2.length < i3.length)
          return -1;
        if (n2.length > i3.length)
          return 1;
        if (0 === n2.length)
          return 0;
        for (var r2 = H.increasingDirection(n2), s2 = H.increasingDirection(i3), o2 = r2 > 0 ? 0 : n2.length - 1, a2 = s2 > 0 ? 0 : n2.length - 1, u2 = 0; u2 < n2.length; u2++) {
          var l2 = n2[o2].compareTo(i3[a2]);
          if (0 !== l2)
            return l2;
          o2 += r2, a2 += s2;
        }
        return 0;
      }, interfaces_: function() {
        return [a];
      }, getClass: function() {
        return j;
      } }), H.ForwardComparator = W, H.BidirectionalComparator = j, H.coordArrayType = new Array(0).fill(null), K.prototype.get = function() {
      }, K.prototype.put = function() {
      }, K.prototype.size = function() {
      }, K.prototype.values = function() {
      }, K.prototype.entrySet = function() {
      }, Z.prototype = new K(), Q.prototype = new v(), Q.prototype.contains = function() {
      }, J.prototype = new Q(), J.prototype.contains = function(t2) {
        for (var e2 = 0, n2 = this.array_.length; n2 > e2; e2++) {
          var i3 = this.array_[e2];
          if (i3 === t2)
            return true;
        }
        return false;
      }, J.prototype.add = function(t2) {
        return this.contains(t2) ? false : (this.array_.push(t2), true);
      }, J.prototype.addAll = function(t2) {
        for (var e2 = t2.iterator(); e2.hasNext(); )
          this.add(e2.next());
        return true;
      }, J.prototype.remove = function(t2) {
        throw new javascript.util.OperationNotSupported();
      }, J.prototype.size = function() {
        return this.array_.length;
      }, J.prototype.isEmpty = function() {
        return 0 === this.array_.length;
      }, J.prototype.toArray = function() {
        for (var t2 = [], e2 = 0, n2 = this.array_.length; n2 > e2; e2++)
          t2.push(this.array_[e2]);
        return t2;
      }, J.prototype.iterator = function() {
        return new Js(this);
      };
      var Js = function(t2) {
        this.hashSet_ = t2, this.position_ = 0;
      };
      Js.prototype.next = function() {
        if (this.position_ === this.hashSet_.size())
          throw new x();
        return this.hashSet_.array_[this.position_++];
      }, Js.prototype.hasNext = function() {
        return this.position_ < this.hashSet_.size();
      }, Js.prototype.remove = function() {
        throw new E();
      };
      var $s = 0, to = 1;
      rt.prototype = new Z(), rt.prototype.get = function(t2) {
        for (var e2 = this.root_; null !== e2; ) {
          var n2 = t2.compareTo(e2.key);
          if (0 > n2)
            e2 = e2.left;
          else {
            if (!(n2 > 0))
              return e2.value;
            e2 = e2.right;
          }
        }
        return null;
      }, rt.prototype.put = function(t2, e2) {
        if (null === this.root_)
          return this.root_ = { key: t2, value: e2, left: null, right: null, parent: null, color: $s, getValue: function() {
            return this.value;
          }, getKey: function() {
            return this.key;
          } }, this.size_ = 1, null;
        var n2, i3, r2 = this.root_;
        do
          if (n2 = r2, i3 = t2.compareTo(r2.key), 0 > i3)
            r2 = r2.left;
          else {
            if (!(i3 > 0)) {
              var s2 = r2.value;
              return r2.value = e2, s2;
            }
            r2 = r2.right;
          }
        while (null !== r2);
        var o2 = { key: t2, left: null, right: null, value: e2, parent: n2, color: $s, getValue: function() {
          return this.value;
        }, getKey: function() {
          return this.key;
        } };
        return 0 > i3 ? n2.left = o2 : n2.right = o2, this.fixAfterInsertion(o2), this.size_++, null;
      }, rt.prototype.fixAfterInsertion = function(t2) {
        for (t2.color = to; null != t2 && t2 != this.root_ && t2.parent.color == to; )
          if (tt(t2) == nt(tt(tt(t2)))) {
            var e2 = it(tt(tt(t2)));
            $(e2) == to ? (et(tt(t2), $s), et(e2, $s), et(tt(tt(t2)), to), t2 = tt(tt(t2))) : (t2 == it(tt(t2)) && (t2 = tt(t2), this.rotateLeft(t2)), et(tt(t2), $s), et(tt(tt(t2)), to), this.rotateRight(tt(tt(t2))));
          } else {
            var e2 = nt(tt(tt(t2)));
            $(e2) == to ? (et(tt(t2), $s), et(e2, $s), et(tt(tt(t2)), to), t2 = tt(tt(t2))) : (t2 == nt(tt(t2)) && (t2 = tt(t2), this.rotateRight(t2)), et(tt(t2), $s), et(tt(tt(t2)), to), this.rotateLeft(tt(tt(t2))));
          }
        this.root_.color = $s;
      }, rt.prototype.values = function() {
        var t2 = new I(), e2 = this.getFirstEntry();
        if (null !== e2)
          for (t2.add(e2.value); null !== (e2 = rt.successor(e2)); )
            t2.add(e2.value);
        return t2;
      }, rt.prototype.entrySet = function() {
        var t2 = new J(), e2 = this.getFirstEntry();
        if (null !== e2)
          for (t2.add(e2); null !== (e2 = rt.successor(e2)); )
            t2.add(e2);
        return t2;
      }, rt.prototype.rotateLeft = function(t2) {
        if (null != t2) {
          var e2 = t2.right;
          t2.right = e2.left, null != e2.left && (e2.left.parent = t2), e2.parent = t2.parent, null == t2.parent ? this.root_ = e2 : t2.parent.left == t2 ? t2.parent.left = e2 : t2.parent.right = e2, e2.left = t2, t2.parent = e2;
        }
      }, rt.prototype.rotateRight = function(t2) {
        if (null != t2) {
          var e2 = t2.left;
          t2.left = e2.right, null != e2.right && (e2.right.parent = t2), e2.parent = t2.parent, null == t2.parent ? this.root_ = e2 : t2.parent.right == t2 ? t2.parent.right = e2 : t2.parent.left = e2, e2.right = t2, t2.parent = e2;
        }
      }, rt.prototype.getFirstEntry = function() {
        var t2 = this.root_;
        if (null != t2)
          for (; null != t2.left; )
            t2 = t2.left;
        return t2;
      }, rt.successor = function(t2) {
        if (null === t2)
          return null;
        if (null !== t2.right) {
          for (var e2 = t2.right; null !== e2.left; )
            e2 = e2.left;
          return e2;
        }
        for (var e2 = t2.parent, n2 = t2; null !== e2 && n2 === e2.right; )
          n2 = e2, e2 = e2.parent;
        return e2;
      }, rt.prototype.size = function() {
        return this.size_;
      }, e(st.prototype, { interfaces_: function() {
        return [];
      }, getClass: function() {
        return st;
      } }), ot.prototype = new Q(), at.prototype = new ot(), at.prototype.contains = function(t2) {
        for (var e2 = 0, n2 = this.array_.length; n2 > e2; e2++) {
          var i3 = this.array_[e2];
          if (0 === i3.compareTo(t2))
            return true;
        }
        return false;
      }, at.prototype.add = function(t2) {
        if (this.contains(t2))
          return false;
        for (var e2 = 0, n2 = this.array_.length; n2 > e2; e2++) {
          var i3 = this.array_[e2];
          if (1 === i3.compareTo(t2))
            return this.array_.splice(e2, 0, t2), true;
        }
        return this.array_.push(t2), true;
      }, at.prototype.addAll = function(t2) {
        for (var e2 = t2.iterator(); e2.hasNext(); )
          this.add(e2.next());
        return true;
      }, at.prototype.remove = function(t2) {
        throw new E();
      }, at.prototype.size = function() {
        return this.array_.length;
      }, at.prototype.isEmpty = function() {
        return 0 === this.array_.length;
      }, at.prototype.toArray = function() {
        for (var t2 = [], e2 = 0, n2 = this.array_.length; n2 > e2; e2++)
          t2.push(this.array_[e2]);
        return t2;
      }, at.prototype.iterator = function() {
        return new eo(this);
      };
      var eo = function(t2) {
        this.treeSet_ = t2, this.position_ = 0;
      };
      eo.prototype.next = function() {
        if (this.position_ === this.treeSet_.size())
          throw new x();
        return this.treeSet_.array_[this.position_++];
      }, eo.prototype.hasNext = function() {
        return this.position_ < this.treeSet_.size();
      }, eo.prototype.remove = function() {
        throw new E();
      }, ut.sort = function() {
        var t2, e2, n2, i3, r2 = arguments[0];
        if (1 === arguments.length)
          return i3 = function(t3, e3) {
            return t3.compareTo(e3);
          }, void r2.sort(i3);
        if (2 === arguments.length)
          n2 = arguments[1], i3 = function(t3, e3) {
            return n2.compare(t3, e3);
          }, r2.sort(i3);
        else {
          if (3 === arguments.length) {
            e2 = r2.slice(arguments[1], arguments[2]), e2.sort();
            var s2 = r2.slice(0, arguments[1]).concat(e2, r2.slice(arguments[2], r2.length));
            for (r2.splice(0, r2.length), t2 = 0; t2 < s2.length; t2++)
              r2.push(s2[t2]);
            return;
          }
          if (4 === arguments.length) {
            for (e2 = r2.slice(arguments[1], arguments[2]), n2 = arguments[3], i3 = function(t3, e3) {
              return n2.compare(t3, e3);
            }, e2.sort(i3), s2 = r2.slice(0, arguments[1]).concat(e2, r2.slice(arguments[2], r2.length)), r2.splice(0, r2.length), t2 = 0; t2 < s2.length; t2++)
              r2.push(s2[t2]);
            return;
          }
        }
      }, ut.asList = function(t2) {
        for (var e2 = new I(), n2 = 0, i3 = t2.length; i3 > n2; n2++)
          e2.add(t2[n2]);
        return e2;
      }, e(lt.prototype, { interfaces_: function() {
        return [];
      }, getClass: function() {
        return lt;
      } }), lt.toDimensionSymbol = function(t2) {
        switch (t2) {
          case lt.FALSE:
            return lt.SYM_FALSE;
          case lt.TRUE:
            return lt.SYM_TRUE;
          case lt.DONTCARE:
            return lt.SYM_DONTCARE;
          case lt.P:
            return lt.SYM_P;
          case lt.L:
            return lt.SYM_L;
          case lt.A:
            return lt.SYM_A;
        }
        throw new i2("Unknown dimension value: " + t2);
      }, lt.toDimensionValue = function(t2) {
        switch (O.toUpperCase(t2)) {
          case lt.SYM_FALSE:
            return lt.FALSE;
          case lt.SYM_TRUE:
            return lt.TRUE;
          case lt.SYM_DONTCARE:
            return lt.DONTCARE;
          case lt.SYM_P:
            return lt.P;
          case lt.SYM_L:
            return lt.L;
          case lt.SYM_A:
            return lt.A;
        }
        throw new i2("Unknown dimension symbol: " + t2);
      }, lt.P = 0, lt.L = 1, lt.A = 2, lt.FALSE = -1, lt.TRUE = -2, lt.DONTCARE = -3, lt.SYM_FALSE = "F", lt.SYM_TRUE = "T", lt.SYM_DONTCARE = "*", lt.SYM_P = "0", lt.SYM_L = "1", lt.SYM_A = "2", e(ht.prototype, { filter: function(t2) {
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return ht;
      } }), e(ct.prototype, { filter: function(t2, e2) {
      }, isDone: function() {
      }, isGeometryChanged: function() {
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return ct;
      } }), h(ft, B), e(ft.prototype, { computeEnvelopeInternal: function() {
        for (var t2 = new C(), e2 = 0; e2 < this.geometries.length; e2++)
          t2.expandToInclude(this.geometries[e2].getEnvelopeInternal());
        return t2;
      }, getGeometryN: function(t2) {
        return this.geometries[t2];
      }, getSortIndex: function() {
        return B.SORTINDEX_GEOMETRYCOLLECTION;
      }, getCoordinates: function() {
        for (var t2 = new Array(this.getNumPoints()).fill(null), e2 = -1, n2 = 0; n2 < this.geometries.length; n2++)
          for (var i3 = this.geometries[n2].getCoordinates(), r2 = 0; r2 < i3.length; r2++)
            e2++, t2[e2] = i3[r2];
        return t2;
      }, getArea: function() {
        for (var t2 = 0, e2 = 0; e2 < this.geometries.length; e2++)
          t2 += this.geometries[e2].getArea();
        return t2;
      }, equalsExact: function() {
        if (2 === arguments.length) {
          var t2 = arguments[0], e2 = arguments[1];
          if (!this.isEquivalentClass(t2))
            return false;
          var n2 = t2;
          if (this.geometries.length !== n2.geometries.length)
            return false;
          for (var i3 = 0; i3 < this.geometries.length; i3++)
            if (!this.geometries[i3].equalsExact(n2.geometries[i3], e2))
              return false;
          return true;
        }
        return B.prototype.equalsExact.apply(this, arguments);
      }, normalize: function() {
        for (var t2 = 0; t2 < this.geometries.length; t2++)
          this.geometries[t2].normalize();
        ut.sort(this.geometries);
      }, getCoordinate: function() {
        return this.isEmpty() ? null : this.geometries[0].getCoordinate();
      }, getBoundaryDimension: function() {
        for (var t2 = lt.FALSE, e2 = 0; e2 < this.geometries.length; e2++)
          t2 = Math.max(t2, this.geometries[e2].getBoundaryDimension());
        return t2;
      }, getDimension: function() {
        for (var t2 = lt.FALSE, e2 = 0; e2 < this.geometries.length; e2++)
          t2 = Math.max(t2, this.geometries[e2].getDimension());
        return t2;
      }, getLength: function() {
        for (var t2 = 0, e2 = 0; e2 < this.geometries.length; e2++)
          t2 += this.geometries[e2].getLength();
        return t2;
      }, getNumPoints: function() {
        for (var t2 = 0, e2 = 0; e2 < this.geometries.length; e2++)
          t2 += this.geometries[e2].getNumPoints();
        return t2;
      }, getNumGeometries: function() {
        return this.geometries.length;
      }, reverse: function() {
        for (var t2 = this.geometries.length, e2 = new Array(t2).fill(null), n2 = 0; n2 < this.geometries.length; n2++)
          e2[n2] = this.geometries[n2].reverse();
        return this.getFactory().createGeometryCollection(e2);
      }, compareToSameClass: function() {
        if (1 === arguments.length) {
          var t2 = arguments[0], e2 = new at(ut.asList(this.geometries)), n2 = new at(ut.asList(t2.geometries));
          return this.compare(e2, n2);
        }
        if (2 === arguments.length) {
          for (var i3 = arguments[0], r2 = arguments[1], s2 = i3, o2 = this.getNumGeometries(), a2 = s2.getNumGeometries(), u2 = 0; o2 > u2 && a2 > u2; ) {
            var l2 = this.getGeometryN(u2), h2 = s2.getGeometryN(u2), c2 = l2.compareToSameClass(h2, r2);
            if (0 !== c2)
              return c2;
            u2++;
          }
          return o2 > u2 ? 1 : a2 > u2 ? -1 : 0;
        }
      }, apply: function() {
        if (R(arguments[0], z))
          for (var t2 = arguments[0], e2 = 0; e2 < this.geometries.length; e2++)
            this.geometries[e2].apply(t2);
        else if (R(arguments[0], ct)) {
          var n2 = arguments[0];
          if (0 === this.geometries.length)
            return null;
          for (var e2 = 0; e2 < this.geometries.length && (this.geometries[e2].apply(n2), !n2.isDone()); e2++)
            ;
          n2.isGeometryChanged() && this.geometryChanged();
        } else if (R(arguments[0], ht)) {
          var i3 = arguments[0];
          i3.filter(this);
          for (var e2 = 0; e2 < this.geometries.length; e2++)
            this.geometries[e2].apply(i3);
        } else if (R(arguments[0], q)) {
          var r2 = arguments[0];
          r2.filter(this);
          for (var e2 = 0; e2 < this.geometries.length; e2++)
            this.geometries[e2].apply(r2);
        }
      }, getBoundary: function() {
        return this.checkNotGeometryCollection(this), f.shouldNeverReachHere(), null;
      }, clone: function() {
        var t2 = B.prototype.clone.call(this);
        t2.geometries = new Array(this.geometries.length).fill(null);
        for (var e2 = 0; e2 < this.geometries.length; e2++)
          t2.geometries[e2] = this.geometries[e2].clone();
        return t2;
      }, getGeometryType: function() {
        return "GeometryCollection";
      }, copy: function() {
        for (var t2 = new Array(this.geometries.length).fill(null), e2 = 0; e2 < t2.length; e2++)
          t2[e2] = this.geometries[e2].copy();
        return new ft(t2, this.factory);
      }, isEmpty: function() {
        for (var t2 = 0; t2 < this.geometries.length; t2++)
          if (!this.geometries[t2].isEmpty())
            return false;
        return true;
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return ft;
      } }), ft.serialVersionUID = -5694727726395021e3, h(gt, ft), e(gt.prototype, { getSortIndex: function() {
        return B.SORTINDEX_MULTILINESTRING;
      }, equalsExact: function() {
        if (2 === arguments.length) {
          var t2 = arguments[0], e2 = arguments[1];
          return this.isEquivalentClass(t2) ? ft.prototype.equalsExact.call(this, t2, e2) : false;
        }
        return ft.prototype.equalsExact.apply(this, arguments);
      }, getBoundaryDimension: function() {
        return this.isClosed() ? lt.FALSE : 0;
      }, isClosed: function() {
        if (this.isEmpty())
          return false;
        for (var t2 = 0; t2 < this.geometries.length; t2++)
          if (!this.geometries[t2].isClosed())
            return false;
        return true;
      }, getDimension: function() {
        return 1;
      }, reverse: function() {
        for (var t2 = this.geometries.length, e2 = new Array(t2).fill(null), n2 = 0; n2 < this.geometries.length; n2++)
          e2[t2 - 1 - n2] = this.geometries[n2].reverse();
        return this.getFactory().createMultiLineString(e2);
      }, getBoundary: function() {
        return new dt(this).getBoundary();
      }, getGeometryType: function() {
        return "MultiLineString";
      }, copy: function() {
        for (var t2 = new Array(this.geometries.length).fill(null), e2 = 0; e2 < t2.length; e2++)
          t2[e2] = this.geometries[e2].copy();
        return new gt(t2, this.factory);
      }, interfaces_: function() {
        return [st];
      }, getClass: function() {
        return gt;
      } }), gt.serialVersionUID = 8166665132445434e3, e(dt.prototype, { boundaryMultiLineString: function(t2) {
        if (this.geom.isEmpty())
          return this.getEmptyMultiPoint();
        var e2 = this.computeBoundaryCoordinates(t2);
        return 1 === e2.length ? this.geomFact.createPoint(e2[0]) : this.geomFact.createMultiPointFromCoords(e2);
      }, getBoundary: function() {
        return this.geom instanceof St ? this.boundaryLineString(this.geom) : this.geom instanceof gt ? this.boundaryMultiLineString(this.geom) : this.geom.getBoundary();
      }, boundaryLineString: function(t2) {
        if (this.geom.isEmpty())
          return this.getEmptyMultiPoint();
        if (t2.isClosed()) {
          var e2 = this.bnRule.isInBoundary(2);
          return e2 ? t2.getStartPoint() : this.geomFact.createMultiPoint();
        }
        return this.geomFact.createMultiPoint([t2.getStartPoint(), t2.getEndPoint()]);
      }, getEmptyMultiPoint: function() {
        return this.geomFact.createMultiPoint();
      }, computeBoundaryCoordinates: function(t2) {
        var e2 = new I();
        this.endpointMap = new rt();
        for (var n2 = 0; n2 < t2.getNumGeometries(); n2++) {
          var i3 = t2.getGeometryN(n2);
          0 !== i3.getNumPoints() && (this.addEndpoint(i3.getCoordinateN(0)), this.addEndpoint(i3.getCoordinateN(i3.getNumPoints() - 1)));
        }
        for (var r2 = this.endpointMap.entrySet().iterator(); r2.hasNext(); ) {
          var s2 = r2.next(), o2 = s2.getValue(), a2 = o2.count;
          this.bnRule.isInBoundary(a2) && e2.add(s2.getKey());
        }
        return H.toCoordinateArray(e2);
      }, addEndpoint: function(t2) {
        var e2 = this.endpointMap.get(t2);
        null === e2 && (e2 = new pt(), this.endpointMap.put(t2, e2)), e2.count++;
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return dt;
      } }), dt.getBoundary = function() {
        if (1 === arguments.length) {
          var t2 = arguments[0], e2 = new dt(t2);
          return e2.getBoundary();
        }
        if (2 === arguments.length) {
          var n2 = arguments[0], i3 = arguments[1], e2 = new dt(n2, i3);
          return e2.getBoundary();
        }
      }, e(pt.prototype, { interfaces_: function() {
        return [];
      }, getClass: function() {
        return pt;
      } }), e(Nt.prototype, { interfaces_: function() {
        return [];
      }, getClass: function() {
        return Nt;
      } }), Nt.chars = function(t2, e2) {
        for (var n2 = new Array(e2).fill(null), i3 = 0; e2 > i3; i3++)
          n2[i3] = t2;
        return new String(n2);
      }, Nt.getStackTrace = function() {
        if (1 === arguments.length) {
          var t2 = arguments[0], e2 = new xt(), n2 = new vt(e2);
          return t2.printStackTrace(n2), e2.toString();
        }
        if (2 === arguments.length) {
          for (var i3 = arguments[0], r2 = arguments[1], s2 = "", o2 = new mt(Nt.getStackTrace(i3)), a2 = new It(o2), u2 = 0; r2 > u2; u2++)
            try {
              s2 += a2.readLine() + Nt.NEWLINE;
            } catch (t3) {
              if (!(t3 instanceof Et))
                throw t3;
              f.shouldNeverReachHere();
            } finally {
            }
          return s2;
        }
      }, Nt.split = function(t2, e2) {
        for (var n2 = e2.length, i3 = new I(), r2 = "" + t2, s2 = r2.indexOf(e2); s2 >= 0; ) {
          var o2 = r2.substring(0, s2);
          i3.add(o2), r2 = r2.substring(s2 + n2), s2 = r2.indexOf(e2);
        }
        r2.length > 0 && i3.add(r2);
        for (var a2 = new Array(i3.size()).fill(null), u2 = 0; u2 < a2.length; u2++)
          a2[u2] = i3.get(u2);
        return a2;
      }, Nt.toString = function() {
        if (1 === arguments.length) {
          var t2 = arguments[0];
          return Nt.SIMPLE_ORDINATE_FORMAT.format(t2);
        }
      }, Nt.spaces = function(t2) {
        return Nt.chars(" ", t2);
      }, Nt.NEWLINE = A.getProperty("line.separator"), Nt.SIMPLE_ORDINATE_FORMAT = new yt("0.#"), e(Ct.prototype, { interfaces_: function() {
        return [];
      }, getClass: function() {
        return Ct;
      } }), Ct.copyCoord = function(t2, e2, n2, i3) {
        for (var r2 = Math.min(t2.getDimension(), n2.getDimension()), s2 = 0; r2 > s2; s2++)
          n2.setOrdinate(i3, s2, t2.getOrdinate(e2, s2));
      }, Ct.isRing = function(t2) {
        var e2 = t2.size();
        return 0 === e2 ? true : 3 >= e2 ? false : t2.getOrdinate(0, D.X) === t2.getOrdinate(e2 - 1, D.X) && t2.getOrdinate(0, D.Y) === t2.getOrdinate(e2 - 1, D.Y);
      }, Ct.isEqual = function(t2, e2) {
        var n2 = t2.size(), i3 = e2.size();
        if (n2 !== i3)
          return false;
        for (var s2 = Math.min(t2.getDimension(), e2.getDimension()), o2 = 0; n2 > o2; o2++)
          for (var a2 = 0; s2 > a2; a2++) {
            var u2 = t2.getOrdinate(o2, a2), l2 = e2.getOrdinate(o2, a2);
            if (!(t2.getOrdinate(o2, a2) === e2.getOrdinate(o2, a2) || r.isNaN(u2) && r.isNaN(l2)))
              return false;
          }
        return true;
      }, Ct.extend = function(t2, e2, n2) {
        var i3 = t2.create(n2, e2.getDimension()), r2 = e2.size();
        if (Ct.copy(e2, 0, i3, 0, r2), r2 > 0)
          for (var s2 = r2; n2 > s2; s2++)
            Ct.copy(e2, r2 - 1, i3, s2, 1);
        return i3;
      }, Ct.reverse = function(t2) {
        for (var e2 = t2.size() - 1, n2 = Math.trunc(e2 / 2), i3 = 0; n2 >= i3; i3++)
          Ct.swap(t2, i3, e2 - i3);
      }, Ct.swap = function(t2, e2, n2) {
        if (e2 === n2)
          return null;
        for (var i3 = 0; i3 < t2.getDimension(); i3++) {
          var r2 = t2.getOrdinate(e2, i3);
          t2.setOrdinate(e2, i3, t2.getOrdinate(n2, i3)), t2.setOrdinate(n2, i3, r2);
        }
      }, Ct.copy = function(t2, e2, n2, i3, r2) {
        for (var s2 = 0; r2 > s2; s2++)
          Ct.copyCoord(t2, e2 + s2, n2, i3 + s2);
      }, Ct.toString = function() {
        if (1 === arguments.length) {
          var t2 = arguments[0], e2 = t2.size();
          if (0 === e2)
            return "()";
          var n2 = t2.getDimension(), i3 = new P();
          i3.append("(");
          for (var r2 = 0; e2 > r2; r2++) {
            r2 > 0 && i3.append(" ");
            for (var s2 = 0; n2 > s2; s2++)
              s2 > 0 && i3.append(","), i3.append(Nt.toString(t2.getOrdinate(r2, s2)));
          }
          return i3.append(")"), i3.toString();
        }
      }, Ct.ensureValidRing = function(t2, e2) {
        var n2 = e2.size();
        if (0 === n2)
          return e2;
        if (3 >= n2)
          return Ct.createClosedRing(t2, e2, 4);
        var i3 = e2.getOrdinate(0, D.X) === e2.getOrdinate(n2 - 1, D.X) && e2.getOrdinate(0, D.Y) === e2.getOrdinate(n2 - 1, D.Y);
        return i3 ? e2 : Ct.createClosedRing(t2, e2, n2 + 1);
      }, Ct.createClosedRing = function(t2, e2, n2) {
        var i3 = t2.create(n2, e2.getDimension()), r2 = e2.size();
        Ct.copy(e2, 0, i3, 0, r2);
        for (var s2 = r2; n2 > s2; s2++)
          Ct.copy(e2, 0, i3, s2, 1);
        return i3;
      }, h(St, B), e(St.prototype, { computeEnvelopeInternal: function() {
        return this.isEmpty() ? new C() : this.points.expandEnvelope(new C());
      }, isRing: function() {
        return this.isClosed() && this.isSimple();
      }, getSortIndex: function() {
        return B.SORTINDEX_LINESTRING;
      }, getCoordinates: function() {
        return this.points.toCoordinateArray();
      }, equalsExact: function() {
        if (2 === arguments.length) {
          var t2 = arguments[0], e2 = arguments[1];
          if (!this.isEquivalentClass(t2))
            return false;
          var n2 = t2;
          if (this.points.size() !== n2.points.size())
            return false;
          for (var i3 = 0; i3 < this.points.size(); i3++)
            if (!this.equal(this.points.getCoordinate(i3), n2.points.getCoordinate(i3), e2))
              return false;
          return true;
        }
        return B.prototype.equalsExact.apply(this, arguments);
      }, normalize: function() {
        for (var t2 = 0; t2 < Math.trunc(this.points.size() / 2); t2++) {
          var e2 = this.points.size() - 1 - t2;
          if (!this.points.getCoordinate(t2).equals(this.points.getCoordinate(e2)))
            return this.points.getCoordinate(t2).compareTo(this.points.getCoordinate(e2)) > 0 && Ct.reverse(this.points), null;
        }
      }, getCoordinate: function() {
        return this.isEmpty() ? null : this.points.getCoordinate(0);
      }, getBoundaryDimension: function() {
        return this.isClosed() ? lt.FALSE : 0;
      }, isClosed: function() {
        return this.isEmpty() ? false : this.getCoordinateN(0).equals2D(this.getCoordinateN(this.getNumPoints() - 1));
      }, getEndPoint: function() {
        return this.isEmpty() ? null : this.getPointN(this.getNumPoints() - 1);
      }, getDimension: function() {
        return 1;
      }, getLength: function() {
        return he.computeLength(this.points);
      }, getNumPoints: function() {
        return this.points.size();
      }, reverse: function() {
        var t2 = this.points.copy();
        Ct.reverse(t2);
        var e2 = this.getFactory().createLineString(t2);
        return e2;
      }, compareToSameClass: function() {
        if (1 === arguments.length) {
          for (var t2 = arguments[0], e2 = t2, n2 = 0, i3 = 0; n2 < this.points.size() && i3 < e2.points.size(); ) {
            var r2 = this.points.getCoordinate(n2).compareTo(e2.points.getCoordinate(i3));
            if (0 !== r2)
              return r2;
            n2++, i3++;
          }
          return n2 < this.points.size() ? 1 : i3 < e2.points.size() ? -1 : 0;
        }
        if (2 === arguments.length) {
          var s2 = arguments[0], o2 = arguments[1], e2 = s2;
          return o2.compare(this.points, e2.points);
        }
      }, apply: function() {
        if (R(arguments[0], z))
          for (var t2 = arguments[0], e2 = 0; e2 < this.points.size(); e2++)
            t2.filter(this.points.getCoordinate(e2));
        else if (R(arguments[0], ct)) {
          var n2 = arguments[0];
          if (0 === this.points.size())
            return null;
          for (var e2 = 0; e2 < this.points.size() && (n2.filter(this.points, e2), !n2.isDone()); e2++)
            ;
          n2.isGeometryChanged() && this.geometryChanged();
        } else if (R(arguments[0], ht)) {
          var i3 = arguments[0];
          i3.filter(this);
        } else if (R(arguments[0], q)) {
          var r2 = arguments[0];
          r2.filter(this);
        }
      }, getBoundary: function() {
        return new dt(this).getBoundary();
      }, isEquivalentClass: function(t2) {
        return t2 instanceof St;
      }, clone: function() {
        var t2 = B.prototype.clone.call(this);
        return t2.points = this.points.clone(), t2;
      }, getCoordinateN: function(t2) {
        return this.points.getCoordinate(t2);
      }, getGeometryType: function() {
        return "LineString";
      }, copy: function() {
        return new St(this.points.copy(), this.factory);
      }, getCoordinateSequence: function() {
        return this.points;
      }, isEmpty: function() {
        return 0 === this.points.size();
      }, init: function(t2) {
        if (null === t2 && (t2 = this.getFactory().getCoordinateSequenceFactory().create([])), 1 === t2.size())
          throw new i2("Invalid number of points in LineString (found " + t2.size() + " - must be 0 or >= 2)");
        this.points = t2;
      }, isCoordinate: function(t2) {
        for (var e2 = 0; e2 < this.points.size(); e2++)
          if (this.points.getCoordinate(e2).equals(t2))
            return true;
        return false;
      }, getStartPoint: function() {
        return this.isEmpty() ? null : this.getPointN(0);
      }, getPointN: function(t2) {
        return this.getFactory().createPoint(this.points.getCoordinate(t2));
      }, interfaces_: function() {
        return [st];
      }, getClass: function() {
        return St;
      } }), St.serialVersionUID = 3110669828065365500, e(wt.prototype, { interfaces_: function() {
        return [];
      }, getClass: function() {
        return wt;
      } }), h(Lt, B), e(Lt.prototype, { computeEnvelopeInternal: function() {
        if (this.isEmpty())
          return new C();
        var t2 = new C();
        return t2.expandToInclude(this.coordinates.getX(0), this.coordinates.getY(0)), t2;
      }, getSortIndex: function() {
        return B.SORTINDEX_POINT;
      }, getCoordinates: function() {
        return this.isEmpty() ? [] : [this.getCoordinate()];
      }, equalsExact: function() {
        if (2 === arguments.length) {
          var t2 = arguments[0], e2 = arguments[1];
          return this.isEquivalentClass(t2) ? this.isEmpty() && t2.isEmpty() ? true : this.isEmpty() !== t2.isEmpty() ? false : this.equal(t2.getCoordinate(), this.getCoordinate(), e2) : false;
        }
        return B.prototype.equalsExact.apply(this, arguments);
      }, normalize: function() {
      }, getCoordinate: function() {
        return 0 !== this.coordinates.size() ? this.coordinates.getCoordinate(0) : null;
      }, getBoundaryDimension: function() {
        return lt.FALSE;
      }, getDimension: function() {
        return 0;
      }, getNumPoints: function() {
        return this.isEmpty() ? 0 : 1;
      }, reverse: function() {
        return this.copy();
      }, getX: function() {
        if (null === this.getCoordinate())
          throw new IllegalStateException("getX called on empty Point");
        return this.getCoordinate().x;
      }, compareToSameClass: function() {
        if (1 === arguments.length) {
          var t2 = arguments[0], e2 = t2;
          return this.getCoordinate().compareTo(e2.getCoordinate());
        }
        if (2 === arguments.length) {
          var n2 = arguments[0], i3 = arguments[1], e2 = n2;
          return i3.compare(this.coordinates, e2.coordinates);
        }
      }, apply: function() {
        if (R(arguments[0], z)) {
          var t2 = arguments[0];
          if (this.isEmpty())
            return null;
          t2.filter(this.getCoordinate());
        } else if (R(arguments[0], ct)) {
          var e2 = arguments[0];
          if (this.isEmpty())
            return null;
          e2.filter(this.coordinates, 0), e2.isGeometryChanged() && this.geometryChanged();
        } else if (R(arguments[0], ht)) {
          var n2 = arguments[0];
          n2.filter(this);
        } else if (R(arguments[0], q)) {
          var i3 = arguments[0];
          i3.filter(this);
        }
      }, getBoundary: function() {
        return this.getFactory().createGeometryCollection(null);
      }, clone: function() {
        var t2 = B.prototype.clone.call(this);
        return t2.coordinates = this.coordinates.clone(), t2;
      }, getGeometryType: function() {
        return "Point";
      }, copy: function() {
        return new Lt(this.coordinates.copy(), this.factory);
      }, getCoordinateSequence: function() {
        return this.coordinates;
      }, getY: function() {
        if (null === this.getCoordinate())
          throw new IllegalStateException("getY called on empty Point");
        return this.getCoordinate().y;
      }, isEmpty: function() {
        return 0 === this.coordinates.size();
      }, init: function(t2) {
        null === t2 && (t2 = this.getFactory().getCoordinateSequenceFactory().create([])), f.isTrue(t2.size() <= 1), this.coordinates = t2;
      }, isSimple: function() {
        return true;
      }, interfaces_: function() {
        return [wt];
      }, getClass: function() {
        return Lt;
      } }), Lt.serialVersionUID = 4902022702746615e3, e(Rt.prototype, { interfaces_: function() {
        return [];
      }, getClass: function() {
        return Rt;
      } }), h(Tt, B), e(Tt.prototype, { computeEnvelopeInternal: function() {
        return this.shell.getEnvelopeInternal();
      }, getSortIndex: function() {
        return B.SORTINDEX_POLYGON;
      }, getCoordinates: function() {
        if (this.isEmpty())
          return [];
        for (var t2 = new Array(this.getNumPoints()).fill(null), e2 = -1, n2 = this.shell.getCoordinates(), i3 = 0; i3 < n2.length; i3++)
          e2++, t2[e2] = n2[i3];
        for (var r2 = 0; r2 < this.holes.length; r2++)
          for (var s2 = this.holes[r2].getCoordinates(), o2 = 0; o2 < s2.length; o2++)
            e2++, t2[e2] = s2[o2];
        return t2;
      }, getArea: function() {
        var t2 = 0;
        t2 += Math.abs(he.signedArea(this.shell.getCoordinateSequence()));
        for (var e2 = 0; e2 < this.holes.length; e2++)
          t2 -= Math.abs(he.signedArea(this.holes[e2].getCoordinateSequence()));
        return t2;
      }, isRectangle: function() {
        if (0 !== this.getNumInteriorRing())
          return false;
        if (null === this.shell)
          return false;
        if (5 !== this.shell.getNumPoints())
          return false;
        for (var t2 = this.shell.getCoordinateSequence(), e2 = this.getEnvelopeInternal(), n2 = 0; 5 > n2; n2++) {
          var i3 = t2.getX(n2);
          if (i3 !== e2.getMinX() && i3 !== e2.getMaxX())
            return false;
          var r2 = t2.getY(n2);
          if (r2 !== e2.getMinY() && r2 !== e2.getMaxY())
            return false;
        }
        for (var s2 = t2.getX(0), o2 = t2.getY(0), n2 = 1; 4 >= n2; n2++) {
          var i3 = t2.getX(n2), r2 = t2.getY(n2), a2 = i3 !== s2, u2 = r2 !== o2;
          if (a2 === u2)
            return false;
          s2 = i3, o2 = r2;
        }
        return true;
      }, equalsExact: function() {
        if (2 === arguments.length) {
          var t2 = arguments[0], e2 = arguments[1];
          if (!this.isEquivalentClass(t2))
            return false;
          var n2 = t2, i3 = this.shell, r2 = n2.shell;
          if (!i3.equalsExact(r2, e2))
            return false;
          if (this.holes.length !== n2.holes.length)
            return false;
          for (var s2 = 0; s2 < this.holes.length; s2++)
            if (!this.holes[s2].equalsExact(n2.holes[s2], e2))
              return false;
          return true;
        }
        return B.prototype.equalsExact.apply(this, arguments);
      }, normalize: function() {
        if (0 === arguments.length) {
          this.normalize(this.shell, true);
          for (var t2 = 0; t2 < this.holes.length; t2++)
            this.normalize(this.holes[t2], false);
          ut.sort(this.holes);
        } else if (2 === arguments.length) {
          var e2 = arguments[0], n2 = arguments[1];
          if (e2.isEmpty())
            return null;
          var i3 = new Array(e2.getCoordinates().length - 1).fill(null);
          A.arraycopy(e2.getCoordinates(), 0, i3, 0, i3.length);
          var r2 = H.minCoordinate(e2.getCoordinates());
          H.scroll(i3, r2), A.arraycopy(i3, 0, e2.getCoordinates(), 0, i3.length), e2.getCoordinates()[i3.length] = i3[0], he.isCCW(e2.getCoordinates()) === n2 && H.reverse(e2.getCoordinates());
        }
      }, getCoordinate: function() {
        return this.shell.getCoordinate();
      }, getNumInteriorRing: function() {
        return this.holes.length;
      }, getBoundaryDimension: function() {
        return 1;
      }, getDimension: function() {
        return 2;
      }, getLength: function() {
        var t2 = 0;
        t2 += this.shell.getLength();
        for (var e2 = 0; e2 < this.holes.length; e2++)
          t2 += this.holes[e2].getLength();
        return t2;
      }, getNumPoints: function() {
        for (var t2 = this.shell.getNumPoints(), e2 = 0; e2 < this.holes.length; e2++)
          t2 += this.holes[e2].getNumPoints();
        return t2;
      }, reverse: function() {
        var t2 = this.copy();
        t2.shell = this.shell.copy().reverse(), t2.holes = new Array(this.holes.length).fill(null);
        for (var e2 = 0; e2 < this.holes.length; e2++)
          t2.holes[e2] = this.holes[e2].copy().reverse();
        return t2;
      }, convexHull: function() {
        return this.getExteriorRing().convexHull();
      }, compareToSameClass: function() {
        if (1 === arguments.length) {
          var t2 = arguments[0], e2 = this.shell, n2 = t2.shell;
          return e2.compareToSameClass(n2);
        }
        if (2 === arguments.length) {
          var i3 = arguments[0], r2 = arguments[1], s2 = i3, e2 = this.shell, n2 = s2.shell, o2 = e2.compareToSameClass(n2, r2);
          if (0 !== o2)
            return o2;
          for (var a2 = this.getNumInteriorRing(), u2 = s2.getNumInteriorRing(), l2 = 0; a2 > l2 && u2 > l2; ) {
            var h2 = this.getInteriorRingN(l2), c2 = s2.getInteriorRingN(l2), f2 = h2.compareToSameClass(c2, r2);
            if (0 !== f2)
              return f2;
            l2++;
          }
          return a2 > l2 ? 1 : u2 > l2 ? -1 : 0;
        }
      }, apply: function() {
        if (R(arguments[0], z)) {
          var t2 = arguments[0];
          this.shell.apply(t2);
          for (var e2 = 0; e2 < this.holes.length; e2++)
            this.holes[e2].apply(t2);
        } else if (R(arguments[0], ct)) {
          var n2 = arguments[0];
          if (this.shell.apply(n2), !n2.isDone())
            for (var e2 = 0; e2 < this.holes.length && (this.holes[e2].apply(n2), !n2.isDone()); e2++)
              ;
          n2.isGeometryChanged() && this.geometryChanged();
        } else if (R(arguments[0], ht)) {
          var i3 = arguments[0];
          i3.filter(this);
        } else if (R(arguments[0], q)) {
          var r2 = arguments[0];
          r2.filter(this), this.shell.apply(r2);
          for (var e2 = 0; e2 < this.holes.length; e2++)
            this.holes[e2].apply(r2);
        }
      }, getBoundary: function() {
        if (this.isEmpty())
          return this.getFactory().createMultiLineString();
        var t2 = new Array(this.holes.length + 1).fill(null);
        t2[0] = this.shell;
        for (var e2 = 0; e2 < this.holes.length; e2++)
          t2[e2 + 1] = this.holes[e2];
        return t2.length <= 1 ? this.getFactory().createLinearRing(t2[0].getCoordinateSequence()) : this.getFactory().createMultiLineString(t2);
      }, clone: function() {
        var t2 = B.prototype.clone.call(this);
        t2.shell = this.shell.clone(), t2.holes = new Array(this.holes.length).fill(null);
        for (var e2 = 0; e2 < this.holes.length; e2++)
          t2.holes[e2] = this.holes[e2].clone();
        return t2;
      }, getGeometryType: function() {
        return "Polygon";
      }, copy: function() {
        for (var t2 = this.shell.copy(), e2 = new Array(this.holes.length).fill(null), n2 = 0; n2 < e2.length; n2++)
          e2[n2] = this.holes[n2].copy();
        return new Tt(t2, e2, this.factory);
      }, getExteriorRing: function() {
        return this.shell;
      }, isEmpty: function() {
        return this.shell.isEmpty();
      }, getInteriorRingN: function(t2) {
        return this.holes[t2];
      }, interfaces_: function() {
        return [Rt];
      }, getClass: function() {
        return Tt;
      } }), Tt.serialVersionUID = -3494792200821764600, h(Pt, ft), e(Pt.prototype, { getSortIndex: function() {
        return B.SORTINDEX_MULTIPOINT;
      }, isValid: function() {
        return true;
      }, equalsExact: function() {
        if (2 === arguments.length) {
          var t2 = arguments[0], e2 = arguments[1];
          return this.isEquivalentClass(t2) ? ft.prototype.equalsExact.call(this, t2, e2) : false;
        }
        return ft.prototype.equalsExact.apply(this, arguments);
      }, getCoordinate: function() {
        if (1 === arguments.length) {
          var t2 = arguments[0];
          return this.geometries[t2].getCoordinate();
        }
        return ft.prototype.getCoordinate.apply(this, arguments);
      }, getBoundaryDimension: function() {
        return lt.FALSE;
      }, getDimension: function() {
        return 0;
      }, getBoundary: function() {
        return this.getFactory().createGeometryCollection(null);
      }, getGeometryType: function() {
        return "MultiPoint";
      }, copy: function() {
        for (var t2 = new Array(this.geometries.length).fill(null), e2 = 0; e2 < t2.length; e2++)
          t2[e2] = this.geometries[e2].copy();
        return new Pt(t2, this.factory);
      }, interfaces_: function() {
        return [wt];
      }, getClass: function() {
        return Pt;
      } }), Pt.serialVersionUID = -8048474874175356e3, h(bt, St), e(bt.prototype, { getSortIndex: function() {
        return B.SORTINDEX_LINEARRING;
      }, getBoundaryDimension: function() {
        return lt.FALSE;
      }, isClosed: function() {
        return this.isEmpty() ? true : St.prototype.isClosed.call(this);
      }, reverse: function() {
        var t2 = this.points.copy();
        Ct.reverse(t2);
        var e2 = this.getFactory().createLinearRing(t2);
        return e2;
      }, validateConstruction: function() {
        if (!this.isEmpty() && !St.prototype.isClosed.call(this))
          throw new i2("Points of LinearRing do not form a closed linestring");
        if (this.getCoordinateSequence().size() >= 1 && this.getCoordinateSequence().size() < bt.MINIMUM_VALID_SIZE)
          throw new i2("Invalid number of points in LinearRing (found " + this.getCoordinateSequence().size() + " - must be 0 or >= 4)");
      }, getGeometryType: function() {
        return "LinearRing";
      }, copy: function() {
        return new bt(this.points.copy(), this.factory);
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return bt;
      } }), bt.MINIMUM_VALID_SIZE = 4, bt.serialVersionUID = -4261142084085851600, h(Ot, ft), e(Ot.prototype, { getSortIndex: function() {
        return B.SORTINDEX_MULTIPOLYGON;
      }, equalsExact: function() {
        if (2 === arguments.length) {
          var t2 = arguments[0], e2 = arguments[1];
          return this.isEquivalentClass(t2) ? ft.prototype.equalsExact.call(this, t2, e2) : false;
        }
        return ft.prototype.equalsExact.apply(this, arguments);
      }, getBoundaryDimension: function() {
        return 1;
      }, getDimension: function() {
        return 2;
      }, reverse: function() {
        for (var t2 = this.geometries.length, e2 = new Array(t2).fill(null), n2 = 0; n2 < this.geometries.length; n2++)
          e2[n2] = this.geometries[n2].reverse();
        return this.getFactory().createMultiPolygon(e2);
      }, getBoundary: function() {
        if (this.isEmpty())
          return this.getFactory().createMultiLineString();
        for (var t2 = new I(), e2 = 0; e2 < this.geometries.length; e2++)
          for (var n2 = this.geometries[e2], i3 = n2.getBoundary(), r2 = 0; r2 < i3.getNumGeometries(); r2++)
            t2.add(i3.getGeometryN(r2));
        var s2 = new Array(t2.size()).fill(null);
        return this.getFactory().createMultiLineString(t2.toArray(s2));
      }, getGeometryType: function() {
        return "MultiPolygon";
      }, copy: function() {
        for (var t2 = new Array(this.geometries.length).fill(null), e2 = 0; e2 < t2.length; e2++)
          t2[e2] = this.geometries[e2].copy();
        return new Ot(t2, this.factory);
      }, interfaces_: function() {
        return [Rt];
      }, getClass: function() {
        return Ot;
      } }), Ot.serialVersionUID = -551033529766975900, e(_t.prototype, { setCopyUserData: function(t2) {
        this.isUserDataCopied = t2;
      }, edit: function(t2, e2) {
        if (null === t2)
          return null;
        var n2 = this.editInternal(t2, e2);
        return this.isUserDataCopied && n2.setUserData(t2.getUserData()), n2;
      }, editInternal: function(t2, e2) {
        return null === this.factory && (this.factory = t2.getFactory()), t2 instanceof ft ? this.editGeometryCollection(t2, e2) : t2 instanceof Tt ? this.editPolygon(t2, e2) : t2 instanceof Lt ? e2.edit(t2, this.factory) : t2 instanceof St ? e2.edit(t2, this.factory) : (f.shouldNeverReachHere("Unsupported Geometry class: " + t2.getClass().getName()), null);
      }, editGeometryCollection: function(t2, e2) {
        for (var n2 = e2.edit(t2, this.factory), i3 = new I(), r2 = 0; r2 < n2.getNumGeometries(); r2++) {
          var s2 = this.edit(n2.getGeometryN(r2), e2);
          null === s2 || s2.isEmpty() || i3.add(s2);
        }
        return n2.getClass() === Pt ? this.factory.createMultiPoint(i3.toArray([])) : n2.getClass() === gt ? this.factory.createMultiLineString(i3.toArray([])) : n2.getClass() === Ot ? this.factory.createMultiPolygon(i3.toArray([])) : this.factory.createGeometryCollection(i3.toArray([]));
      }, editPolygon: function(t2, e2) {
        var n2 = e2.edit(t2, this.factory);
        if (null === n2 && (n2 = this.factory.createPolygon(null)), n2.isEmpty())
          return n2;
        var i3 = this.edit(n2.getExteriorRing(), e2);
        if (null === i3 || i3.isEmpty())
          return this.factory.createPolygon();
        for (var r2 = new I(), s2 = 0; s2 < n2.getNumInteriorRing(); s2++) {
          var o2 = this.edit(n2.getInteriorRingN(s2), e2);
          null === o2 || o2.isEmpty() || r2.add(o2);
        }
        return this.factory.createPolygon(i3, r2.toArray([]));
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return _t;
      } }), _t.GeometryEditorOperation = Mt, e(Dt.prototype, { edit: function(t2, e2) {
        return t2;
      }, interfaces_: function() {
        return [Mt];
      }, getClass: function() {
        return Dt;
      } }), e(At.prototype, { edit: function(t2, e2) {
        if (t2 instanceof bt)
          return e2.createLinearRing(this.editCoordinates(t2.getCoordinates(), t2));
        if (t2 instanceof St)
          return e2.createLineString(this.editCoordinates(t2.getCoordinates(), t2));
        if (t2 instanceof Lt) {
          var n2 = this.editCoordinates(t2.getCoordinates(), t2);
          return n2.length > 0 ? e2.createPoint(n2[0]) : e2.createPoint();
        }
        return t2;
      }, interfaces_: function() {
        return [Mt];
      }, getClass: function() {
        return At;
      } }), e(Ft.prototype, { edit: function(t2, e2) {
        return t2 instanceof bt ? e2.createLinearRing(this.edit(t2.getCoordinateSequence(), t2)) : t2 instanceof St ? e2.createLineString(this.edit(t2.getCoordinateSequence(), t2)) : t2 instanceof Lt ? e2.createPoint(this.edit(t2.getCoordinateSequence(), t2)) : t2;
      }, interfaces_: function() {
        return [Mt];
      }, getClass: function() {
        return Ft;
      } }), _t.NoOpGeometryOperation = Dt, _t.CoordinateOperation = At, _t.CoordinateSequenceOperation = Ft, e(Gt.prototype, { setOrdinate: function(t2, e2, n2) {
        switch (e2) {
          case D.X:
            this.coordinates[t2].x = n2;
            break;
          case D.Y:
            this.coordinates[t2].y = n2;
            break;
          case D.Z:
            this.coordinates[t2].z = n2;
            break;
          default:
            throw new i2("invalid ordinateIndex");
        }
      }, size: function() {
        return this.coordinates.length;
      }, getOrdinate: function(t2, e2) {
        switch (e2) {
          case D.X:
            return this.coordinates[t2].x;
          case D.Y:
            return this.coordinates[t2].y;
          case D.Z:
            return this.coordinates[t2].z;
        }
        return r.NaN;
      }, getCoordinate: function() {
        if (1 === arguments.length) {
          var t2 = arguments[0];
          return this.coordinates[t2];
        }
        if (2 === arguments.length) {
          var e2 = arguments[0], n2 = arguments[1];
          n2.x = this.coordinates[e2].x, n2.y = this.coordinates[e2].y, n2.z = this.coordinates[e2].z;
        }
      }, getCoordinateCopy: function(t2) {
        return new g(this.coordinates[t2]);
      }, getDimension: function() {
        return this.dimension;
      }, getX: function(t2) {
        return this.coordinates[t2].x;
      }, clone: function() {
        for (var t2 = new Array(this.size()).fill(null), e2 = 0; e2 < this.coordinates.length; e2++)
          t2[e2] = this.coordinates[e2].clone();
        return new Gt(t2, this.dimension);
      }, expandEnvelope: function(t2) {
        for (var e2 = 0; e2 < this.coordinates.length; e2++)
          t2.expandToInclude(this.coordinates[e2]);
        return t2;
      }, copy: function() {
        for (var t2 = new Array(this.size()).fill(null), e2 = 0; e2 < this.coordinates.length; e2++)
          t2[e2] = this.coordinates[e2].copy();
        return new Gt(t2, this.dimension);
      }, toString: function() {
        if (this.coordinates.length > 0) {
          var t2 = new P(17 * this.coordinates.length);
          t2.append("("), t2.append(this.coordinates[0]);
          for (var e2 = 1; e2 < this.coordinates.length; e2++)
            t2.append(", "), t2.append(this.coordinates[e2]);
          return t2.append(")"), t2.toString();
        }
        return "()";
      }, getY: function(t2) {
        return this.coordinates[t2].y;
      }, toCoordinateArray: function() {
        return this.coordinates;
      }, interfaces_: function() {
        return [D, u];
      }, getClass: function() {
        return Gt;
      } }), Gt.serialVersionUID = -915438501601840600, e(qt.prototype, { readResolve: function() {
        return qt.instance();
      }, create: function() {
        if (1 === arguments.length) {
          if (arguments[0] instanceof Array) {
            var t2 = arguments[0];
            return new Gt(t2);
          }
          if (R(arguments[0], D)) {
            var e2 = arguments[0];
            return new Gt(e2);
          }
        } else if (2 === arguments.length) {
          var n2 = arguments[0], i3 = arguments[1];
          return i3 > 3 && (i3 = 3), 2 > i3 ? new Gt(n2) : new Gt(n2, i3);
        }
      }, interfaces_: function() {
        return [G, u];
      }, getClass: function() {
        return qt;
      } }), qt.instance = function() {
        return qt.instanceObject;
      }, qt.serialVersionUID = -4099577099607551500, qt.instanceObject = new qt();
      var no, io = Object.defineProperty, ro = zt({ delete: kt, has: Xt, get: Yt, set: Ht, keys: jt, values: Kt, entries: Zt, forEach: $t, clear: Wt }), so = "undefined" != typeof Map && Map.prototype.values ? Map : ro;
      te.prototype = new K(), te.prototype.get = function(t2) {
        return this.map_.get(t2) || null;
      }, te.prototype.put = function(t2, e2) {
        return this.map_.set(t2, e2), e2;
      }, te.prototype.values = function() {
        for (var t2 = new I(), e2 = this.map_.values(), n2 = e2.next(); !n2.done; )
          t2.add(n2.value), n2 = e2.next();
        return t2;
      }, te.prototype.entrySet = function() {
        var t2 = new J();
        return this.map_.entries().forEach(function(e2) {
          return t2.add(e2);
        }), t2;
      }, te.prototype.size = function() {
        return this.map_.size();
      }, e(ee.prototype, { equals: function(t2) {
        if (!(t2 instanceof ee))
          return false;
        var e2 = t2;
        return this.modelType === e2.modelType && this.scale === e2.scale;
      }, compareTo: function(t2) {
        var e2 = t2, n2 = this.getMaximumSignificantDigits(), i3 = e2.getMaximumSignificantDigits();
        return new b(n2).compareTo(new b(i3));
      }, getScale: function() {
        return this.scale;
      }, isFloating: function() {
        return this.modelType === ee.FLOATING || this.modelType === ee.FLOATING_SINGLE;
      }, getType: function() {
        return this.modelType;
      }, toString: function() {
        var t2 = "UNKNOWN";
        return this.modelType === ee.FLOATING ? t2 = "Floating" : this.modelType === ee.FLOATING_SINGLE ? t2 = "Floating-Single" : this.modelType === ee.FIXED && (t2 = "Fixed (Scale=" + this.getScale() + ")"), t2;
      }, makePrecise: function() {
        if ("number" == typeof arguments[0]) {
          var t2 = arguments[0];
          if (r.isNaN(t2))
            return t2;
          if (this.modelType === ee.FLOATING_SINGLE) {
            var e2 = t2;
            return e2;
          }
          return this.modelType === ee.FIXED ? Math.round(t2 * this.scale) / this.scale : t2;
        }
        if (arguments[0] instanceof g) {
          var n2 = arguments[0];
          if (this.modelType === ee.FLOATING)
            return null;
          n2.x = this.makePrecise(n2.x), n2.y = this.makePrecise(n2.y);
        }
      }, getMaximumSignificantDigits: function() {
        var t2 = 16;
        return this.modelType === ee.FLOATING ? t2 = 16 : this.modelType === ee.FLOATING_SINGLE ? t2 = 6 : this.modelType === ee.FIXED && (t2 = 1 + Math.trunc(Math.ceil(Math.log(this.getScale()) / Math.log(10)))), t2;
      }, setScale: function(t2) {
        this.scale = Math.abs(t2);
      }, interfaces_: function() {
        return [u, s];
      }, getClass: function() {
        return ee;
      } }), ee.mostPrecise = function(t2, e2) {
        return t2.compareTo(e2) >= 0 ? t2 : e2;
      }, e(ne.prototype, { readResolve: function() {
        return ne.nameToTypeMap.get(this.name);
      }, toString: function() {
        return this.name;
      }, interfaces_: function() {
        return [u];
      }, getClass: function() {
        return ne;
      } }), ne.serialVersionUID = -552860263173159e4, ne.nameToTypeMap = new te(), ee.Type = ne, ee.serialVersionUID = 7777263578777804e3, ee.FIXED = new ne("FIXED"), ee.FLOATING = new ne("FLOATING"), ee.FLOATING_SINGLE = new ne("FLOATING SINGLE"), ee.maximumPreciseValue = 9007199254740992, e(ie.prototype, { toGeometry: function(t2) {
        return t2.isNull() ? this.createPoint(null) : t2.getMinX() === t2.getMaxX() && t2.getMinY() === t2.getMaxY() ? this.createPoint(new g(t2.getMinX(), t2.getMinY())) : t2.getMinX() === t2.getMaxX() || t2.getMinY() === t2.getMaxY() ? this.createLineString([new g(t2.getMinX(), t2.getMinY()), new g(t2.getMaxX(), t2.getMaxY())]) : this.createPolygon(this.createLinearRing([new g(t2.getMinX(), t2.getMinY()), new g(t2.getMinX(), t2.getMaxY()), new g(t2.getMaxX(), t2.getMaxY()), new g(t2.getMaxX(), t2.getMinY()), new g(t2.getMinX(), t2.getMinY())]), null);
      }, createLineString: function() {
        if (0 === arguments.length)
          return this.createLineString(this.getCoordinateSequenceFactory().create([]));
        if (1 === arguments.length) {
          if (arguments[0] instanceof Array) {
            var t2 = arguments[0];
            return this.createLineString(null !== t2 ? this.getCoordinateSequenceFactory().create(t2) : null);
          }
          if (R(arguments[0], D)) {
            var e2 = arguments[0];
            return new St(e2, this);
          }
        }
      }, createMultiLineString: function() {
        if (0 === arguments.length)
          return new gt(null, this);
        if (1 === arguments.length) {
          var t2 = arguments[0];
          return new gt(t2, this);
        }
      }, buildGeometry: function(t2) {
        for (var e2 = null, n2 = false, i3 = false, r2 = t2.iterator(); r2.hasNext(); ) {
          var s2 = r2.next(), o2 = s2.getClass();
          null === e2 && (e2 = o2), o2 !== e2 && (n2 = true), s2.isGeometryCollectionOrDerived() && (i3 = true);
        }
        if (null === e2)
          return this.createGeometryCollection();
        if (n2 || i3)
          return this.createGeometryCollection(ie.toGeometryArray(t2));
        var a2 = t2.iterator().next(), u2 = t2.size() > 1;
        if (u2) {
          if (a2 instanceof Tt)
            return this.createMultiPolygon(ie.toPolygonArray(t2));
          if (a2 instanceof St)
            return this.createMultiLineString(ie.toLineStringArray(t2));
          if (a2 instanceof Lt)
            return this.createMultiPoint(ie.toPointArray(t2));
          f.shouldNeverReachHere("Unhandled class: " + a2.getClass().getName());
        }
        return a2;
      }, createMultiPointFromCoords: function(t2) {
        return this.createMultiPoint(null !== t2 ? this.getCoordinateSequenceFactory().create(t2) : null);
      }, createPoint: function() {
        if (0 === arguments.length)
          return this.createPoint(this.getCoordinateSequenceFactory().create([]));
        if (1 === arguments.length) {
          if (arguments[0] instanceof g) {
            var t2 = arguments[0];
            return this.createPoint(null !== t2 ? this.getCoordinateSequenceFactory().create([t2]) : null);
          }
          if (R(arguments[0], D)) {
            var e2 = arguments[0];
            return new Lt(e2, this);
          }
        }
      }, getCoordinateSequenceFactory: function() {
        return this.coordinateSequenceFactory;
      }, createPolygon: function() {
        if (0 === arguments.length)
          return new Tt(null, null, this);
        if (1 === arguments.length) {
          if (R(arguments[0], D)) {
            var t2 = arguments[0];
            return this.createPolygon(this.createLinearRing(t2));
          }
          if (arguments[0] instanceof Array) {
            var e2 = arguments[0];
            return this.createPolygon(this.createLinearRing(e2));
          }
          if (arguments[0] instanceof bt) {
            var n2 = arguments[0];
            return this.createPolygon(n2, null);
          }
        } else if (2 === arguments.length) {
          var i3 = arguments[0], r2 = arguments[1];
          return new Tt(i3, r2, this);
        }
      }, getSRID: function() {
        return this.SRID;
      }, createGeometryCollection: function() {
        if (0 === arguments.length)
          return new ft(null, this);
        if (1 === arguments.length) {
          var t2 = arguments[0];
          return new ft(t2, this);
        }
      }, createGeometry: function(t2) {
        var e2 = new _t(this);
        return e2.edit(t2, { edit: function() {
          if (2 === arguments.length) {
            var t3 = arguments[0];
            arguments[1];
            return this.coordinateSequenceFactory.create(t3);
          }
        } });
      }, getPrecisionModel: function() {
        return this.precisionModel;
      }, createLinearRing: function() {
        if (0 === arguments.length)
          return this.createLinearRing(this.getCoordinateSequenceFactory().create([]));
        if (1 === arguments.length) {
          if (arguments[0] instanceof Array) {
            var t2 = arguments[0];
            return this.createLinearRing(null !== t2 ? this.getCoordinateSequenceFactory().create(t2) : null);
          }
          if (R(arguments[0], D)) {
            var e2 = arguments[0];
            return new bt(e2, this);
          }
        }
      }, createMultiPolygon: function() {
        if (0 === arguments.length)
          return new Ot(null, this);
        if (1 === arguments.length) {
          var t2 = arguments[0];
          return new Ot(t2, this);
        }
      }, createMultiPoint: function() {
        if (0 === arguments.length)
          return new Pt(null, this);
        if (1 === arguments.length) {
          if (arguments[0] instanceof Array) {
            var t2 = arguments[0];
            return new Pt(t2, this);
          }
          if (arguments[0] instanceof Array) {
            var e2 = arguments[0];
            return this.createMultiPoint(null !== e2 ? this.getCoordinateSequenceFactory().create(e2) : null);
          }
          if (R(arguments[0], D)) {
            var n2 = arguments[0];
            if (null === n2)
              return this.createMultiPoint(new Array(0).fill(null));
            for (var i3 = new Array(n2.size()).fill(null), r2 = 0; r2 < n2.size(); r2++) {
              var s2 = this.getCoordinateSequenceFactory().create(1, n2.getDimension());
              Ct.copy(n2, r2, s2, 0, 1), i3[r2] = this.createPoint(s2);
            }
            return this.createMultiPoint(i3);
          }
        }
      }, interfaces_: function() {
        return [u];
      }, getClass: function() {
        return ie;
      } }), ie.toMultiPolygonArray = function(t2) {
        var e2 = new Array(t2.size()).fill(null);
        return t2.toArray(e2);
      }, ie.toGeometryArray = function(t2) {
        if (null === t2)
          return null;
        var e2 = new Array(t2.size()).fill(null);
        return t2.toArray(e2);
      }, ie.getDefaultCoordinateSequenceFactory = function() {
        return qt.instance();
      }, ie.toMultiLineStringArray = function(t2) {
        var e2 = new Array(t2.size()).fill(null);
        return t2.toArray(e2);
      }, ie.toLineStringArray = function(t2) {
        var e2 = new Array(t2.size()).fill(null);
        return t2.toArray(e2);
      }, ie.toMultiPointArray = function(t2) {
        var e2 = new Array(t2.size()).fill(null);
        return t2.toArray(e2);
      }, ie.toLinearRingArray = function(t2) {
        var e2 = new Array(t2.size()).fill(null);
        return t2.toArray(e2);
      }, ie.toPointArray = function(t2) {
        var e2 = new Array(t2.size()).fill(null);
        return t2.toArray(e2);
      }, ie.toPolygonArray = function(t2) {
        var e2 = new Array(t2.size()).fill(null);
        return t2.toArray(e2);
      }, ie.createPointFromInternalCoord = function(t2, e2) {
        return e2.getPrecisionModel().makePrecise(t2), e2.getFactory().createPoint(t2);
      }, ie.serialVersionUID = -6820524753094096e3;
      var oo = { typeStr: /^\s*(\w+)\s*\(\s*(.*)\s*\)\s*$/, emptyTypeStr: /^\s*(\w+)\s*EMPTY\s*$/, spaces: /\s+/, parenComma: /\)\s*,\s*\(/, doubleParenComma: /\)\s*\)\s*,\s*\(\s*\(/, trimParens: /^\s*\(?(.*?)\)?\s*$/ };
      e(re.prototype, { read: function(t2) {
        var e2, n2, i3;
        t2 = t2.replace(/[\n\r]/g, " ");
        var r2 = oo.typeStr.exec(t2);
        if (-1 !== t2.search("EMPTY") && (r2 = oo.emptyTypeStr.exec(t2), r2[2] = void 0), r2 && (n2 = r2[1].toLowerCase(), i3 = r2[2], uo[n2] && (e2 = uo[n2].apply(this, [i3]))), void 0 === e2)
          throw new Error("Could not parse WKT " + t2);
        return e2;
      }, write: function(t2) {
        return this.extractGeometry(t2);
      }, extractGeometry: function(t2) {
        var e2 = t2.getGeometryType().toLowerCase();
        if (!ao[e2])
          return null;
        var n2, i3 = e2.toUpperCase();
        return n2 = t2.isEmpty() ? i3 + " EMPTY" : i3 + "(" + ao[e2].apply(this, [t2]) + ")";
      } });
      var ao = { coordinate: function(t2) {
        return t2.x + " " + t2.y;
      }, point: function(t2) {
        return ao.coordinate.call(this, t2.coordinates.coordinates[0]);
      }, multipoint: function(t2) {
        for (var e2 = [], n2 = 0, i3 = t2.geometries.length; i3 > n2; ++n2)
          e2.push("(" + ao.point.apply(this, [t2.geometries[n2]]) + ")");
        return e2.join(",");
      }, linestring: function(t2) {
        for (var e2 = [], n2 = 0, i3 = t2.points.coordinates.length; i3 > n2; ++n2)
          e2.push(ao.coordinate.apply(this, [t2.points.coordinates[n2]]));
        return e2.join(",");
      }, linearring: function(t2) {
        for (var e2 = [], n2 = 0, i3 = t2.points.coordinates.length; i3 > n2; ++n2)
          e2.push(ao.coordinate.apply(this, [t2.points.coordinates[n2]]));
        return e2.join(",");
      }, multilinestring: function(t2) {
        for (var e2 = [], n2 = 0, i3 = t2.geometries.length; i3 > n2; ++n2)
          e2.push("(" + ao.linestring.apply(this, [t2.geometries[n2]]) + ")");
        return e2.join(",");
      }, polygon: function(t2) {
        var e2 = [];
        e2.push("(" + ao.linestring.apply(this, [t2.shell]) + ")");
        for (var n2 = 0, i3 = t2.holes.length; i3 > n2; ++n2)
          e2.push("(" + ao.linestring.apply(this, [t2.holes[n2]]) + ")");
        return e2.join(",");
      }, multipolygon: function(t2) {
        for (var e2 = [], n2 = 0, i3 = t2.geometries.length; i3 > n2; ++n2)
          e2.push("(" + ao.polygon.apply(this, [t2.geometries[n2]]) + ")");
        return e2.join(",");
      }, geometrycollection: function(t2) {
        for (var e2 = [], n2 = 0, i3 = t2.geometries.length; i3 > n2; ++n2)
          e2.push(this.extractGeometry(t2.geometries[n2]));
        return e2.join(",");
      } }, uo = { point: function(t2) {
        if (void 0 === t2)
          return this.geometryFactory.createPoint();
        var e2 = t2.trim().split(oo.spaces);
        return this.geometryFactory.createPoint(new g(Number.parseFloat(e2[0]), Number.parseFloat(e2[1])));
      }, multipoint: function(t2) {
        if (void 0 === t2)
          return this.geometryFactory.createMultiPoint();
        for (var e2, n2 = t2.trim().split(","), i3 = [], r2 = 0, s2 = n2.length; s2 > r2; ++r2)
          e2 = n2[r2].replace(oo.trimParens, "$1"), i3.push(uo.point.apply(this, [e2]));
        return this.geometryFactory.createMultiPoint(i3);
      }, linestring: function(t2) {
        if (void 0 === t2)
          return this.geometryFactory.createLineString();
        for (var e2, n2 = t2.trim().split(","), i3 = [], r2 = 0, s2 = n2.length; s2 > r2; ++r2)
          e2 = n2[r2].trim().split(oo.spaces), i3.push(new g(Number.parseFloat(e2[0]), Number.parseFloat(e2[1])));
        return this.geometryFactory.createLineString(i3);
      }, linearring: function(t2) {
        if (void 0 === t2)
          return this.geometryFactory.createLinearRing();
        for (var e2, n2 = t2.trim().split(","), i3 = [], r2 = 0, s2 = n2.length; s2 > r2; ++r2)
          e2 = n2[r2].trim().split(oo.spaces), i3.push(new g(Number.parseFloat(e2[0]), Number.parseFloat(e2[1])));
        return this.geometryFactory.createLinearRing(i3);
      }, multilinestring: function(t2) {
        if (void 0 === t2)
          return this.geometryFactory.createMultiLineString();
        for (var e2, n2 = t2.trim().split(oo.parenComma), i3 = [], r2 = 0, s2 = n2.length; s2 > r2; ++r2)
          e2 = n2[r2].replace(oo.trimParens, "$1"), i3.push(uo.linestring.apply(this, [e2]));
        return this.geometryFactory.createMultiLineString(i3);
      }, polygon: function(t2) {
        if (void 0 === t2)
          return this.geometryFactory.createPolygon();
        for (var e2, n2, i3, r2, s2 = t2.trim().split(oo.parenComma), o2 = [], a2 = 0, u2 = s2.length; u2 > a2; ++a2)
          e2 = s2[a2].replace(oo.trimParens, "$1"), n2 = uo.linestring.apply(this, [e2]), i3 = this.geometryFactory.createLinearRing(n2.points), 0 === a2 ? r2 = i3 : o2.push(i3);
        return this.geometryFactory.createPolygon(r2, o2);
      }, multipolygon: function(t2) {
        if (void 0 === t2)
          return this.geometryFactory.createMultiPolygon();
        for (var e2, n2 = t2.trim().split(oo.doubleParenComma), i3 = [], r2 = 0, s2 = n2.length; s2 > r2; ++r2)
          e2 = n2[r2].replace(oo.trimParens, "$1"), i3.push(uo.polygon.apply(this, [e2]));
        return this.geometryFactory.createMultiPolygon(i3);
      }, geometrycollection: function(t2) {
        if (void 0 === t2)
          return this.geometryFactory.createGeometryCollection();
        t2 = t2.replace(/,\s*([A-Za-z])/g, "|$1");
        for (var e2 = t2.trim().split("|"), n2 = [], i3 = 0, r2 = e2.length; r2 > i3; ++i3)
          n2.push(this.read(e2[i3]));
        return this.geometryFactory.createGeometryCollection(n2);
      } };
      e(se.prototype, { write: function(t2) {
        return this.parser.write(t2);
      } }), e(se, { toLineString: function(t2, e2) {
        if (2 !== arguments.length)
          throw new Error("Not implemented");
        return "LINESTRING ( " + t2.x + " " + t2.y + ", " + e2.x + " " + e2.y + " )";
      } }), e(oe.prototype, { getIndexAlongSegment: function(t2, e2) {
        return this.computeIntLineIndex(), this.intLineIndex[t2][e2];
      }, getTopologySummary: function() {
        var t2 = new P();
        return this.isEndPoint() && t2.append(" endpoint"), this._isProper && t2.append(" proper"), this.isCollinear() && t2.append(" collinear"), t2.toString();
      }, computeIntersection: function(t2, e2, n2, i3) {
        this.inputLines[0][0] = t2, this.inputLines[0][1] = e2, this.inputLines[1][0] = n2, this.inputLines[1][1] = i3, this.result = this.computeIntersect(t2, e2, n2, i3);
      }, getIntersectionNum: function() {
        return this.result;
      }, computeIntLineIndex: function() {
        if (0 === arguments.length)
          null === this.intLineIndex && (this.intLineIndex = Array(2).fill().map(function() {
            return Array(2);
          }), this.computeIntLineIndex(0), this.computeIntLineIndex(1));
        else if (1 === arguments.length) {
          var t2 = arguments[0], e2 = this.getEdgeDistance(t2, 0), n2 = this.getEdgeDistance(t2, 1);
          e2 > n2 ? (this.intLineIndex[t2][0] = 0, this.intLineIndex[t2][1] = 1) : (this.intLineIndex[t2][0] = 1, this.intLineIndex[t2][1] = 0);
        }
      }, isProper: function() {
        return this.hasIntersection() && this._isProper;
      }, setPrecisionModel: function(t2) {
        this.precisionModel = t2;
      }, isInteriorIntersection: function() {
        if (0 === arguments.length)
          return this.isInteriorIntersection(0) ? true : !!this.isInteriorIntersection(1);
        if (1 === arguments.length) {
          for (var t2 = arguments[0], e2 = 0; e2 < this.result; e2++)
            if (!this.intPt[e2].equals2D(this.inputLines[t2][0]) && !this.intPt[e2].equals2D(this.inputLines[t2][1]))
              return true;
          return false;
        }
      }, getIntersection: function(t2) {
        return this.intPt[t2];
      }, isEndPoint: function() {
        return this.hasIntersection() && !this._isProper;
      }, hasIntersection: function() {
        return this.result !== oe.NO_INTERSECTION;
      }, getEdgeDistance: function(t2, e2) {
        var n2 = oe.computeEdgeDistance(this.intPt[e2], this.inputLines[t2][0], this.inputLines[t2][1]);
        return n2;
      }, isCollinear: function() {
        return this.result === oe.COLLINEAR_INTERSECTION;
      }, toString: function() {
        return se.toLineString(this.inputLines[0][0], this.inputLines[0][1]) + " - " + se.toLineString(this.inputLines[1][0], this.inputLines[1][1]) + this.getTopologySummary();
      }, getEndpoint: function(t2, e2) {
        return this.inputLines[t2][e2];
      }, isIntersection: function(t2) {
        for (var e2 = 0; e2 < this.result; e2++)
          if (this.intPt[e2].equals2D(t2))
            return true;
        return false;
      }, getIntersectionAlongSegment: function(t2, e2) {
        return this.computeIntLineIndex(), this.intPt[this.intLineIndex[t2][e2]];
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return oe;
      } }), oe.computeEdgeDistance = function(t2, e2, n2) {
        var i3 = Math.abs(n2.x - e2.x), r2 = Math.abs(n2.y - e2.y), s2 = -1;
        if (t2.equals(e2))
          s2 = 0;
        else if (t2.equals(n2))
          s2 = i3 > r2 ? i3 : r2;
        else {
          var o2 = Math.abs(t2.x - e2.x), a2 = Math.abs(t2.y - e2.y);
          s2 = i3 > r2 ? o2 : a2, 0 !== s2 || t2.equals(e2) || (s2 = Math.max(o2, a2));
        }
        return f.isTrue(!(0 === s2 && !t2.equals(e2)), "Bad distance calculation"), s2;
      }, oe.nonRobustComputeEdgeDistance = function(t2, e2, n2) {
        var i3 = t2.x - e2.x, r2 = t2.y - e2.y, s2 = Math.sqrt(i3 * i3 + r2 * r2);
        return f.isTrue(!(0 === s2 && !t2.equals(e2)), "Invalid distance calculation"), s2;
      }, oe.DONT_INTERSECT = 0, oe.DO_INTERSECT = 1, oe.COLLINEAR = 2, oe.NO_INTERSECTION = 0, oe.POINT_INTERSECTION = 1, oe.COLLINEAR_INTERSECTION = 2, h(ae, oe), e(ae.prototype, { isInSegmentEnvelopes: function(t2) {
        var e2 = new C(this.inputLines[0][0], this.inputLines[0][1]), n2 = new C(this.inputLines[1][0], this.inputLines[1][1]);
        return e2.contains(t2) && n2.contains(t2);
      }, computeIntersection: function() {
        if (3 !== arguments.length)
          return oe.prototype.computeIntersection.apply(this, arguments);
        var t2 = arguments[0], e2 = arguments[1], n2 = arguments[2];
        return this._isProper = false, C.intersects(e2, n2, t2) && 0 === he.orientationIndex(e2, n2, t2) && 0 === he.orientationIndex(n2, e2, t2) ? (this._isProper = true, (t2.equals(e2) || t2.equals(n2)) && (this._isProper = false), this.result = oe.POINT_INTERSECTION, null) : void (this.result = oe.NO_INTERSECTION);
      }, normalizeToMinimum: function(t2, e2, n2, i3, r2) {
        r2.x = this.smallestInAbsValue(t2.x, e2.x, n2.x, i3.x), r2.y = this.smallestInAbsValue(t2.y, e2.y, n2.y, i3.y), t2.x -= r2.x, t2.y -= r2.y, e2.x -= r2.x, e2.y -= r2.y, n2.x -= r2.x, n2.y -= r2.y, i3.x -= r2.x, i3.y -= r2.y;
      }, safeHCoordinateIntersection: function(t2, e2, n2, i3) {
        var r2 = null;
        try {
          r2 = F.intersection(t2, e2, n2, i3);
        } catch (s2) {
          if (!(s2 instanceof w))
            throw s2;
          r2 = ae.nearestEndpoint(t2, e2, n2, i3);
        } finally {
        }
        return r2;
      }, intersection: function(t2, e2, n2, i3) {
        var r2 = this.intersectionWithNormalization(t2, e2, n2, i3);
        return this.isInSegmentEnvelopes(r2) || (r2 = new g(ae.nearestEndpoint(t2, e2, n2, i3))), null !== this.precisionModel && this.precisionModel.makePrecise(r2), r2;
      }, smallestInAbsValue: function(t2, e2, n2, i3) {
        var r2 = t2, s2 = Math.abs(r2);
        return Math.abs(e2) < s2 && (r2 = e2, s2 = Math.abs(e2)), Math.abs(n2) < s2 && (r2 = n2, s2 = Math.abs(n2)), Math.abs(i3) < s2 && (r2 = i3), r2;
      }, checkDD: function(t2, e2, n2, i3, r2) {
        var s2 = M.intersection(t2, e2, n2, i3), o2 = this.isInSegmentEnvelopes(s2);
        A.out.println("DD in env = " + o2 + "  --------------------- " + s2), r2.distance(s2) > 1e-4 && A.out.println("Distance = " + r2.distance(s2));
      }, intersectionWithNormalization: function(t2, e2, n2, i3) {
        var r2 = new g(t2), s2 = new g(e2), o2 = new g(n2), a2 = new g(i3), u2 = new g();
        this.normalizeToEnvCentre(r2, s2, o2, a2, u2);
        var l2 = this.safeHCoordinateIntersection(r2, s2, o2, a2);
        return l2.x += u2.x, l2.y += u2.y, l2;
      }, computeCollinearIntersection: function(t2, e2, n2, i3) {
        var r2 = C.intersects(t2, e2, n2), s2 = C.intersects(t2, e2, i3), o2 = C.intersects(n2, i3, t2), a2 = C.intersects(n2, i3, e2);
        return r2 && s2 ? (this.intPt[0] = n2, this.intPt[1] = i3, oe.COLLINEAR_INTERSECTION) : o2 && a2 ? (this.intPt[0] = t2, this.intPt[1] = e2, oe.COLLINEAR_INTERSECTION) : r2 && o2 ? (this.intPt[0] = n2, this.intPt[1] = t2, !n2.equals(t2) || s2 || a2 ? oe.COLLINEAR_INTERSECTION : oe.POINT_INTERSECTION) : r2 && a2 ? (this.intPt[0] = n2, this.intPt[1] = e2, !n2.equals(e2) || s2 || o2 ? oe.COLLINEAR_INTERSECTION : oe.POINT_INTERSECTION) : s2 && o2 ? (this.intPt[0] = i3, this.intPt[1] = t2, !i3.equals(t2) || r2 || a2 ? oe.COLLINEAR_INTERSECTION : oe.POINT_INTERSECTION) : s2 && a2 ? (this.intPt[0] = i3, this.intPt[1] = e2, !i3.equals(e2) || r2 || o2 ? oe.COLLINEAR_INTERSECTION : oe.POINT_INTERSECTION) : oe.NO_INTERSECTION;
      }, normalizeToEnvCentre: function(t2, e2, n2, i3, r2) {
        var s2 = t2.x < e2.x ? t2.x : e2.x, o2 = t2.y < e2.y ? t2.y : e2.y, a2 = t2.x > e2.x ? t2.x : e2.x, u2 = t2.y > e2.y ? t2.y : e2.y, l2 = n2.x < i3.x ? n2.x : i3.x, h2 = n2.y < i3.y ? n2.y : i3.y, c2 = n2.x > i3.x ? n2.x : i3.x, f2 = n2.y > i3.y ? n2.y : i3.y, g2 = s2 > l2 ? s2 : l2, d2 = c2 > a2 ? a2 : c2, p2 = o2 > h2 ? o2 : h2, v2 = f2 > u2 ? u2 : f2, m2 = (g2 + d2) / 2, y2 = (p2 + v2) / 2;
        r2.x = m2, r2.y = y2, t2.x -= r2.x, t2.y -= r2.y, e2.x -= r2.x, e2.y -= r2.y, n2.x -= r2.x, n2.y -= r2.y, i3.x -= r2.x, i3.y -= r2.y;
      }, computeIntersect: function(t2, e2, n2, i3) {
        if (this._isProper = false, !C.intersects(t2, e2, n2, i3))
          return oe.NO_INTERSECTION;
        var r2 = he.orientationIndex(t2, e2, n2), s2 = he.orientationIndex(t2, e2, i3);
        if (r2 > 0 && s2 > 0 || 0 > r2 && 0 > s2)
          return oe.NO_INTERSECTION;
        var o2 = he.orientationIndex(n2, i3, t2), a2 = he.orientationIndex(n2, i3, e2);
        if (o2 > 0 && a2 > 0 || 0 > o2 && 0 > a2)
          return oe.NO_INTERSECTION;
        var u2 = 0 === r2 && 0 === s2 && 0 === o2 && 0 === a2;
        return u2 ? this.computeCollinearIntersection(t2, e2, n2, i3) : (0 === r2 || 0 === s2 || 0 === o2 || 0 === a2 ? (this._isProper = false, t2.equals2D(n2) || t2.equals2D(i3) ? this.intPt[0] = t2 : e2.equals2D(n2) || e2.equals2D(i3) ? this.intPt[0] = e2 : 0 === r2 ? this.intPt[0] = new g(n2) : 0 === s2 ? this.intPt[0] = new g(i3) : 0 === o2 ? this.intPt[0] = new g(t2) : 0 === a2 && (this.intPt[0] = new g(e2))) : (this._isProper = true, this.intPt[0] = this.intersection(t2, e2, n2, i3)), oe.POINT_INTERSECTION);
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return ae;
      } }), ae.nearestEndpoint = function(t2, e2, n2, i3) {
        var r2 = t2, s2 = he.distancePointLine(t2, n2, i3), o2 = he.distancePointLine(e2, n2, i3);
        return s2 > o2 && (s2 = o2, r2 = e2), o2 = he.distancePointLine(n2, t2, e2), s2 > o2 && (s2 = o2, r2 = n2), o2 = he.distancePointLine(i3, t2, e2), s2 > o2 && (s2 = o2, r2 = i3), r2;
      }, e(ue.prototype, { interfaces_: function() {
        return [];
      }, getClass: function() {
        return ue;
      } }), ue.orientationIndex = function(t2, e2, n2) {
        var i3 = e2.x - t2.x, r2 = e2.y - t2.y, s2 = n2.x - e2.x, o2 = n2.y - e2.y;
        return ue.signOfDet2x2(i3, r2, s2, o2);
      }, ue.signOfDet2x2 = function(t2, e2, n2, i3) {
        var r2 = null, s2 = null, o2 = null, a2 = 0;
        if (r2 = 1, 0 === t2 || 0 === i3)
          return 0 === e2 || 0 === n2 ? 0 : e2 > 0 ? n2 > 0 ? -r2 : r2 : n2 > 0 ? r2 : -r2;
        if (0 === e2 || 0 === n2)
          return i3 > 0 ? t2 > 0 ? r2 : -r2 : t2 > 0 ? -r2 : r2;
        if (e2 > 0 ? i3 > 0 ? i3 >= e2 || (r2 = -r2, s2 = t2, t2 = n2, n2 = s2, s2 = e2, e2 = i3, i3 = s2) : -i3 >= e2 ? (r2 = -r2, n2 = -n2, i3 = -i3) : (s2 = t2, t2 = -n2, n2 = s2, s2 = e2, e2 = -i3, i3 = s2) : i3 > 0 ? i3 >= -e2 ? (r2 = -r2, t2 = -t2, e2 = -e2) : (s2 = -t2, t2 = n2, n2 = s2, s2 = -e2, e2 = i3, i3 = s2) : e2 >= i3 ? (t2 = -t2, e2 = -e2, n2 = -n2, i3 = -i3) : (r2 = -r2, s2 = -t2, t2 = -n2, n2 = s2, s2 = -e2, e2 = -i3, i3 = s2), t2 > 0) {
          if (!(n2 > 0))
            return r2;
          if (!(n2 >= t2))
            return r2;
        } else {
          if (n2 > 0)
            return -r2;
          if (!(t2 >= n2))
            return -r2;
          r2 = -r2, t2 = -t2, n2 = -n2;
        }
        for (; ; ) {
          if (a2 += 1, o2 = Math.floor(n2 / t2), n2 -= o2 * t2, i3 -= o2 * e2, 0 > i3)
            return -r2;
          if (i3 > e2)
            return r2;
          if (t2 > n2 + n2) {
            if (i3 + i3 > e2)
              return r2;
          } else {
            if (e2 > i3 + i3)
              return -r2;
            n2 = t2 - n2, i3 = e2 - i3, r2 = -r2;
          }
          if (0 === i3)
            return 0 === n2 ? 0 : -r2;
          if (0 === n2)
            return r2;
          if (o2 = Math.floor(t2 / n2), t2 -= o2 * n2, e2 -= o2 * i3, 0 > e2)
            return r2;
          if (e2 > i3)
            return -r2;
          if (n2 > t2 + t2) {
            if (e2 + e2 > i3)
              return -r2;
          } else {
            if (i3 > e2 + e2)
              return r2;
            t2 = n2 - t2, e2 = i3 - e2, r2 = -r2;
          }
          if (0 === e2)
            return 0 === t2 ? 0 : r2;
          if (0 === t2)
            return -r2;
        }
      }, e(le.prototype, { countSegment: function(t2, e2) {
        if (t2.x < this.p.x && e2.x < this.p.x)
          return null;
        if (this.p.x === e2.x && this.p.y === e2.y)
          return this.isPointOnSegment = true, null;
        if (t2.y === this.p.y && e2.y === this.p.y) {
          var n2 = t2.x, i3 = e2.x;
          return n2 > i3 && (n2 = e2.x, i3 = t2.x), this.p.x >= n2 && this.p.x <= i3 && (this.isPointOnSegment = true), null;
        }
        if (t2.y > this.p.y && e2.y <= this.p.y || e2.y > this.p.y && t2.y <= this.p.y) {
          var r2 = t2.x - this.p.x, s2 = t2.y - this.p.y, o2 = e2.x - this.p.x, a2 = e2.y - this.p.y, u2 = ue.signOfDet2x2(r2, s2, o2, a2);
          if (0 === u2)
            return this.isPointOnSegment = true, null;
          s2 > a2 && (u2 = -u2), u2 > 0 && this.crossingCount++;
        }
      }, isPointInPolygon: function() {
        return this.getLocation() !== L.EXTERIOR;
      }, getLocation: function() {
        return this.isPointOnSegment ? L.BOUNDARY : this.crossingCount % 2 === 1 ? L.INTERIOR : L.EXTERIOR;
      }, isOnSegment: function() {
        return this.isPointOnSegment;
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return le;
      } }), le.locatePointInRing = function() {
        if (arguments[0] instanceof g && R(arguments[1], D)) {
          for (var t2 = arguments[0], e2 = arguments[1], n2 = new le(t2), i3 = new g(), r2 = new g(), s2 = 1; s2 < e2.size(); s2++)
            if (e2.getCoordinate(s2, i3), e2.getCoordinate(s2 - 1, r2), n2.countSegment(i3, r2), n2.isOnSegment())
              return n2.getLocation();
          return n2.getLocation();
        }
        if (arguments[0] instanceof g && arguments[1] instanceof Array) {
          for (var o2 = arguments[0], a2 = arguments[1], n2 = new le(o2), s2 = 1; s2 < a2.length; s2++) {
            var i3 = a2[s2], r2 = a2[s2 - 1];
            if (n2.countSegment(i3, r2), n2.isOnSegment())
              return n2.getLocation();
          }
          return n2.getLocation();
        }
      }, e(he.prototype, { interfaces_: function() {
        return [];
      }, getClass: function() {
        return he;
      } }), he.orientationIndex = function(t2, e2, n2) {
        return M.orientationIndex(t2, e2, n2);
      }, he.signedArea = function() {
        if (arguments[0] instanceof Array) {
          var t2 = arguments[0];
          if (t2.length < 3)
            return 0;
          for (var e2 = 0, n2 = t2[0].x, i3 = 1; i3 < t2.length - 1; i3++) {
            var r2 = t2[i3].x - n2, s2 = t2[i3 + 1].y, o2 = t2[i3 - 1].y;
            e2 += r2 * (o2 - s2);
          }
          return e2 / 2;
        }
        if (R(arguments[0], D)) {
          var a2 = arguments[0], u2 = a2.size();
          if (3 > u2)
            return 0;
          var l2 = new g(), h2 = new g(), c2 = new g();
          a2.getCoordinate(0, h2), a2.getCoordinate(1, c2);
          var n2 = h2.x;
          c2.x -= n2;
          for (var e2 = 0, i3 = 1; u2 - 1 > i3; i3++)
            l2.y = h2.y, h2.x = c2.x, h2.y = c2.y, a2.getCoordinate(i3 + 1, c2), c2.x -= n2, e2 += h2.x * (l2.y - c2.y);
          return e2 / 2;
        }
      }, he.distanceLineLine = function(t2, e2, n2, i3) {
        if (t2.equals(e2))
          return he.distancePointLine(t2, n2, i3);
        if (n2.equals(i3))
          return he.distancePointLine(i3, t2, e2);
        var r2 = false;
        if (C.intersects(t2, e2, n2, i3)) {
          var s2 = (e2.x - t2.x) * (i3.y - n2.y) - (e2.y - t2.y) * (i3.x - n2.x);
          if (0 === s2)
            r2 = true;
          else {
            var o2 = (t2.y - n2.y) * (i3.x - n2.x) - (t2.x - n2.x) * (i3.y - n2.y), a2 = (t2.y - n2.y) * (e2.x - t2.x) - (t2.x - n2.x) * (e2.y - t2.y), u2 = a2 / s2, l2 = o2 / s2;
            (0 > l2 || l2 > 1 || 0 > u2 || u2 > 1) && (r2 = true);
          }
        } else
          r2 = true;
        return r2 ? T.min(he.distancePointLine(t2, n2, i3), he.distancePointLine(e2, n2, i3), he.distancePointLine(n2, t2, e2), he.distancePointLine(i3, t2, e2)) : 0;
      }, he.isPointInRing = function(t2, e2) {
        return he.locatePointInRing(t2, e2) !== L.EXTERIOR;
      }, he.computeLength = function(t2) {
        var e2 = t2.size();
        if (1 >= e2)
          return 0;
        var n2 = 0, i3 = new g();
        t2.getCoordinate(0, i3);
        for (var r2 = i3.x, s2 = i3.y, o2 = 1; e2 > o2; o2++) {
          t2.getCoordinate(o2, i3);
          var a2 = i3.x, u2 = i3.y, l2 = a2 - r2, h2 = u2 - s2;
          n2 += Math.sqrt(l2 * l2 + h2 * h2), r2 = a2, s2 = u2;
        }
        return n2;
      }, he.isCCW = function(t2) {
        var e2 = t2.length - 1;
        if (3 > e2)
          throw new i2("Ring has fewer than 4 points, so orientation cannot be determined");
        for (var n2 = t2[0], r2 = 0, s2 = 1; e2 >= s2; s2++) {
          var o2 = t2[s2];
          o2.y > n2.y && (n2 = o2, r2 = s2);
        }
        var a2 = r2;
        do
          a2 -= 1, 0 > a2 && (a2 = e2);
        while (t2[a2].equals2D(n2) && a2 !== r2);
        var u2 = r2;
        do
          u2 = (u2 + 1) % e2;
        while (t2[u2].equals2D(n2) && u2 !== r2);
        var l2 = t2[a2], h2 = t2[u2];
        if (l2.equals2D(n2) || h2.equals2D(n2) || l2.equals2D(h2))
          return false;
        var c2 = he.computeOrientation(l2, n2, h2), f2 = false;
        return f2 = 0 === c2 ? l2.x > h2.x : c2 > 0;
      }, he.locatePointInRing = function(t2, e2) {
        return le.locatePointInRing(t2, e2);
      }, he.distancePointLinePerpendicular = function(t2, e2, n2) {
        var i3 = (n2.x - e2.x) * (n2.x - e2.x) + (n2.y - e2.y) * (n2.y - e2.y), r2 = ((e2.y - t2.y) * (n2.x - e2.x) - (e2.x - t2.x) * (n2.y - e2.y)) / i3;
        return Math.abs(r2) * Math.sqrt(i3);
      }, he.computeOrientation = function(t2, e2, n2) {
        return he.orientationIndex(t2, e2, n2);
      }, he.distancePointLine = function() {
        if (2 === arguments.length) {
          var t2 = arguments[0], e2 = arguments[1];
          if (0 === e2.length)
            throw new i2("Line array must contain at least one vertex");
          for (var n2 = t2.distance(e2[0]), r2 = 0; r2 < e2.length - 1; r2++) {
            var s2 = he.distancePointLine(t2, e2[r2], e2[r2 + 1]);
            n2 > s2 && (n2 = s2);
          }
          return n2;
        }
        if (3 === arguments.length) {
          var o2 = arguments[0], a2 = arguments[1], u2 = arguments[2];
          if (a2.x === u2.x && a2.y === u2.y)
            return o2.distance(a2);
          var l2 = (u2.x - a2.x) * (u2.x - a2.x) + (u2.y - a2.y) * (u2.y - a2.y), h2 = ((o2.x - a2.x) * (u2.x - a2.x) + (o2.y - a2.y) * (u2.y - a2.y)) / l2;
          if (0 >= h2)
            return o2.distance(a2);
          if (h2 >= 1)
            return o2.distance(u2);
          var c2 = ((a2.y - o2.y) * (u2.x - a2.x) - (a2.x - o2.x) * (u2.y - a2.y)) / l2;
          return Math.abs(c2) * Math.sqrt(l2);
        }
      }, he.isOnLine = function(t2, e2) {
        for (var n2 = new ae(), i3 = 1; i3 < e2.length; i3++) {
          var r2 = e2[i3 - 1], s2 = e2[i3];
          if (n2.computeIntersection(t2, r2, s2), n2.hasIntersection())
            return true;
        }
        return false;
      }, he.CLOCKWISE = -1, he.RIGHT = he.CLOCKWISE, he.COUNTERCLOCKWISE = 1, he.LEFT = he.COUNTERCLOCKWISE, he.COLLINEAR = 0, he.STRAIGHT = he.COLLINEAR, e(ce.prototype, { minX: function() {
        return Math.min(this.p0.x, this.p1.x);
      }, orientationIndex: function() {
        if (arguments[0] instanceof ce) {
          var t2 = arguments[0], e2 = he.orientationIndex(this.p0, this.p1, t2.p0), n2 = he.orientationIndex(this.p0, this.p1, t2.p1);
          return e2 >= 0 && n2 >= 0 ? Math.max(e2, n2) : 0 >= e2 && 0 >= n2 ? Math.max(e2, n2) : 0;
        }
        if (arguments[0] instanceof g) {
          var i3 = arguments[0];
          return he.orientationIndex(this.p0, this.p1, i3);
        }
      }, toGeometry: function(t2) {
        return t2.createLineString([this.p0, this.p1]);
      }, isVertical: function() {
        return this.p0.x === this.p1.x;
      }, equals: function(t2) {
        if (!(t2 instanceof ce))
          return false;
        var e2 = t2;
        return this.p0.equals(e2.p0) && this.p1.equals(e2.p1);
      }, intersection: function(t2) {
        var e2 = new ae();
        return e2.computeIntersection(this.p0, this.p1, t2.p0, t2.p1), e2.hasIntersection() ? e2.getIntersection(0) : null;
      }, project: function() {
        if (arguments[0] instanceof g) {
          var t2 = arguments[0];
          if (t2.equals(this.p0) || t2.equals(this.p1))
            return new g(t2);
          var e2 = this.projectionFactor(t2), n2 = new g();
          return n2.x = this.p0.x + e2 * (this.p1.x - this.p0.x), n2.y = this.p0.y + e2 * (this.p1.y - this.p0.y), n2;
        }
        if (arguments[0] instanceof ce) {
          var i3 = arguments[0], r2 = this.projectionFactor(i3.p0), s2 = this.projectionFactor(i3.p1);
          if (r2 >= 1 && s2 >= 1)
            return null;
          if (0 >= r2 && 0 >= s2)
            return null;
          var o2 = this.project(i3.p0);
          0 > r2 && (o2 = this.p0), r2 > 1 && (o2 = this.p1);
          var a2 = this.project(i3.p1);
          return 0 > s2 && (a2 = this.p0), s2 > 1 && (a2 = this.p1), new ce(o2, a2);
        }
      }, normalize: function() {
        this.p1.compareTo(this.p0) < 0 && this.reverse();
      }, angle: function() {
        return Math.atan2(this.p1.y - this.p0.y, this.p1.x - this.p0.x);
      }, getCoordinate: function(t2) {
        return 0 === t2 ? this.p0 : this.p1;
      }, distancePerpendicular: function(t2) {
        return he.distancePointLinePerpendicular(t2, this.p0, this.p1);
      }, minY: function() {
        return Math.min(this.p0.y, this.p1.y);
      }, midPoint: function() {
        return ce.midPoint(this.p0, this.p1);
      }, projectionFactor: function(t2) {
        if (t2.equals(this.p0))
          return 0;
        if (t2.equals(this.p1))
          return 1;
        var e2 = this.p1.x - this.p0.x, n2 = this.p1.y - this.p0.y, i3 = e2 * e2 + n2 * n2;
        if (0 >= i3)
          return r.NaN;
        var s2 = ((t2.x - this.p0.x) * e2 + (t2.y - this.p0.y) * n2) / i3;
        return s2;
      }, closestPoints: function(t2) {
        var e2 = this.intersection(t2);
        if (null !== e2)
          return [e2, e2];
        var n2 = new Array(2).fill(null), i3 = r.MAX_VALUE, s2 = null, o2 = this.closestPoint(t2.p0);
        i3 = o2.distance(t2.p0), n2[0] = o2, n2[1] = t2.p0;
        var a2 = this.closestPoint(t2.p1);
        s2 = a2.distance(t2.p1), i3 > s2 && (i3 = s2, n2[0] = a2, n2[1] = t2.p1);
        var u2 = t2.closestPoint(this.p0);
        s2 = u2.distance(this.p0), i3 > s2 && (i3 = s2, n2[0] = this.p0, n2[1] = u2);
        var l2 = t2.closestPoint(this.p1);
        return s2 = l2.distance(this.p1), i3 > s2 && (i3 = s2, n2[0] = this.p1, n2[1] = l2), n2;
      }, closestPoint: function(t2) {
        var e2 = this.projectionFactor(t2);
        if (e2 > 0 && 1 > e2)
          return this.project(t2);
        var n2 = this.p0.distance(t2), i3 = this.p1.distance(t2);
        return i3 > n2 ? this.p0 : this.p1;
      }, maxX: function() {
        return Math.max(this.p0.x, this.p1.x);
      }, getLength: function() {
        return this.p0.distance(this.p1);
      }, compareTo: function(t2) {
        var e2 = t2, n2 = this.p0.compareTo(e2.p0);
        return 0 !== n2 ? n2 : this.p1.compareTo(e2.p1);
      }, reverse: function() {
        var t2 = this.p0;
        this.p0 = this.p1, this.p1 = t2;
      }, equalsTopo: function(t2) {
        return this.p0.equals(t2.p0) && this.p1.equals(t2.p1) || this.p0.equals(t2.p1) && this.p1.equals(t2.p0);
      }, lineIntersection: function(t2) {
        try {
          var e2 = F.intersection(this.p0, this.p1, t2.p0, t2.p1);
          return e2;
        } catch (t3) {
          if (!(t3 instanceof w))
            throw t3;
        } finally {
        }
        return null;
      }, maxY: function() {
        return Math.max(this.p0.y, this.p1.y);
      }, pointAlongOffset: function(t2, e2) {
        var n2 = this.p0.x + t2 * (this.p1.x - this.p0.x), i3 = this.p0.y + t2 * (this.p1.y - this.p0.y), r2 = this.p1.x - this.p0.x, s2 = this.p1.y - this.p0.y, o2 = Math.sqrt(r2 * r2 + s2 * s2), a2 = 0, u2 = 0;
        if (0 !== e2) {
          if (0 >= o2)
            throw new IllegalStateException("Cannot compute offset from zero-length line segment");
          a2 = e2 * r2 / o2, u2 = e2 * s2 / o2;
        }
        var l2 = n2 - u2, h2 = i3 + a2, c2 = new g(l2, h2);
        return c2;
      }, setCoordinates: function() {
        if (1 === arguments.length) {
          var t2 = arguments[0];
          this.setCoordinates(t2.p0, t2.p1);
        } else if (2 === arguments.length) {
          var e2 = arguments[0], n2 = arguments[1];
          this.p0.x = e2.x, this.p0.y = e2.y, this.p1.x = n2.x, this.p1.y = n2.y;
        }
      }, segmentFraction: function(t2) {
        var e2 = this.projectionFactor(t2);
        return 0 > e2 ? e2 = 0 : (e2 > 1 || r.isNaN(e2)) && (e2 = 1), e2;
      }, toString: function() {
        return "LINESTRING( " + this.p0.x + " " + this.p0.y + ", " + this.p1.x + " " + this.p1.y + ")";
      }, isHorizontal: function() {
        return this.p0.y === this.p1.y;
      }, distance: function() {
        if (arguments[0] instanceof ce) {
          var t2 = arguments[0];
          return he.distanceLineLine(this.p0, this.p1, t2.p0, t2.p1);
        }
        if (arguments[0] instanceof g) {
          var e2 = arguments[0];
          return he.distancePointLine(e2, this.p0, this.p1);
        }
      }, pointAlong: function(t2) {
        var e2 = new g();
        return e2.x = this.p0.x + t2 * (this.p1.x - this.p0.x), e2.y = this.p0.y + t2 * (this.p1.y - this.p0.y), e2;
      }, hashCode: function() {
        var t2 = java.lang.Double.doubleToLongBits(this.p0.x);
        t2 ^= 31 * java.lang.Double.doubleToLongBits(this.p0.y);
        var e2 = Math.trunc(t2) ^ Math.trunc(t2 >> 32), n2 = java.lang.Double.doubleToLongBits(this.p1.x);
        n2 ^= 31 * java.lang.Double.doubleToLongBits(this.p1.y);
        var i3 = Math.trunc(n2) ^ Math.trunc(n2 >> 32);
        return e2 ^ i3;
      }, interfaces_: function() {
        return [s, u];
      }, getClass: function() {
        return ce;
      } }), ce.midPoint = function(t2, e2) {
        return new g((t2.x + e2.x) / 2, (t2.y + e2.y) / 2);
      }, ce.serialVersionUID = 3252005833466256400, e(fe.prototype, { isIntersects: function() {
        return !this.isDisjoint();
      }, isCovers: function() {
        var t2 = fe.isTrue(this.matrix[L.INTERIOR][L.INTERIOR]) || fe.isTrue(this.matrix[L.INTERIOR][L.BOUNDARY]) || fe.isTrue(this.matrix[L.BOUNDARY][L.INTERIOR]) || fe.isTrue(this.matrix[L.BOUNDARY][L.BOUNDARY]);
        return t2 && this.matrix[L.EXTERIOR][L.INTERIOR] === lt.FALSE && this.matrix[L.EXTERIOR][L.BOUNDARY] === lt.FALSE;
      }, isCoveredBy: function() {
        var t2 = fe.isTrue(this.matrix[L.INTERIOR][L.INTERIOR]) || fe.isTrue(this.matrix[L.INTERIOR][L.BOUNDARY]) || fe.isTrue(this.matrix[L.BOUNDARY][L.INTERIOR]) || fe.isTrue(this.matrix[L.BOUNDARY][L.BOUNDARY]);
        return t2 && this.matrix[L.INTERIOR][L.EXTERIOR] === lt.FALSE && this.matrix[L.BOUNDARY][L.EXTERIOR] === lt.FALSE;
      }, set: function() {
        if (1 === arguments.length)
          for (var t2 = arguments[0], e2 = 0; e2 < t2.length; e2++) {
            var n2 = Math.trunc(e2 / 3), i3 = e2 % 3;
            this.matrix[n2][i3] = lt.toDimensionValue(t2.charAt(e2));
          }
        else if (3 === arguments.length) {
          var r2 = arguments[0], s2 = arguments[1], o2 = arguments[2];
          this.matrix[r2][s2] = o2;
        }
      }, isContains: function() {
        return fe.isTrue(this.matrix[L.INTERIOR][L.INTERIOR]) && this.matrix[L.EXTERIOR][L.INTERIOR] === lt.FALSE && this.matrix[L.EXTERIOR][L.BOUNDARY] === lt.FALSE;
      }, setAtLeast: function() {
        if (1 === arguments.length)
          for (var t2 = arguments[0], e2 = 0; e2 < t2.length; e2++) {
            var n2 = Math.trunc(e2 / 3), i3 = e2 % 3;
            this.setAtLeast(n2, i3, lt.toDimensionValue(t2.charAt(e2)));
          }
        else if (3 === arguments.length) {
          var r2 = arguments[0], s2 = arguments[1], o2 = arguments[2];
          this.matrix[r2][s2] < o2 && (this.matrix[r2][s2] = o2);
        }
      }, setAtLeastIfValid: function(t2, e2, n2) {
        t2 >= 0 && e2 >= 0 && this.setAtLeast(t2, e2, n2);
      }, isWithin: function() {
        return fe.isTrue(this.matrix[L.INTERIOR][L.INTERIOR]) && this.matrix[L.INTERIOR][L.EXTERIOR] === lt.FALSE && this.matrix[L.BOUNDARY][L.EXTERIOR] === lt.FALSE;
      }, isTouches: function(t2, e2) {
        return t2 > e2 ? this.isTouches(e2, t2) : t2 === lt.A && e2 === lt.A || t2 === lt.L && e2 === lt.L || t2 === lt.L && e2 === lt.A || t2 === lt.P && e2 === lt.A || t2 === lt.P && e2 === lt.L ? this.matrix[L.INTERIOR][L.INTERIOR] === lt.FALSE && (fe.isTrue(this.matrix[L.INTERIOR][L.BOUNDARY]) || fe.isTrue(this.matrix[L.BOUNDARY][L.INTERIOR]) || fe.isTrue(this.matrix[L.BOUNDARY][L.BOUNDARY])) : false;
      }, isOverlaps: function(t2, e2) {
        return t2 === lt.P && e2 === lt.P || t2 === lt.A && e2 === lt.A ? fe.isTrue(this.matrix[L.INTERIOR][L.INTERIOR]) && fe.isTrue(this.matrix[L.INTERIOR][L.EXTERIOR]) && fe.isTrue(this.matrix[L.EXTERIOR][L.INTERIOR]) : t2 === lt.L && e2 === lt.L ? 1 === this.matrix[L.INTERIOR][L.INTERIOR] && fe.isTrue(this.matrix[L.INTERIOR][L.EXTERIOR]) && fe.isTrue(this.matrix[L.EXTERIOR][L.INTERIOR]) : false;
      }, isEquals: function(t2, e2) {
        return t2 !== e2 ? false : fe.isTrue(this.matrix[L.INTERIOR][L.INTERIOR]) && this.matrix[L.INTERIOR][L.EXTERIOR] === lt.FALSE && this.matrix[L.BOUNDARY][L.EXTERIOR] === lt.FALSE && this.matrix[L.EXTERIOR][L.INTERIOR] === lt.FALSE && this.matrix[L.EXTERIOR][L.BOUNDARY] === lt.FALSE;
      }, toString: function() {
        for (var t2 = new P("123456789"), e2 = 0; 3 > e2; e2++)
          for (var n2 = 0; 3 > n2; n2++)
            t2.setCharAt(3 * e2 + n2, lt.toDimensionSymbol(this.matrix[e2][n2]));
        return t2.toString();
      }, setAll: function(t2) {
        for (var e2 = 0; 3 > e2; e2++)
          for (var n2 = 0; 3 > n2; n2++)
            this.matrix[e2][n2] = t2;
      }, get: function(t2, e2) {
        return this.matrix[t2][e2];
      }, transpose: function() {
        var t2 = this.matrix[1][0];
        return this.matrix[1][0] = this.matrix[0][1], this.matrix[0][1] = t2, t2 = this.matrix[2][0], this.matrix[2][0] = this.matrix[0][2], this.matrix[0][2] = t2, t2 = this.matrix[2][1], this.matrix[2][1] = this.matrix[1][2], this.matrix[1][2] = t2, this;
      }, matches: function(t2) {
        if (9 !== t2.length)
          throw new i2("Should be length 9: " + t2);
        for (var e2 = 0; 3 > e2; e2++)
          for (var n2 = 0; 3 > n2; n2++)
            if (!fe.matches(this.matrix[e2][n2], t2.charAt(3 * e2 + n2)))
              return false;
        return true;
      }, add: function(t2) {
        for (var e2 = 0; 3 > e2; e2++)
          for (var n2 = 0; 3 > n2; n2++)
            this.setAtLeast(e2, n2, t2.get(e2, n2));
      }, isDisjoint: function() {
        return this.matrix[L.INTERIOR][L.INTERIOR] === lt.FALSE && this.matrix[L.INTERIOR][L.BOUNDARY] === lt.FALSE && this.matrix[L.BOUNDARY][L.INTERIOR] === lt.FALSE && this.matrix[L.BOUNDARY][L.BOUNDARY] === lt.FALSE;
      }, isCrosses: function(t2, e2) {
        return t2 === lt.P && e2 === lt.L || t2 === lt.P && e2 === lt.A || t2 === lt.L && e2 === lt.A ? fe.isTrue(this.matrix[L.INTERIOR][L.INTERIOR]) && fe.isTrue(this.matrix[L.INTERIOR][L.EXTERIOR]) : t2 === lt.L && e2 === lt.P || t2 === lt.A && e2 === lt.P || t2 === lt.A && e2 === lt.L ? fe.isTrue(this.matrix[L.INTERIOR][L.INTERIOR]) && fe.isTrue(this.matrix[L.EXTERIOR][L.INTERIOR]) : t2 === lt.L && e2 === lt.L ? 0 === this.matrix[L.INTERIOR][L.INTERIOR] : false;
      }, interfaces_: function() {
        return [o];
      }, getClass: function() {
        return fe;
      } }), fe.matches = function() {
        if (Number.isInteger(arguments[0]) && "string" == typeof arguments[1]) {
          var t2 = arguments[0], e2 = arguments[1];
          return e2 === lt.SYM_DONTCARE ? true : e2 === lt.SYM_TRUE && (t2 >= 0 || t2 === lt.TRUE) ? true : e2 === lt.SYM_FALSE && t2 === lt.FALSE ? true : e2 === lt.SYM_P && t2 === lt.P ? true : e2 === lt.SYM_L && t2 === lt.L ? true : e2 === lt.SYM_A && t2 === lt.A;
        }
        if ("string" == typeof arguments[0] && "string" == typeof arguments[1]) {
          var n2 = arguments[0], i3 = arguments[1], r2 = new fe(n2);
          return r2.matches(i3);
        }
      }, fe.isTrue = function(t2) {
        return t2 >= 0 || t2 === lt.TRUE;
      };
      var lo = Object.freeze({ Coordinate: g, CoordinateList: N, Envelope: C, LineSegment: ce, GeometryFactory: ie, Geometry: B, Point: Lt, LineString: St, LinearRing: bt, Polygon: Tt, GeometryCollection: ft, MultiPoint: Pt, MultiLineString: gt, MultiPolygon: Ot, Dimension: lt, IntersectionMatrix: fe });
      e(ge.prototype, { addPoint: function(t2) {
        this.ptCount += 1, this.ptCentSum.x += t2.x, this.ptCentSum.y += t2.y;
      }, setBasePoint: function(t2) {
        null === this.areaBasePt && (this.areaBasePt = t2);
      }, addLineSegments: function(t2) {
        for (var e2 = 0, n2 = 0; n2 < t2.length - 1; n2++) {
          var i3 = t2[n2].distance(t2[n2 + 1]);
          if (0 !== i3) {
            e2 += i3;
            var r2 = (t2[n2].x + t2[n2 + 1].x) / 2;
            this.lineCentSum.x += i3 * r2;
            var s2 = (t2[n2].y + t2[n2 + 1].y) / 2;
            this.lineCentSum.y += i3 * s2;
          }
        }
        this.totalLength += e2, 0 === e2 && t2.length > 0 && this.addPoint(t2[0]);
      }, addHole: function(t2) {
        for (var e2 = he.isCCW(t2), n2 = 0; n2 < t2.length - 1; n2++)
          this.addTriangle(this.areaBasePt, t2[n2], t2[n2 + 1], e2);
        this.addLineSegments(t2);
      }, getCentroid: function() {
        var t2 = new g();
        if (Math.abs(this.areasum2) > 0)
          t2.x = this.cg3.x / 3 / this.areasum2, t2.y = this.cg3.y / 3 / this.areasum2;
        else if (this.totalLength > 0)
          t2.x = this.lineCentSum.x / this.totalLength, t2.y = this.lineCentSum.y / this.totalLength;
        else {
          if (!(this.ptCount > 0))
            return null;
          t2.x = this.ptCentSum.x / this.ptCount, t2.y = this.ptCentSum.y / this.ptCount;
        }
        return t2;
      }, addShell: function(t2) {
        t2.length > 0 && this.setBasePoint(t2[0]);
        for (var e2 = !he.isCCW(t2), n2 = 0; n2 < t2.length - 1; n2++)
          this.addTriangle(this.areaBasePt, t2[n2], t2[n2 + 1], e2);
        this.addLineSegments(t2);
      }, addTriangle: function(t2, e2, n2, i3) {
        var r2 = i3 ? 1 : -1;
        ge.centroid3(t2, e2, n2, this.triangleCent3);
        var s2 = ge.area2(t2, e2, n2);
        this.cg3.x += r2 * s2 * this.triangleCent3.x, this.cg3.y += r2 * s2 * this.triangleCent3.y, this.areasum2 += r2 * s2;
      }, add: function() {
        if (arguments[0] instanceof Tt) {
          var t2 = arguments[0];
          this.addShell(t2.getExteriorRing().getCoordinates());
          for (var e2 = 0; e2 < t2.getNumInteriorRing(); e2++)
            this.addHole(t2.getInteriorRingN(e2).getCoordinates());
        } else if (arguments[0] instanceof B) {
          var n2 = arguments[0];
          if (n2.isEmpty())
            return null;
          if (n2 instanceof Lt)
            this.addPoint(n2.getCoordinate());
          else if (n2 instanceof St)
            this.addLineSegments(n2.getCoordinates());
          else if (n2 instanceof Tt) {
            var i3 = n2;
            this.add(i3);
          } else if (n2 instanceof ft)
            for (var r2 = n2, e2 = 0; e2 < r2.getNumGeometries(); e2++)
              this.add(r2.getGeometryN(e2));
        }
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return ge;
      } }), ge.area2 = function(t2, e2, n2) {
        return (e2.x - t2.x) * (n2.y - t2.y) - (n2.x - t2.x) * (e2.y - t2.y);
      }, ge.centroid3 = function(t2, e2, n2, i3) {
        return i3.x = t2.x + e2.x + n2.x, i3.y = t2.y + e2.y + n2.y, null;
      }, ge.getCentroid = function(t2) {
        var e2 = new ge(t2);
        return e2.getCentroid();
      }, de.prototype = new Error(), de.prototype.name = "EmptyStackException", pe.prototype = new y(), pe.prototype.add = function(t2) {
        return this.array_.push(t2), true;
      }, pe.prototype.get = function(t2) {
        if (0 > t2 || t2 >= this.size())
          throw new IndexOutOfBoundsException();
        return this.array_[t2];
      }, pe.prototype.push = function(t2) {
        return this.array_.push(t2), t2;
      }, pe.prototype.pop = function(t2) {
        if (0 === this.array_.length)
          throw new de();
        return this.array_.pop();
      }, pe.prototype.peek = function() {
        if (0 === this.array_.length)
          throw new de();
        return this.array_[this.array_.length - 1];
      }, pe.prototype.empty = function() {
        return 0 === this.array_.length;
      }, pe.prototype.isEmpty = function() {
        return this.empty();
      }, pe.prototype.search = function(t2) {
        return this.array_.indexOf(t2);
      }, pe.prototype.size = function() {
        return this.array_.length;
      }, pe.prototype.toArray = function() {
        for (var t2 = [], e2 = 0, n2 = this.array_.length; n2 > e2; e2++)
          t2.push(this.array_[e2]);
        return t2;
      }, e(ve.prototype, { filter: function(t2) {
        this.treeSet.contains(t2) || (this.list.add(t2), this.treeSet.add(t2));
      }, getCoordinates: function() {
        var t2 = new Array(this.list.size()).fill(null);
        return this.list.toArray(t2);
      }, interfaces_: function() {
        return [z];
      }, getClass: function() {
        return ve;
      } }), ve.filterCoordinates = function(t2) {
        for (var e2 = new ve(), n2 = 0; n2 < t2.length; n2++)
          e2.filter(t2[n2]);
        return e2.getCoordinates();
      }, e(me.prototype, { preSort: function(t2) {
        for (var e2 = null, n2 = 1; n2 < t2.length; n2++)
          (t2[n2].y < t2[0].y || t2[n2].y === t2[0].y && t2[n2].x < t2[0].x) && (e2 = t2[0], t2[0] = t2[n2], t2[n2] = e2);
        return ut.sort(t2, 1, t2.length, new ye(t2[0])), t2;
      }, computeOctRing: function(t2) {
        var e2 = this.computeOctPts(t2), n2 = new N();
        return n2.add(e2, false), n2.size() < 3 ? null : (n2.closeRing(), n2.toCoordinateArray());
      }, lineOrPolygon: function(t2) {
        if (t2 = this.cleanRing(t2), 3 === t2.length)
          return this.geomFactory.createLineString([t2[0], t2[1]]);
        var e2 = this.geomFactory.createLinearRing(t2);
        return this.geomFactory.createPolygon(e2, null);
      }, cleanRing: function(t2) {
        f.equals(t2[0], t2[t2.length - 1]);
        for (var e2 = new I(), n2 = null, i3 = 0; i3 <= t2.length - 2; i3++) {
          var r2 = t2[i3], s2 = t2[i3 + 1];
          r2.equals(s2) || null !== n2 && this.isBetween(n2, r2, s2) || (e2.add(r2), n2 = r2);
        }
        e2.add(t2[t2.length - 1]);
        var o2 = new Array(e2.size()).fill(null);
        return e2.toArray(o2);
      }, isBetween: function(t2, e2, n2) {
        if (0 !== he.computeOrientation(t2, e2, n2))
          return false;
        if (t2.x !== n2.x) {
          if (t2.x <= e2.x && e2.x <= n2.x)
            return true;
          if (n2.x <= e2.x && e2.x <= t2.x)
            return true;
        }
        if (t2.y !== n2.y) {
          if (t2.y <= e2.y && e2.y <= n2.y)
            return true;
          if (n2.y <= e2.y && e2.y <= t2.y)
            return true;
        }
        return false;
      }, reduce: function(t2) {
        var e2 = this.computeOctRing(t2);
        if (null === e2)
          return t2;
        for (var n2 = new at(), i3 = 0; i3 < e2.length; i3++)
          n2.add(e2[i3]);
        for (var i3 = 0; i3 < t2.length; i3++)
          he.isPointInRing(t2[i3], e2) || n2.add(t2[i3]);
        var r2 = H.toCoordinateArray(n2);
        return r2.length < 3 ? this.padArray3(r2) : r2;
      }, getConvexHull: function() {
        if (0 === this.inputPts.length)
          return this.geomFactory.createGeometryCollection(null);
        if (1 === this.inputPts.length)
          return this.geomFactory.createPoint(this.inputPts[0]);
        if (2 === this.inputPts.length)
          return this.geomFactory.createLineString(this.inputPts);
        var t2 = this.inputPts;
        this.inputPts.length > 50 && (t2 = this.reduce(this.inputPts));
        var e2 = this.preSort(t2), n2 = this.grahamScan(e2), i3 = this.toCoordinateArray(n2);
        return this.lineOrPolygon(i3);
      }, padArray3: function(t2) {
        for (var e2 = new Array(3).fill(null), n2 = 0; n2 < e2.length; n2++)
          n2 < t2.length ? e2[n2] = t2[n2] : e2[n2] = t2[0];
        return e2;
      }, computeOctPts: function(t2) {
        for (var e2 = new Array(8).fill(null), n2 = 0; n2 < e2.length; n2++)
          e2[n2] = t2[0];
        for (var i3 = 1; i3 < t2.length; i3++)
          t2[i3].x < e2[0].x && (e2[0] = t2[i3]), t2[i3].x - t2[i3].y < e2[1].x - e2[1].y && (e2[1] = t2[i3]), t2[i3].y > e2[2].y && (e2[2] = t2[i3]), t2[i3].x + t2[i3].y > e2[3].x + e2[3].y && (e2[3] = t2[i3]), t2[i3].x > e2[4].x && (e2[4] = t2[i3]), t2[i3].x - t2[i3].y > e2[5].x - e2[5].y && (e2[5] = t2[i3]), t2[i3].y < e2[6].y && (e2[6] = t2[i3]), t2[i3].x + t2[i3].y < e2[7].x + e2[7].y && (e2[7] = t2[i3]);
        return e2;
      }, toCoordinateArray: function(t2) {
        for (var e2 = new Array(t2.size()).fill(null), n2 = 0; n2 < t2.size(); n2++) {
          var i3 = t2.get(n2);
          e2[n2] = i3;
        }
        return e2;
      }, grahamScan: function(t2) {
        var e2 = null, n2 = new pe();
        e2 = n2.push(t2[0]), e2 = n2.push(t2[1]), e2 = n2.push(t2[2]);
        for (var i3 = 3; i3 < t2.length; i3++) {
          for (e2 = n2.pop(); !n2.empty() && he.computeOrientation(n2.peek(), e2, t2[i3]) > 0; )
            e2 = n2.pop();
          e2 = n2.push(e2), e2 = n2.push(t2[i3]);
        }
        return e2 = n2.push(t2[0]), n2;
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return me;
      } }), me.extractCoordinates = function(t2) {
        var e2 = new ve();
        return t2.apply(e2), e2.getCoordinates();
      }, e(ye.prototype, { compare: function(t2, e2) {
        var n2 = t2, i3 = e2;
        return ye.polarCompare(this.origin, n2, i3);
      }, interfaces_: function() {
        return [a];
      }, getClass: function() {
        return ye;
      } }), ye.polarCompare = function(t2, e2, n2) {
        var i3 = e2.x - t2.x, r2 = e2.y - t2.y, s2 = n2.x - t2.x, o2 = n2.y - t2.y, a2 = he.computeOrientation(t2, e2, n2);
        if (a2 === he.COUNTERCLOCKWISE)
          return 1;
        if (a2 === he.CLOCKWISE)
          return -1;
        var u2 = i3 * i3 + r2 * r2, l2 = s2 * s2 + o2 * o2;
        return l2 > u2 ? -1 : u2 > l2 ? 1 : 0;
      }, me.RadialComparator = ye, e(xe.prototype, { transformPoint: function(t2, e2) {
        return this.factory.createPoint(this.transformCoordinates(t2.getCoordinateSequence(), t2));
      }, transformPolygon: function(t2, e2) {
        var n2 = true, i3 = this.transformLinearRing(t2.getExteriorRing(), t2);
        null !== i3 && i3 instanceof bt && !i3.isEmpty() || (n2 = false);
        for (var r2 = new I(), s2 = 0; s2 < t2.getNumInteriorRing(); s2++) {
          var o2 = this.transformLinearRing(t2.getInteriorRingN(s2), t2);
          null === o2 || o2.isEmpty() || (o2 instanceof bt || (n2 = false), r2.add(o2));
        }
        if (n2)
          return this.factory.createPolygon(i3, r2.toArray([]));
        var a2 = new I();
        return null !== i3 && a2.add(i3), a2.addAll(r2), this.factory.buildGeometry(a2);
      }, createCoordinateSequence: function(t2) {
        return this.factory.getCoordinateSequenceFactory().create(t2);
      }, getInputGeometry: function() {
        return this.inputGeom;
      }, transformMultiLineString: function(t2, e2) {
        for (var n2 = new I(), i3 = 0; i3 < t2.getNumGeometries(); i3++) {
          var r2 = this.transformLineString(t2.getGeometryN(i3), t2);
          null !== r2 && (r2.isEmpty() || n2.add(r2));
        }
        return this.factory.buildGeometry(n2);
      }, transformCoordinates: function(t2, e2) {
        return this.copy(t2);
      }, transformLineString: function(t2, e2) {
        return this.factory.createLineString(this.transformCoordinates(t2.getCoordinateSequence(), t2));
      }, transformMultiPoint: function(t2, e2) {
        for (var n2 = new I(), i3 = 0; i3 < t2.getNumGeometries(); i3++) {
          var r2 = this.transformPoint(t2.getGeometryN(i3), t2);
          null !== r2 && (r2.isEmpty() || n2.add(r2));
        }
        return this.factory.buildGeometry(n2);
      }, transformMultiPolygon: function(t2, e2) {
        for (var n2 = new I(), i3 = 0; i3 < t2.getNumGeometries(); i3++) {
          var r2 = this.transformPolygon(t2.getGeometryN(i3), t2);
          null !== r2 && (r2.isEmpty() || n2.add(r2));
        }
        return this.factory.buildGeometry(n2);
      }, copy: function(t2) {
        return t2.copy();
      }, transformGeometryCollection: function(t2, e2) {
        for (var n2 = new I(), i3 = 0; i3 < t2.getNumGeometries(); i3++) {
          var r2 = this.transform(t2.getGeometryN(i3));
          null !== r2 && (this.pruneEmptyGeometry && r2.isEmpty() || n2.add(r2));
        }
        return this.preserveGeometryCollectionType ? this.factory.createGeometryCollection(ie.toGeometryArray(n2)) : this.factory.buildGeometry(n2);
      }, transform: function(t2) {
        if (this.inputGeom = t2, this.factory = t2.getFactory(), t2 instanceof Lt)
          return this.transformPoint(t2, null);
        if (t2 instanceof Pt)
          return this.transformMultiPoint(t2, null);
        if (t2 instanceof bt)
          return this.transformLinearRing(t2, null);
        if (t2 instanceof St)
          return this.transformLineString(t2, null);
        if (t2 instanceof gt)
          return this.transformMultiLineString(t2, null);
        if (t2 instanceof Tt)
          return this.transformPolygon(t2, null);
        if (t2 instanceof Ot)
          return this.transformMultiPolygon(t2, null);
        if (t2 instanceof ft)
          return this.transformGeometryCollection(t2, null);
        throw new i2("Unknown Geometry subtype: " + t2.getClass().getName());
      }, transformLinearRing: function(t2, e2) {
        var n2 = this.transformCoordinates(t2.getCoordinateSequence(), t2);
        if (null === n2)
          return this.factory.createLinearRing(null);
        var i3 = n2.size();
        return i3 > 0 && 4 > i3 && !this.preserveType ? this.factory.createLineString(n2) : this.factory.createLinearRing(n2);
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return xe;
      } }), e(Ee.prototype, { snapVertices: function(t2, e2) {
        for (var n2 = this._isClosed ? t2.size() - 1 : t2.size(), i3 = 0; n2 > i3; i3++) {
          var r2 = t2.get(i3), s2 = this.findSnapForVertex(r2, e2);
          null !== s2 && (t2.set(i3, new g(s2)), 0 === i3 && this._isClosed && t2.set(t2.size() - 1, new g(s2)));
        }
      }, findSnapForVertex: function(t2, e2) {
        for (var n2 = 0; n2 < e2.length; n2++) {
          if (t2.equals2D(e2[n2]))
            return null;
          if (t2.distance(e2[n2]) < this.snapTolerance)
            return e2[n2];
        }
        return null;
      }, snapTo: function(t2) {
        var e2 = new N(this.srcPts);
        this.snapVertices(e2, t2), this.snapSegments(e2, t2);
        var n2 = e2.toCoordinateArray();
        return n2;
      }, snapSegments: function(t2, e2) {
        if (0 === e2.length)
          return null;
        var n2 = e2.length;
        e2[0].equals2D(e2[e2.length - 1]) && (n2 = e2.length - 1);
        for (var i3 = 0; n2 > i3; i3++) {
          var r2 = e2[i3], s2 = this.findSegmentIndexToSnap(r2, t2);
          s2 >= 0 && t2.add(s2 + 1, new g(r2), false);
        }
      }, findSegmentIndexToSnap: function(t2, e2) {
        for (var n2 = r.MAX_VALUE, i3 = -1, s2 = 0; s2 < e2.size() - 1; s2++) {
          if (this.seg.p0 = e2.get(s2), this.seg.p1 = e2.get(s2 + 1), this.seg.p0.equals2D(t2) || this.seg.p1.equals2D(t2)) {
            if (this.allowSnappingToSourceVertices)
              continue;
            return -1;
          }
          var o2 = this.seg.distance(t2);
          o2 < this.snapTolerance && n2 > o2 && (n2 = o2, i3 = s2);
        }
        return i3;
      }, setAllowSnappingToSourceVertices: function(t2) {
        this.allowSnappingToSourceVertices = t2;
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return Ee;
      } }), Ee.isClosed = function(t2) {
        return t2.length <= 1 ? false : t2[0].equals2D(t2[t2.length - 1]);
      }, e(Ie.prototype, { snapTo: function(t2, e2) {
        var n2 = this.extractTargetCoordinates(t2), i3 = new Ne(e2, n2);
        return i3.transform(this.srcGeom);
      }, snapToSelf: function(t2, e2) {
        var n2 = this.extractTargetCoordinates(this.srcGeom), i3 = new Ne(t2, n2, true), r2 = i3.transform(this.srcGeom), s2 = r2;
        return e2 && R(s2, Rt) && (s2 = r2.buffer(0)), s2;
      }, computeSnapTolerance: function(t2) {
        var e2 = this.computeMinimumSegmentLength(t2), n2 = e2 / 10;
        return n2;
      }, extractTargetCoordinates: function(t2) {
        for (var e2 = new at(), n2 = t2.getCoordinates(), i3 = 0; i3 < n2.length; i3++)
          e2.add(n2[i3]);
        return e2.toArray(new Array(0).fill(null));
      }, computeMinimumSegmentLength: function(t2) {
        for (var e2 = r.MAX_VALUE, n2 = 0; n2 < t2.length - 1; n2++) {
          var i3 = t2[n2].distance(t2[n2 + 1]);
          e2 > i3 && (e2 = i3);
        }
        return e2;
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return Ie;
      } }), Ie.snap = function(t2, e2, n2) {
        var i3 = new Array(2).fill(null), r2 = new Ie(t2);
        i3[0] = r2.snapTo(e2, n2);
        var s2 = new Ie(e2);
        return i3[1] = s2.snapTo(i3[0], n2), i3;
      }, Ie.computeOverlaySnapTolerance = function() {
        if (1 === arguments.length) {
          var t2 = arguments[0], e2 = Ie.computeSizeBasedSnapTolerance(t2), n2 = t2.getPrecisionModel();
          if (n2.getType() === ee.FIXED) {
            var i3 = 1 / n2.getScale() * 2 / 1.415;
            i3 > e2 && (e2 = i3);
          }
          return e2;
        }
        if (2 === arguments.length) {
          var r2 = arguments[0], s2 = arguments[1];
          return Math.min(Ie.computeOverlaySnapTolerance(r2), Ie.computeOverlaySnapTolerance(s2));
        }
      }, Ie.computeSizeBasedSnapTolerance = function(t2) {
        var e2 = t2.getEnvelopeInternal(), n2 = Math.min(e2.getHeight(), e2.getWidth()), i3 = n2 * Ie.SNAP_PRECISION_FACTOR;
        return i3;
      }, Ie.snapToSelf = function(t2, e2, n2) {
        var i3 = new Ie(t2);
        return i3.snapToSelf(e2, n2);
      }, Ie.SNAP_PRECISION_FACTOR = 1e-9, h(Ne, xe), e(Ne.prototype, { snapLine: function(t2, e2) {
        var n2 = new Ee(t2, this.snapTolerance);
        return n2.setAllowSnappingToSourceVertices(this.isSelfSnap), n2.snapTo(e2);
      }, transformCoordinates: function(t2, e2) {
        var n2 = t2.toCoordinateArray(), i3 = this.snapLine(n2, this.snapPts);
        return this.factory.getCoordinateSequenceFactory().create(i3);
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return Ne;
      } }), e(Ce.prototype, { getCommon: function() {
        return r.longBitsToDouble(this.commonBits);
      }, add: function(t2) {
        var e2 = r.doubleToLongBits(t2);
        if (this.isFirst)
          return this.commonBits = e2, this.commonSignExp = Ce.signExpBits(this.commonBits), this.isFirst = false, null;
        var n2 = Ce.signExpBits(e2);
        return n2 !== this.commonSignExp ? (this.commonBits = 0, null) : (this.commonMantissaBitsCount = Ce.numCommonMostSigMantissaBits(this.commonBits, e2), void (this.commonBits = Ce.zeroLowerBits(this.commonBits, 64 - (12 + this.commonMantissaBitsCount))));
      }, toString: function() {
        if (1 === arguments.length) {
          var t2 = arguments[0], e2 = r.longBitsToDouble(t2), n2 = Long.toBinaryString(t2), i3 = "0000000000000000000000000000000000000000000000000000000000000000" + n2, s2 = i3.substring(i3.length - 64), o2 = s2.substring(0, 1) + "  " + s2.substring(1, 12) + "(exp) " + s2.substring(12) + " [ " + e2 + " ]";
          return o2;
        }
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return Ce;
      } }), Ce.getBit = function(t2, e2) {
        var n2 = 1 << e2;
        return 0 !== (t2 & n2) ? 1 : 0;
      }, Ce.signExpBits = function(t2) {
        return t2 >> 52;
      }, Ce.zeroLowerBits = function(t2, e2) {
        var n2 = (1 << e2) - 1, i3 = ~n2, r2 = t2 & i3;
        return r2;
      }, Ce.numCommonMostSigMantissaBits = function(t2, e2) {
        for (var n2 = 0, i3 = 52; i3 >= 0; i3--) {
          if (Ce.getBit(t2, i3) !== Ce.getBit(e2, i3))
            return n2;
          n2++;
        }
        return 52;
      }, e(Se.prototype, { addCommonBits: function(t2) {
        var e2 = new Le(this.commonCoord);
        t2.apply(e2), t2.geometryChanged();
      }, removeCommonBits: function(t2) {
        if (0 === this.commonCoord.x && 0 === this.commonCoord.y)
          return t2;
        var e2 = new g(this.commonCoord);
        e2.x = -e2.x, e2.y = -e2.y;
        var n2 = new Le(e2);
        return t2.apply(n2), t2.geometryChanged(), t2;
      }, getCommonCoordinate: function() {
        return this.commonCoord;
      }, add: function(t2) {
        t2.apply(this.ccFilter), this.commonCoord = this.ccFilter.getCommonCoordinate();
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return Se;
      } }), e(we.prototype, { filter: function(t2) {
        this.commonBitsX.add(t2.x), this.commonBitsY.add(t2.y);
      }, getCommonCoordinate: function() {
        return new g(this.commonBitsX.getCommon(), this.commonBitsY.getCommon());
      }, interfaces_: function() {
        return [z];
      }, getClass: function() {
        return we;
      } }), e(Le.prototype, { filter: function(t2, e2) {
        var n2 = t2.getOrdinate(e2, 0) + this.trans.x, i3 = t2.getOrdinate(e2, 1) + this.trans.y;
        t2.setOrdinate(e2, 0, n2), t2.setOrdinate(e2, 1, i3);
      }, isDone: function() {
        return false;
      }, isGeometryChanged: function() {
        return true;
      }, interfaces_: function() {
        return [ct];
      }, getClass: function() {
        return Le;
      } }), Se.CommonCoordinateFilter = we, Se.Translater = Le, e(Re.prototype, { next: function() {
        if (this.atStart)
          return this.atStart = false, Re.isAtomic(this.parent) && this.index++, this.parent;
        if (null !== this.subcollectionIterator) {
          if (this.subcollectionIterator.hasNext())
            return this.subcollectionIterator.next();
          this.subcollectionIterator = null;
        }
        if (this.index >= this.max)
          throw new x();
        var t2 = this.parent.getGeometryN(this.index++);
        return t2 instanceof ft ? (this.subcollectionIterator = new Re(t2), this.subcollectionIterator.next()) : t2;
      }, remove: function() {
        throw new UnsupportedOperationException(this.getClass().getName());
      }, hasNext: function() {
        if (this.atStart)
          return true;
        if (null !== this.subcollectionIterator) {
          if (this.subcollectionIterator.hasNext())
            return true;
          this.subcollectionIterator = null;
        }
        return !(this.index >= this.max);
      }, interfaces_: function() {
        return [p];
      }, getClass: function() {
        return Re;
      } }), Re.isAtomic = function(t2) {
        return !(t2 instanceof ft);
      }, e(Te.prototype, { locateInternal: function() {
        if (arguments[0] instanceof g && arguments[1] instanceof Tt) {
          var t2 = arguments[0], e2 = arguments[1];
          if (e2.isEmpty())
            return L.EXTERIOR;
          var n2 = e2.getExteriorRing(), i3 = this.locateInPolygonRing(t2, n2);
          if (i3 === L.EXTERIOR)
            return L.EXTERIOR;
          if (i3 === L.BOUNDARY)
            return L.BOUNDARY;
          for (var r2 = 0; r2 < e2.getNumInteriorRing(); r2++) {
            var s2 = e2.getInteriorRingN(r2), o2 = this.locateInPolygonRing(t2, s2);
            if (o2 === L.INTERIOR)
              return L.EXTERIOR;
            if (o2 === L.BOUNDARY)
              return L.BOUNDARY;
          }
          return L.INTERIOR;
        }
        if (arguments[0] instanceof g && arguments[1] instanceof St) {
          var a2 = arguments[0], u2 = arguments[1];
          if (!u2.getEnvelopeInternal().intersects(a2))
            return L.EXTERIOR;
          var l2 = u2.getCoordinates();
          return u2.isClosed() || !a2.equals(l2[0]) && !a2.equals(l2[l2.length - 1]) ? he.isOnLine(a2, l2) ? L.INTERIOR : L.EXTERIOR : L.BOUNDARY;
        }
        if (arguments[0] instanceof g && arguments[1] instanceof Lt) {
          var h2 = arguments[0], c2 = arguments[1], f2 = c2.getCoordinate();
          return f2.equals2D(h2) ? L.INTERIOR : L.EXTERIOR;
        }
      }, locateInPolygonRing: function(t2, e2) {
        return e2.getEnvelopeInternal().intersects(t2) ? he.locatePointInRing(t2, e2.getCoordinates()) : L.EXTERIOR;
      }, intersects: function(t2, e2) {
        return this.locate(t2, e2) !== L.EXTERIOR;
      }, updateLocationInfo: function(t2) {
        t2 === L.INTERIOR && (this.isIn = true), t2 === L.BOUNDARY && this.numBoundaries++;
      }, computeLocation: function(t2, e2) {
        if (e2 instanceof Lt && this.updateLocationInfo(this.locateInternal(t2, e2)), e2 instanceof St)
          this.updateLocationInfo(this.locateInternal(t2, e2));
        else if (e2 instanceof Tt)
          this.updateLocationInfo(this.locateInternal(t2, e2));
        else if (e2 instanceof gt)
          for (var n2 = e2, i3 = 0; i3 < n2.getNumGeometries(); i3++) {
            var r2 = n2.getGeometryN(i3);
            this.updateLocationInfo(this.locateInternal(t2, r2));
          }
        else if (e2 instanceof Ot)
          for (var s2 = e2, i3 = 0; i3 < s2.getNumGeometries(); i3++) {
            var o2 = s2.getGeometryN(i3);
            this.updateLocationInfo(this.locateInternal(t2, o2));
          }
        else if (e2 instanceof ft)
          for (var a2 = new Re(e2); a2.hasNext(); ) {
            var u2 = a2.next();
            u2 !== e2 && this.computeLocation(t2, u2);
          }
      }, locate: function(t2, e2) {
        return e2.isEmpty() ? L.EXTERIOR : e2 instanceof St ? this.locateInternal(t2, e2) : e2 instanceof Tt ? this.locateInternal(t2, e2) : (this.isIn = false, this.numBoundaries = 0, this.computeLocation(t2, e2), this.boundaryRule.isInBoundary(this.numBoundaries) ? L.BOUNDARY : this.numBoundaries > 0 || this.isIn ? L.INTERIOR : L.EXTERIOR);
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return Te;
      } }), e(Pe.prototype, { interfaces_: function() {
        return [];
      }, getClass: function() {
        return Pe;
      } }), Pe.octant = function() {
        if ("number" == typeof arguments[0] && "number" == typeof arguments[1]) {
          var t2 = arguments[0], e2 = arguments[1];
          if (0 === t2 && 0 === e2)
            throw new i2("Cannot compute the octant for point ( " + t2 + ", " + e2 + " )");
          var n2 = Math.abs(t2), r2 = Math.abs(e2);
          return t2 >= 0 ? e2 >= 0 ? n2 >= r2 ? 0 : 1 : n2 >= r2 ? 7 : 6 : e2 >= 0 ? n2 >= r2 ? 3 : 2 : n2 >= r2 ? 4 : 5;
        }
        if (arguments[0] instanceof g && arguments[1] instanceof g) {
          var s2 = arguments[0], o2 = arguments[1], a2 = o2.x - s2.x, u2 = o2.y - s2.y;
          if (0 === a2 && 0 === u2)
            throw new i2("Cannot compute the octant for two identical points " + s2);
          return Pe.octant(a2, u2);
        }
      }, e(be.prototype, { getCoordinates: function() {
      }, size: function() {
      }, getCoordinate: function(t2) {
      }, isClosed: function() {
      }, setData: function(t2) {
      }, getData: function() {
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return be;
      } }), e(Oe.prototype, { getCoordinates: function() {
        return this.pts;
      }, size: function() {
        return this.pts.length;
      }, getCoordinate: function(t2) {
        return this.pts[t2];
      }, isClosed: function() {
        return this.pts[0].equals(this.pts[this.pts.length - 1]);
      }, getSegmentOctant: function(t2) {
        return t2 === this.pts.length - 1 ? -1 : Pe.octant(this.getCoordinate(t2), this.getCoordinate(t2 + 1));
      }, setData: function(t2) {
        this.data = t2;
      }, getData: function() {
        return this.data;
      }, toString: function() {
        return se.toLineString(new Gt(this.pts));
      }, interfaces_: function() {
        return [be];
      }, getClass: function() {
        return Oe;
      } }), e(_e.prototype, { getBounds: function() {
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return _e;
      } }), e(Me.prototype, { getItem: function() {
        return this.item;
      }, getBounds: function() {
        return this.bounds;
      }, interfaces_: function() {
        return [_e, u];
      }, getClass: function() {
        return Me;
      } }), e(De.prototype, { poll: function() {
        if (this.isEmpty())
          return null;
        var t2 = this.items.get(1);
        return this.items.set(1, this.items.get(this._size)), this._size -= 1, this.reorder(1), t2;
      }, size: function() {
        return this._size;
      }, reorder: function(t2) {
        for (var e2 = null, n2 = this.items.get(t2); 2 * t2 <= this._size && (e2 = 2 * t2, e2 !== this._size && this.items.get(e2 + 1).compareTo(this.items.get(e2)) < 0 && e2++, this.items.get(e2).compareTo(n2) < 0); t2 = e2)
          this.items.set(t2, this.items.get(e2));
        this.items.set(t2, n2);
      }, clear: function() {
        this._size = 0, this.items.clear();
      }, isEmpty: function() {
        return 0 === this._size;
      }, add: function(t2) {
        this.items.add(null), this._size += 1;
        var e2 = this._size;
        for (this.items.set(0, t2); t2.compareTo(this.items.get(Math.trunc(e2 / 2))) < 0; e2 /= 2)
          this.items.set(e2, this.items.get(Math.trunc(e2 / 2)));
        this.items.set(e2, t2);
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return De;
      } }), e(Ae.prototype, { visitItem: function(t2) {
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return Ae;
      } }), e(Fe.prototype, { insert: function(t2, e2) {
      }, remove: function(t2, e2) {
      }, query: function() {
        if (1 === arguments.length) {
          arguments[0];
        } else if (2 === arguments.length) {
          arguments[0], arguments[1];
        }
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return Fe;
      } }), e(Ge.prototype, { getLevel: function() {
        return this.level;
      }, size: function() {
        return this.childBoundables.size();
      }, getChildBoundables: function() {
        return this.childBoundables;
      }, addChildBoundable: function(t2) {
        f.isTrue(null === this.bounds), this.childBoundables.add(t2);
      }, isEmpty: function() {
        return this.childBoundables.isEmpty();
      }, getBounds: function() {
        return null === this.bounds && (this.bounds = this.computeBounds()), this.bounds;
      }, interfaces_: function() {
        return [_e, u];
      }, getClass: function() {
        return Ge;
      } }), Ge.serialVersionUID = 6493722185909574e3;
      var ho = { reverseOrder: function() {
        return { compare: function(t2, e2) {
          return e2.compareTo(t2);
        } };
      }, min: function(t2) {
        return ho.sort(t2), t2.get(0);
      }, sort: function(t2, e2) {
        var n2 = t2.toArray();
        e2 ? ut.sort(n2, e2) : ut.sort(n2);
        for (var i3 = t2.iterator(), r2 = 0, s2 = n2.length; s2 > r2; r2++)
          i3.next(), i3.set(n2[r2]);
      }, singletonList: function(t2) {
        var e2 = new I();
        return e2.add(t2), e2;
      } };
      e(qe.prototype, { expandToQueue: function(t2, e2) {
        var n2 = qe.isComposite(this.boundable1), r2 = qe.isComposite(this.boundable2);
        if (n2 && r2)
          return qe.area(this.boundable1) > qe.area(this.boundable2) ? (this.expand(this.boundable1, this.boundable2, t2, e2), null) : (this.expand(this.boundable2, this.boundable1, t2, e2), null);
        if (n2)
          return this.expand(this.boundable1, this.boundable2, t2, e2), null;
        if (r2)
          return this.expand(this.boundable2, this.boundable1, t2, e2), null;
        throw new i2("neither boundable is composite");
      }, isLeaves: function() {
        return !(qe.isComposite(this.boundable1) || qe.isComposite(this.boundable2));
      }, compareTo: function(t2) {
        var e2 = t2;
        return this._distance < e2._distance ? -1 : this._distance > e2._distance ? 1 : 0;
      }, expand: function(t2, e2, n2, i3) {
        for (var r2 = t2.getChildBoundables(), s2 = r2.iterator(); s2.hasNext(); ) {
          var o2 = s2.next(), a2 = new qe(o2, e2, this.itemDistance);
          a2.getDistance() < i3 && n2.add(a2);
        }
      }, getBoundable: function(t2) {
        return 0 === t2 ? this.boundable1 : this.boundable2;
      }, getDistance: function() {
        return this._distance;
      }, distance: function() {
        return this.isLeaves() ? this.itemDistance.distance(this.boundable1, this.boundable2) : this.boundable1.getBounds().distance(this.boundable2.getBounds());
      }, interfaces_: function() {
        return [s];
      }, getClass: function() {
        return qe;
      } }), qe.area = function(t2) {
        return t2.getBounds().getArea();
      }, qe.isComposite = function(t2) {
        return t2 instanceof Ge;
      }, e(Be.prototype, { getNodeCapacity: function() {
        return this.nodeCapacity;
      }, lastNode: function(t2) {
        return t2.get(t2.size() - 1);
      }, size: function t2() {
        if (0 === arguments.length)
          return this.isEmpty() ? 0 : (this.build(), this.size(this.root));
        if (1 === arguments.length) {
          for (var e2 = arguments[0], t3 = 0, n2 = e2.getChildBoundables().iterator(); n2.hasNext(); ) {
            var i3 = n2.next();
            i3 instanceof Ge ? t3 += this.size(i3) : i3 instanceof Me && (t3 += 1);
          }
          return t3;
        }
      }, removeItem: function(t2, e2) {
        for (var n2 = null, i3 = t2.getChildBoundables().iterator(); i3.hasNext(); ) {
          var r2 = i3.next();
          r2 instanceof Me && r2.getItem() === e2 && (n2 = r2);
        }
        return null !== n2 ? (t2.getChildBoundables().remove(n2), true) : false;
      }, itemsTree: function() {
        if (0 === arguments.length) {
          this.build();
          var t2 = this.itemsTree(this.root);
          return null === t2 ? new I() : t2;
        }
        if (1 === arguments.length) {
          for (var e2 = arguments[0], n2 = new I(), i3 = e2.getChildBoundables().iterator(); i3.hasNext(); ) {
            var r2 = i3.next();
            if (r2 instanceof Ge) {
              var s2 = this.itemsTree(r2);
              null !== s2 && n2.add(s2);
            } else
              r2 instanceof Me ? n2.add(r2.getItem()) : f.shouldNeverReachHere();
          }
          return n2.size() <= 0 ? null : n2;
        }
      }, insert: function(t2, e2) {
        f.isTrue(!this.built, "Cannot insert items into an STR packed R-tree after it has been built."), this.itemBoundables.add(new Me(t2, e2));
      }, boundablesAtLevel: function() {
        if (1 === arguments.length) {
          var t2 = arguments[0], e2 = new I();
          return this.boundablesAtLevel(t2, this.root, e2), e2;
        }
        if (3 === arguments.length) {
          var n2 = arguments[0], i3 = arguments[1], r2 = arguments[2];
          if (f.isTrue(n2 > -2), i3.getLevel() === n2)
            return r2.add(i3), null;
          for (var s2 = i3.getChildBoundables().iterator(); s2.hasNext(); ) {
            var o2 = s2.next();
            o2 instanceof Ge ? this.boundablesAtLevel(n2, o2, r2) : (f.isTrue(o2 instanceof Me), -1 === n2 && r2.add(o2));
          }
          return null;
        }
      }, query: function() {
        if (1 === arguments.length) {
          var t2 = arguments[0];
          this.build();
          var e2 = new I();
          return this.isEmpty() ? e2 : (this.getIntersectsOp().intersects(this.root.getBounds(), t2) && this.query(t2, this.root, e2), e2);
        }
        if (2 === arguments.length) {
          var n2 = arguments[0], i3 = arguments[1];
          if (this.build(), this.isEmpty())
            return null;
          this.getIntersectsOp().intersects(this.root.getBounds(), n2) && this.query(n2, this.root, i3);
        } else if (3 === arguments.length) {
          if (R(arguments[2], Ae) && arguments[0] instanceof Object && arguments[1] instanceof Ge)
            for (var r2 = arguments[0], s2 = arguments[1], o2 = arguments[2], a2 = s2.getChildBoundables(), u2 = 0; u2 < a2.size(); u2++) {
              var l2 = a2.get(u2);
              this.getIntersectsOp().intersects(l2.getBounds(), r2) && (l2 instanceof Ge ? this.query(r2, l2, o2) : l2 instanceof Me ? o2.visitItem(l2.getItem()) : f.shouldNeverReachHere());
            }
          else if (R(arguments[2], y) && arguments[0] instanceof Object && arguments[1] instanceof Ge)
            for (var h2 = arguments[0], c2 = arguments[1], g2 = arguments[2], a2 = c2.getChildBoundables(), u2 = 0; u2 < a2.size(); u2++) {
              var l2 = a2.get(u2);
              this.getIntersectsOp().intersects(l2.getBounds(), h2) && (l2 instanceof Ge ? this.query(h2, l2, g2) : l2 instanceof Me ? g2.add(l2.getItem()) : f.shouldNeverReachHere());
            }
        }
      }, build: function() {
        return this.built ? null : (this.root = this.itemBoundables.isEmpty() ? this.createNode(0) : this.createHigherLevels(this.itemBoundables, -1), this.itemBoundables = null, void (this.built = true));
      }, getRoot: function() {
        return this.build(), this.root;
      }, remove: function() {
        if (2 === arguments.length) {
          var t2 = arguments[0], e2 = arguments[1];
          return this.build(), this.getIntersectsOp().intersects(this.root.getBounds(), t2) ? this.remove(t2, this.root, e2) : false;
        }
        if (3 === arguments.length) {
          var n2 = arguments[0], i3 = arguments[1], r2 = arguments[2], s2 = this.removeItem(i3, r2);
          if (s2)
            return true;
          for (var o2 = null, a2 = i3.getChildBoundables().iterator(); a2.hasNext(); ) {
            var u2 = a2.next();
            if (this.getIntersectsOp().intersects(u2.getBounds(), n2) && u2 instanceof Ge && (s2 = this.remove(n2, u2, r2))) {
              o2 = u2;
              break;
            }
          }
          return null !== o2 && o2.getChildBoundables().isEmpty() && i3.getChildBoundables().remove(o2), s2;
        }
      }, createHigherLevels: function(t2, e2) {
        f.isTrue(!t2.isEmpty());
        var n2 = this.createParentBoundables(t2, e2 + 1);
        return 1 === n2.size() ? n2.get(0) : this.createHigherLevels(n2, e2 + 1);
      }, depth: function() {
        if (0 === arguments.length)
          return this.isEmpty() ? 0 : (this.build(), this.depth(this.root));
        if (1 === arguments.length) {
          for (var t2 = arguments[0], e2 = 0, n2 = t2.getChildBoundables().iterator(); n2.hasNext(); ) {
            var i3 = n2.next();
            if (i3 instanceof Ge) {
              var r2 = this.depth(i3);
              r2 > e2 && (e2 = r2);
            }
          }
          return e2 + 1;
        }
      }, createParentBoundables: function(t2, e2) {
        f.isTrue(!t2.isEmpty());
        var n2 = new I();
        n2.add(this.createNode(e2));
        var i3 = new I(t2);
        ho.sort(i3, this.getComparator());
        for (var r2 = i3.iterator(); r2.hasNext(); ) {
          var s2 = r2.next();
          this.lastNode(n2).getChildBoundables().size() === this.getNodeCapacity() && n2.add(this.createNode(e2)), this.lastNode(n2).addChildBoundable(s2);
        }
        return n2;
      }, isEmpty: function() {
        return this.built ? this.root.isEmpty() : this.itemBoundables.isEmpty();
      }, interfaces_: function() {
        return [u];
      }, getClass: function() {
        return Be;
      } }), Be.compareDoubles = function(t2, e2) {
        return t2 > e2 ? 1 : e2 > t2 ? -1 : 0;
      }, Be.IntersectsOp = ze, Be.serialVersionUID = -3886435814360241e3, Be.DEFAULT_NODE_CAPACITY = 10, e(Ve.prototype, { distance: function(t2, e2) {
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return Ve;
      } }), h(ke, Be), e(ke.prototype, { createParentBoundablesFromVerticalSlices: function(t2, e2) {
        f.isTrue(t2.length > 0);
        for (var n2 = new I(), i3 = 0; i3 < t2.length; i3++)
          n2.addAll(this.createParentBoundablesFromVerticalSlice(t2[i3], e2));
        return n2;
      }, createNode: function(t2) {
        return new Ye(t2);
      }, size: function() {
        return 0 === arguments.length ? Be.prototype.size.call(this) : Be.prototype.size.apply(this, arguments);
      }, insert: function() {
        if (2 !== arguments.length)
          return Be.prototype.insert.apply(this, arguments);
        var t2 = arguments[0], e2 = arguments[1];
        return t2.isNull() ? null : void Be.prototype.insert.call(this, t2, e2);
      }, getIntersectsOp: function() {
        return ke.intersectsOp;
      }, verticalSlices: function(t2, e2) {
        for (var n2 = Math.trunc(Math.ceil(t2.size() / e2)), i3 = new Array(e2).fill(null), r2 = t2.iterator(), s2 = 0; e2 > s2; s2++) {
          i3[s2] = new I();
          for (var o2 = 0; r2.hasNext() && n2 > o2; ) {
            var a2 = r2.next();
            i3[s2].add(a2), o2++;
          }
        }
        return i3;
      }, query: function() {
        if (1 === arguments.length) {
          var t2 = arguments[0];
          return Be.prototype.query.call(this, t2);
        }
        if (2 === arguments.length) {
          var e2 = arguments[0], n2 = arguments[1];
          Be.prototype.query.call(this, e2, n2);
        } else if (3 === arguments.length) {
          if (R(arguments[2], Ae) && arguments[0] instanceof Object && arguments[1] instanceof Ge) {
            var i3 = arguments[0], r2 = arguments[1], s2 = arguments[2];
            Be.prototype.query.call(this, i3, r2, s2);
          } else if (R(arguments[2], y) && arguments[0] instanceof Object && arguments[1] instanceof Ge) {
            var o2 = arguments[0], a2 = arguments[1], u2 = arguments[2];
            Be.prototype.query.call(this, o2, a2, u2);
          }
        }
      }, getComparator: function() {
        return ke.yComparator;
      }, createParentBoundablesFromVerticalSlice: function(t2, e2) {
        return Be.prototype.createParentBoundables.call(this, t2, e2);
      }, remove: function() {
        if (2 === arguments.length) {
          var t2 = arguments[0], e2 = arguments[1];
          return Be.prototype.remove.call(this, t2, e2);
        }
        return Be.prototype.remove.apply(this, arguments);
      }, depth: function() {
        return 0 === arguments.length ? Be.prototype.depth.call(this) : Be.prototype.depth.apply(this, arguments);
      }, createParentBoundables: function(t2, e2) {
        f.isTrue(!t2.isEmpty());
        var n2 = Math.trunc(Math.ceil(t2.size() / this.getNodeCapacity())), i3 = new I(t2);
        ho.sort(i3, ke.xComparator);
        var r2 = this.verticalSlices(i3, Math.trunc(Math.ceil(Math.sqrt(n2))));
        return this.createParentBoundablesFromVerticalSlices(r2, e2);
      }, nearestNeighbour: function() {
        if (1 === arguments.length) {
          if (R(arguments[0], Ve)) {
            var t2 = arguments[0], e2 = new qe(this.getRoot(), this.getRoot(), t2);
            return this.nearestNeighbour(e2);
          }
          if (arguments[0] instanceof qe) {
            var n2 = arguments[0];
            return this.nearestNeighbour(n2, r.POSITIVE_INFINITY);
          }
        } else if (2 === arguments.length) {
          if (arguments[0] instanceof ke && R(arguments[1], Ve)) {
            var i3 = arguments[0], s2 = arguments[1], e2 = new qe(this.getRoot(), i3.getRoot(), s2);
            return this.nearestNeighbour(e2);
          }
          if (arguments[0] instanceof qe && "number" == typeof arguments[1]) {
            var o2 = arguments[0], a2 = arguments[1], u2 = a2, l2 = null, h2 = new De();
            for (h2.add(o2); !h2.isEmpty() && u2 > 0; ) {
              var c2 = h2.poll(), f2 = c2.getDistance();
              if (f2 >= u2)
                break;
              c2.isLeaves() ? (u2 = f2, l2 = c2) : c2.expandToQueue(h2, u2);
            }
            return [l2.getBoundable(0).getItem(), l2.getBoundable(1).getItem()];
          }
        } else if (3 === arguments.length) {
          var g2 = arguments[0], d2 = arguments[1], p2 = arguments[2], v2 = new Me(g2, d2), e2 = new qe(this.getRoot(), v2, p2);
          return this.nearestNeighbour(e2)[0];
        }
      }, interfaces_: function() {
        return [Fe, u];
      }, getClass: function() {
        return ke;
      } }), ke.centreX = function(t2) {
        return ke.avg(t2.getMinX(), t2.getMaxX());
      }, ke.avg = function(t2, e2) {
        return (t2 + e2) / 2;
      }, ke.centreY = function(t2) {
        return ke.avg(t2.getMinY(), t2.getMaxY());
      }, h(Ye, Ge), e(Ye.prototype, { computeBounds: function() {
        for (var t2 = null, e2 = this.getChildBoundables().iterator(); e2.hasNext(); ) {
          var n2 = e2.next();
          null === t2 ? t2 = new C(n2.getBounds()) : t2.expandToInclude(n2.getBounds());
        }
        return t2;
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return Ye;
      } }), ke.STRtreeNode = Ye, ke.serialVersionUID = 259274702368956900, ke.xComparator = { interfaces_: function() {
        return [a];
      }, compare: function(t2, e2) {
        return Be.compareDoubles(ke.centreX(t2.getBounds()), ke.centreX(e2.getBounds()));
      } }, ke.yComparator = { interfaces_: function() {
        return [a];
      }, compare: function(t2, e2) {
        return Be.compareDoubles(ke.centreY(t2.getBounds()), ke.centreY(e2.getBounds()));
      } }, ke.intersectsOp = { interfaces_: function() {
        return [IntersectsOp];
      }, intersects: function(t2, e2) {
        return t2.intersects(e2);
      } }, ke.DEFAULT_NODE_CAPACITY = 10, e(Ue.prototype, { interfaces_: function() {
        return [];
      }, getClass: function() {
        return Ue;
      } }), Ue.relativeSign = function(t2, e2) {
        return e2 > t2 ? -1 : t2 > e2 ? 1 : 0;
      }, Ue.compare = function(t2, e2, n2) {
        if (e2.equals2D(n2))
          return 0;
        var i3 = Ue.relativeSign(e2.x, n2.x), r2 = Ue.relativeSign(e2.y, n2.y);
        switch (t2) {
          case 0:
            return Ue.compareValue(i3, r2);
          case 1:
            return Ue.compareValue(r2, i3);
          case 2:
            return Ue.compareValue(r2, -i3);
          case 3:
            return Ue.compareValue(-i3, r2);
          case 4:
            return Ue.compareValue(-i3, -r2);
          case 5:
            return Ue.compareValue(-r2, -i3);
          case 6:
            return Ue.compareValue(-r2, i3);
          case 7:
            return Ue.compareValue(i3, -r2);
        }
        return f.shouldNeverReachHere("invalid octant value"), 0;
      }, Ue.compareValue = function(t2, e2) {
        return 0 > t2 ? -1 : t2 > 0 ? 1 : 0 > e2 ? -1 : e2 > 0 ? 1 : 0;
      }, e(Xe.prototype, { getCoordinate: function() {
        return this.coord;
      }, print: function(t2) {
        t2.print(this.coord), t2.print(" seg # = " + this.segmentIndex);
      }, compareTo: function(t2) {
        var e2 = t2;
        return this.segmentIndex < e2.segmentIndex ? -1 : this.segmentIndex > e2.segmentIndex ? 1 : this.coord.equals2D(e2.coord) ? 0 : Ue.compare(this.segmentOctant, this.coord, e2.coord);
      }, isEndPoint: function(t2) {
        return 0 !== this.segmentIndex || this._isInterior ? this.segmentIndex === t2 : true;
      }, isInterior: function() {
        return this._isInterior;
      }, interfaces_: function() {
        return [s];
      }, getClass: function() {
        return Xe;
      } }), e(He.prototype, { getSplitCoordinates: function() {
        var t2 = new N();
        this.addEndpoints();
        for (var e2 = this.iterator(), n2 = e2.next(); e2.hasNext(); ) {
          var i3 = e2.next();
          this.addEdgeCoordinates(n2, i3, t2), n2 = i3;
        }
        return t2.toCoordinateArray();
      }, addCollapsedNodes: function() {
        var t2 = new I();
        this.findCollapsesFromInsertedNodes(t2), this.findCollapsesFromExistingVertices(t2);
        for (var e2 = t2.iterator(); e2.hasNext(); ) {
          var n2 = e2.next().intValue();
          this.add(this.edge.getCoordinate(n2), n2);
        }
      }, print: function(t2) {
        t2.println("Intersections:");
        for (var e2 = this.iterator(); e2.hasNext(); ) {
          var n2 = e2.next();
          n2.print(t2);
        }
      }, findCollapsesFromExistingVertices: function(t2) {
        for (var e2 = 0; e2 < this.edge.size() - 2; e2++) {
          var n2 = this.edge.getCoordinate(e2), i3 = (this.edge.getCoordinate(e2 + 1), this.edge.getCoordinate(e2 + 2));
          n2.equals2D(i3) && t2.add(new b(e2 + 1));
        }
      }, addEdgeCoordinates: function(t2, e2, n2) {
        var i3 = e2.segmentIndex - t2.segmentIndex + 2, r2 = this.edge.getCoordinate(e2.segmentIndex), s2 = e2.isInterior() || !e2.coord.equals2D(r2);
        s2 || i3--;
        n2.add(new g(t2.coord), false);
        for (var o2 = t2.segmentIndex + 1; o2 <= e2.segmentIndex; o2++)
          n2.add(this.edge.getCoordinate(o2));
        s2 && n2.add(new g(e2.coord));
      }, iterator: function() {
        return this.nodeMap.values().iterator();
      }, addSplitEdges: function(t2) {
        this.addEndpoints(), this.addCollapsedNodes();
        for (var e2 = this.iterator(), n2 = e2.next(); e2.hasNext(); ) {
          var i3 = e2.next(), r2 = this.createSplitEdge(n2, i3);
          t2.add(r2), n2 = i3;
        }
      }, findCollapseIndex: function(t2, e2, n2) {
        if (!t2.coord.equals2D(e2.coord))
          return false;
        var i3 = e2.segmentIndex - t2.segmentIndex;
        return e2.isInterior() || i3--, 1 === i3 ? (n2[0] = t2.segmentIndex + 1, true) : false;
      }, findCollapsesFromInsertedNodes: function(t2) {
        for (var e2 = new Array(1).fill(null), n2 = this.iterator(), i3 = n2.next(); n2.hasNext(); ) {
          var r2 = n2.next(), s2 = this.findCollapseIndex(i3, r2, e2);
          s2 && t2.add(new b(e2[0])), i3 = r2;
        }
      }, getEdge: function() {
        return this.edge;
      }, addEndpoints: function() {
        var t2 = this.edge.size() - 1;
        this.add(this.edge.getCoordinate(0), 0), this.add(this.edge.getCoordinate(t2), t2);
      }, createSplitEdge: function(t2, e2) {
        var n2 = e2.segmentIndex - t2.segmentIndex + 2, i3 = this.edge.getCoordinate(e2.segmentIndex), r2 = e2.isInterior() || !e2.coord.equals2D(i3);
        r2 || n2--;
        var s2 = new Array(n2).fill(null), o2 = 0;
        s2[o2++] = new g(t2.coord);
        for (var a2 = t2.segmentIndex + 1; a2 <= e2.segmentIndex; a2++)
          s2[o2++] = this.edge.getCoordinate(a2);
        return r2 && (s2[o2] = new g(e2.coord)), new Ke(s2, this.edge.getData());
      }, add: function(t2, e2) {
        var n2 = new Xe(this.edge, t2, e2, this.edge.getSegmentOctant(e2)), i3 = this.nodeMap.get(n2);
        return null !== i3 ? (f.isTrue(i3.coord.equals2D(t2), "Found equal nodes with different coordinates"), i3) : (this.nodeMap.put(n2, n2), n2);
      }, checkSplitEdgesCorrectness: function(t2) {
        var e2 = this.edge.getCoordinates(), n2 = t2.get(0), i3 = n2.getCoordinate(0);
        if (!i3.equals2D(e2[0]))
          throw new l("bad split edge start point at " + i3);
        var r2 = t2.get(t2.size() - 1), s2 = r2.getCoordinates(), o2 = s2[s2.length - 1];
        if (!o2.equals2D(e2[e2.length - 1]))
          throw new l("bad split edge end point at " + o2);
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return He;
      } }), e(We.prototype, { next: function() {
        return null === this.currNode ? (this.currNode = this.nextNode, this.currSegIndex = this.currNode.segmentIndex, this.readNextNode(), this.currNode) : null === this.nextNode ? null : this.nextNode.segmentIndex === this.currNode.segmentIndex ? (this.currNode = this.nextNode, this.currSegIndex = this.currNode.segmentIndex, this.readNextNode(), this.currNode) : (this.nextNode.segmentIndex > this.currNode.segmentIndex, null);
      }, remove: function() {
        throw new UnsupportedOperationException(this.getClass().getName());
      }, hasNext: function() {
        return null !== this.nextNode;
      }, readNextNode: function() {
        this.nodeIt.hasNext() ? this.nextNode = this.nodeIt.next() : this.nextNode = null;
      }, interfaces_: function() {
        return [p];
      }, getClass: function() {
        return We;
      } }), e(je.prototype, { addIntersection: function(t2, e2) {
      }, interfaces_: function() {
        return [be];
      }, getClass: function() {
        return je;
      } }), e(Ke.prototype, { getCoordinates: function() {
        return this.pts;
      }, size: function() {
        return this.pts.length;
      }, getCoordinate: function(t2) {
        return this.pts[t2];
      }, isClosed: function() {
        return this.pts[0].equals(this.pts[this.pts.length - 1]);
      }, getSegmentOctant: function(t2) {
        return t2 === this.pts.length - 1 ? -1 : this.safeOctant(this.getCoordinate(t2), this.getCoordinate(t2 + 1));
      }, setData: function(t2) {
        this.data = t2;
      }, safeOctant: function(t2, e2) {
        return t2.equals2D(e2) ? 0 : Pe.octant(t2, e2);
      }, getData: function() {
        return this.data;
      }, addIntersection: function() {
        if (2 === arguments.length) {
          var t2 = arguments[0], e2 = arguments[1];
          this.addIntersectionNode(t2, e2);
        } else if (4 === arguments.length) {
          var n2 = arguments[0], i3 = arguments[1], r2 = (arguments[2], arguments[3]), s2 = new g(n2.getIntersection(r2));
          this.addIntersection(s2, i3);
        }
      }, toString: function() {
        return se.toLineString(new Gt(this.pts));
      }, getNodeList: function() {
        return this.nodeList;
      }, addIntersectionNode: function(t2, e2) {
        var n2 = e2, i3 = n2 + 1;
        if (i3 < this.pts.length) {
          var r2 = this.pts[i3];
          t2.equals2D(r2) && (n2 = i3);
        }
        var s2 = this.nodeList.add(t2, n2);
        return s2;
      }, addIntersections: function(t2, e2, n2) {
        for (var i3 = 0; i3 < t2.getIntersectionNum(); i3++)
          this.addIntersection(t2, e2, n2, i3);
      }, interfaces_: function() {
        return [je];
      }, getClass: function() {
        return Ke;
      } }), Ke.getNodedSubstrings = function() {
        if (1 === arguments.length) {
          var t2 = arguments[0], e2 = new I();
          return Ke.getNodedSubstrings(t2, e2), e2;
        }
        if (2 === arguments.length)
          for (var n2 = arguments[0], i3 = arguments[1], r2 = n2.iterator(); r2.hasNext(); ) {
            var s2 = r2.next();
            s2.getNodeList().addSplitEdges(i3);
          }
      }, e(Ze.prototype, { overlap: function() {
        if (2 === arguments.length) {
          arguments[0], arguments[1];
        } else if (4 === arguments.length) {
          var t2 = arguments[0], e2 = arguments[1], n2 = arguments[2], i3 = arguments[3];
          t2.getLineSegment(e2, this.overlapSeg1), n2.getLineSegment(i3, this.overlapSeg2), this.overlap(this.overlapSeg1, this.overlapSeg2);
        }
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return Ze;
      } }), e(Qe.prototype, { getLineSegment: function(t2, e2) {
        e2.p0 = this.pts[t2], e2.p1 = this.pts[t2 + 1];
      }, computeSelect: function(t2, e2, n2, i3) {
        var r2 = this.pts[e2], s2 = this.pts[n2];
        if (i3.tempEnv1.init(r2, s2), n2 - e2 === 1)
          return i3.select(this, e2), null;
        if (!t2.intersects(i3.tempEnv1))
          return null;
        var o2 = Math.trunc((e2 + n2) / 2);
        o2 > e2 && this.computeSelect(t2, e2, o2, i3), n2 > o2 && this.computeSelect(t2, o2, n2, i3);
      }, getCoordinates: function() {
        for (var t2 = new Array(this.end - this.start + 1).fill(null), e2 = 0, n2 = this.start; n2 <= this.end; n2++)
          t2[e2++] = this.pts[n2];
        return t2;
      }, computeOverlaps: function(t2, e2) {
        this.computeOverlapsInternal(this.start, this.end, t2, t2.start, t2.end, e2);
      }, setId: function(t2) {
        this.id = t2;
      }, select: function(t2, e2) {
        this.computeSelect(t2, this.start, this.end, e2);
      }, getEnvelope: function() {
        if (null === this.env) {
          var t2 = this.pts[this.start], e2 = this.pts[this.end];
          this.env = new C(t2, e2);
        }
        return this.env;
      }, getEndIndex: function() {
        return this.end;
      }, getStartIndex: function() {
        return this.start;
      }, getContext: function() {
        return this.context;
      }, getId: function() {
        return this.id;
      }, computeOverlapsInternal: function(t2, e2, n2, i3, r2, s2) {
        var o2 = this.pts[t2], a2 = this.pts[e2], u2 = n2.pts[i3], l2 = n2.pts[r2];
        if (e2 - t2 === 1 && r2 - i3 === 1)
          return s2.overlap(this, t2, n2, i3), null;
        if (s2.tempEnv1.init(o2, a2), s2.tempEnv2.init(u2, l2), !s2.tempEnv1.intersects(s2.tempEnv2))
          return null;
        var h2 = Math.trunc((t2 + e2) / 2), c2 = Math.trunc((i3 + r2) / 2);
        h2 > t2 && (c2 > i3 && this.computeOverlapsInternal(t2, h2, n2, i3, c2, s2), r2 > c2 && this.computeOverlapsInternal(t2, h2, n2, c2, r2, s2)), e2 > h2 && (c2 > i3 && this.computeOverlapsInternal(h2, e2, n2, i3, c2, s2), r2 > c2 && this.computeOverlapsInternal(h2, e2, n2, c2, r2, s2));
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return Qe;
      } }), e(Je.prototype, { interfaces_: function() {
        return [];
      }, getClass: function() {
        return Je;
      } }), Je.isNorthern = function(t2) {
        return t2 === Je.NE || t2 === Je.NW;
      }, Je.isOpposite = function(t2, e2) {
        if (t2 === e2)
          return false;
        var n2 = (t2 - e2 + 4) % 4;
        return 2 === n2;
      }, Je.commonHalfPlane = function(t2, e2) {
        if (t2 === e2)
          return t2;
        var n2 = (t2 - e2 + 4) % 4;
        if (2 === n2)
          return -1;
        var i3 = e2 > t2 ? t2 : e2, r2 = t2 > e2 ? t2 : e2;
        return 0 === i3 && 3 === r2 ? 3 : i3;
      }, Je.isInHalfPlane = function(t2, e2) {
        return e2 === Je.SE ? t2 === Je.SE || t2 === Je.SW : t2 === e2 || t2 === e2 + 1;
      }, Je.quadrant = function() {
        if ("number" == typeof arguments[0] && "number" == typeof arguments[1]) {
          var t2 = arguments[0], e2 = arguments[1];
          if (0 === t2 && 0 === e2)
            throw new i2("Cannot compute the quadrant for point ( " + t2 + ", " + e2 + " )");
          return t2 >= 0 ? e2 >= 0 ? Je.NE : Je.SE : e2 >= 0 ? Je.NW : Je.SW;
        }
        if (arguments[0] instanceof g && arguments[1] instanceof g) {
          var n2 = arguments[0], r2 = arguments[1];
          if (r2.x === n2.x && r2.y === n2.y)
            throw new i2("Cannot compute the quadrant for two identical points " + n2);
          return r2.x >= n2.x ? r2.y >= n2.y ? Je.NE : Je.SE : r2.y >= n2.y ? Je.NW : Je.SW;
        }
      }, Je.NE = 0, Je.NW = 1, Je.SW = 2, Je.SE = 3, e($e.prototype, { interfaces_: function() {
        return [];
      }, getClass: function() {
        return $e;
      } }), $e.getChainStartIndices = function(t2) {
        var e2 = 0, n2 = new I();
        n2.add(new b(e2));
        do {
          var i3 = $e.findChainEnd(t2, e2);
          n2.add(new b(i3)), e2 = i3;
        } while (e2 < t2.length - 1);
        var r2 = $e.toIntArray(n2);
        return r2;
      }, $e.findChainEnd = function(t2, e2) {
        for (var n2 = e2; n2 < t2.length - 1 && t2[n2].equals2D(t2[n2 + 1]); )
          n2++;
        if (n2 >= t2.length - 1)
          return t2.length - 1;
        for (var i3 = Je.quadrant(t2[n2], t2[n2 + 1]), r2 = e2 + 1; r2 < t2.length; ) {
          if (!t2[r2 - 1].equals2D(t2[r2])) {
            var s2 = Je.quadrant(t2[r2 - 1], t2[r2]);
            if (s2 !== i3)
              break;
          }
          r2++;
        }
        return r2 - 1;
      }, $e.getChains = function() {
        if (1 === arguments.length) {
          var t2 = arguments[0];
          return $e.getChains(t2, null);
        }
        if (2 === arguments.length) {
          for (var e2 = arguments[0], n2 = arguments[1], i3 = new I(), r2 = $e.getChainStartIndices(e2), s2 = 0; s2 < r2.length - 1; s2++) {
            var o2 = new Qe(e2, r2[s2], r2[s2 + 1], n2);
            i3.add(o2);
          }
          return i3;
        }
      }, $e.toIntArray = function(t2) {
        for (var e2 = new Array(t2.size()).fill(null), n2 = 0; n2 < e2.length; n2++)
          e2[n2] = t2.get(n2).intValue();
        return e2;
      }, e(tn.prototype, { computeNodes: function(t2) {
      }, getNodedSubstrings: function() {
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return tn;
      } }), e(en.prototype, { setSegmentIntersector: function(t2) {
        this.segInt = t2;
      }, interfaces_: function() {
        return [tn];
      }, getClass: function() {
        return en;
      } }), h(nn, en), e(nn.prototype, { getMonotoneChains: function() {
        return this.monoChains;
      }, getNodedSubstrings: function() {
        return Ke.getNodedSubstrings(this.nodedSegStrings);
      }, getIndex: function() {
        return this.index;
      }, add: function(t2) {
        for (var e2 = $e.getChains(t2.getCoordinates(), t2), n2 = e2.iterator(); n2.hasNext(); ) {
          var i3 = n2.next();
          i3.setId(this.idCounter++), this.index.insert(i3.getEnvelope(), i3), this.monoChains.add(i3);
        }
      }, computeNodes: function(t2) {
        this.nodedSegStrings = t2;
        for (var e2 = t2.iterator(); e2.hasNext(); )
          this.add(e2.next());
        this.intersectChains();
      }, intersectChains: function() {
        for (var t2 = new rn(this.segInt), e2 = this.monoChains.iterator(); e2.hasNext(); )
          for (var n2 = e2.next(), i3 = this.index.query(n2.getEnvelope()), r2 = i3.iterator(); r2.hasNext(); ) {
            var s2 = r2.next();
            if (s2.getId() > n2.getId() && (n2.computeOverlaps(s2, t2), this.nOverlaps++), this.segInt.isDone())
              return null;
          }
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return nn;
      } }), h(rn, Ze), e(rn.prototype, { overlap: function() {
        if (4 !== arguments.length)
          return Ze.prototype.overlap.apply(this, arguments);
        var t2 = arguments[0], e2 = arguments[1], n2 = arguments[2], i3 = arguments[3], r2 = t2.getContext(), s2 = n2.getContext();
        this.si.processIntersections(r2, e2, s2, i3);
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return rn;
      } }), nn.SegmentOverlapAction = rn, h(sn, l), e(sn.prototype, { getCoordinate: function() {
        return this.pt;
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return sn;
      } }), sn.msgWithCoord = function(t2, e2) {
        return null !== e2 ? t2 + " [ " + e2 + " ]" : t2;
      }, e(on.prototype, { processIntersections: function(t2, e2, n2, i3) {
      }, isDone: function() {
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return on;
      } }), e(an.prototype, { getInteriorIntersection: function() {
        return this.interiorIntersection;
      }, setCheckEndSegmentsOnly: function(t2) {
        this.isCheckEndSegmentsOnly = t2;
      }, getIntersectionSegments: function() {
        return this.intSegments;
      }, count: function() {
        return this.intersectionCount;
      }, getIntersections: function() {
        return this.intersections;
      }, setFindAllIntersections: function(t2) {
        this.findAllIntersections = t2;
      }, setKeepIntersections: function(t2) {
        this.keepIntersections = t2;
      }, processIntersections: function(t2, e2, n2, i3) {
        if (!this.findAllIntersections && this.hasIntersection())
          return null;
        if (t2 === n2 && e2 === i3)
          return null;
        if (this.isCheckEndSegmentsOnly) {
          var r2 = this.isEndSegment(t2, e2) || this.isEndSegment(n2, i3);
          if (!r2)
            return null;
        }
        var s2 = t2.getCoordinates()[e2], o2 = t2.getCoordinates()[e2 + 1], a2 = n2.getCoordinates()[i3], u2 = n2.getCoordinates()[i3 + 1];
        this.li.computeIntersection(s2, o2, a2, u2), this.li.hasIntersection() && this.li.isInteriorIntersection() && (this.intSegments = new Array(4).fill(null), this.intSegments[0] = s2, this.intSegments[1] = o2, this.intSegments[2] = a2, this.intSegments[3] = u2, this.interiorIntersection = this.li.getIntersection(0), this.keepIntersections && this.intersections.add(this.interiorIntersection), this.intersectionCount++);
      }, isEndSegment: function(t2, e2) {
        return 0 === e2 ? true : e2 >= t2.size() - 2;
      }, hasIntersection: function() {
        return null !== this.interiorIntersection;
      }, isDone: function() {
        return this.findAllIntersections ? false : null !== this.interiorIntersection;
      }, interfaces_: function() {
        return [on];
      }, getClass: function() {
        return an;
      } }), an.createAllIntersectionsFinder = function(t2) {
        var e2 = new an(t2);
        return e2.setFindAllIntersections(true), e2;
      }, an.createAnyIntersectionFinder = function(t2) {
        return new an(t2);
      }, an.createIntersectionCounter = function(t2) {
        var e2 = new an(t2);
        return e2.setFindAllIntersections(true), e2.setKeepIntersections(false), e2;
      }, e(un.prototype, { execute: function() {
        return null !== this.segInt ? null : void this.checkInteriorIntersections();
      }, getIntersections: function() {
        return this.segInt.getIntersections();
      }, isValid: function() {
        return this.execute(), this._isValid;
      }, setFindAllIntersections: function(t2) {
        this.findAllIntersections = t2;
      }, checkInteriorIntersections: function() {
        this._isValid = true, this.segInt = new an(this.li), this.segInt.setFindAllIntersections(this.findAllIntersections);
        var t2 = new nn();
        return t2.setSegmentIntersector(this.segInt), t2.computeNodes(this.segStrings), this.segInt.hasIntersection() ? (this._isValid = false, null) : void 0;
      }, checkValid: function() {
        if (this.execute(), !this._isValid)
          throw new sn(this.getErrorMessage(), this.segInt.getInteriorIntersection());
      }, getErrorMessage: function() {
        if (this._isValid)
          return "no intersections found";
        var t2 = this.segInt.getIntersectionSegments();
        return "found non-noded intersection between " + se.toLineString(t2[0], t2[1]) + " and " + se.toLineString(t2[2], t2[3]);
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return un;
      } }), un.computeIntersections = function(t2) {
        var e2 = new un(t2);
        return e2.setFindAllIntersections(true), e2.isValid(), e2.getIntersections();
      }, e(ln.prototype, { checkValid: function() {
        this.nv.checkValid();
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return ln;
      } }), ln.toSegmentStrings = function(t2) {
        for (var e2 = new I(), n2 = t2.iterator(); n2.hasNext(); ) {
          var i3 = n2.next();
          e2.add(new Oe(i3.getCoordinates(), i3));
        }
        return e2;
      }, ln.checkValid = function(t2) {
        var e2 = new ln(t2);
        e2.checkValid();
      }, e(hn.prototype, { map: function(t2) {
        for (var e2 = new I(), n2 = 0; n2 < t2.getNumGeometries(); n2++) {
          var i3 = this.mapOp.map(t2.getGeometryN(n2));
          i3.isEmpty() || e2.add(i3);
        }
        return t2.getFactory().createGeometryCollection(ie.toGeometryArray(e2));
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return hn;
      } }), hn.map = function(t2, e2) {
        var n2 = new hn(e2);
        return n2.map(t2);
      }, e(cn.prototype, { interfaces_: function() {
        return [];
      }, getClass: function() {
        return cn;
      } }), cn.opposite = function(t2) {
        return t2 === cn.LEFT ? cn.RIGHT : t2 === cn.RIGHT ? cn.LEFT : t2;
      }, cn.ON = 0, cn.LEFT = 1, cn.RIGHT = 2, e(fn.prototype, { setAllLocations: function(t2) {
        for (var e2 = 0; e2 < this.location.length; e2++)
          this.location[e2] = t2;
      }, isNull: function() {
        for (var t2 = 0; t2 < this.location.length; t2++)
          if (this.location[t2] !== L.NONE)
            return false;
        return true;
      }, setAllLocationsIfNull: function(t2) {
        for (var e2 = 0; e2 < this.location.length; e2++)
          this.location[e2] === L.NONE && (this.location[e2] = t2);
      }, isLine: function() {
        return 1 === this.location.length;
      }, merge: function(t2) {
        if (t2.location.length > this.location.length) {
          var e2 = new Array(3).fill(null);
          e2[cn.ON] = this.location[cn.ON], e2[cn.LEFT] = L.NONE, e2[cn.RIGHT] = L.NONE, this.location = e2;
        }
        for (var n2 = 0; n2 < this.location.length; n2++)
          this.location[n2] === L.NONE && n2 < t2.location.length && (this.location[n2] = t2.location[n2]);
      }, getLocations: function() {
        return this.location;
      }, flip: function() {
        if (this.location.length <= 1)
          return null;
        var t2 = this.location[cn.LEFT];
        this.location[cn.LEFT] = this.location[cn.RIGHT], this.location[cn.RIGHT] = t2;
      }, toString: function() {
        var t2 = new P();
        return this.location.length > 1 && t2.append(L.toLocationSymbol(this.location[cn.LEFT])), t2.append(L.toLocationSymbol(this.location[cn.ON])), this.location.length > 1 && t2.append(L.toLocationSymbol(this.location[cn.RIGHT])), t2.toString();
      }, setLocations: function(t2, e2, n2) {
        this.location[cn.ON] = t2, this.location[cn.LEFT] = e2, this.location[cn.RIGHT] = n2;
      }, get: function(t2) {
        return t2 < this.location.length ? this.location[t2] : L.NONE;
      }, isArea: function() {
        return this.location.length > 1;
      }, isAnyNull: function() {
        for (var t2 = 0; t2 < this.location.length; t2++)
          if (this.location[t2] === L.NONE)
            return true;
        return false;
      }, setLocation: function() {
        if (1 === arguments.length) {
          var t2 = arguments[0];
          this.setLocation(cn.ON, t2);
        } else if (2 === arguments.length) {
          var e2 = arguments[0], n2 = arguments[1];
          this.location[e2] = n2;
        }
      }, init: function(t2) {
        this.location = new Array(t2).fill(null), this.setAllLocations(L.NONE);
      }, isEqualOnSide: function(t2, e2) {
        return this.location[e2] === t2.location[e2];
      }, allPositionsEqual: function(t2) {
        for (var e2 = 0; e2 < this.location.length; e2++)
          if (this.location[e2] !== t2)
            return false;
        return true;
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return fn;
      } }), e(gn.prototype, { getGeometryCount: function() {
        var t2 = 0;
        return this.elt[0].isNull() || t2++, this.elt[1].isNull() || t2++, t2;
      }, setAllLocations: function(t2, e2) {
        this.elt[t2].setAllLocations(e2);
      }, isNull: function(t2) {
        return this.elt[t2].isNull();
      }, setAllLocationsIfNull: function() {
        if (1 === arguments.length) {
          var t2 = arguments[0];
          this.setAllLocationsIfNull(0, t2), this.setAllLocationsIfNull(1, t2);
        } else if (2 === arguments.length) {
          var e2 = arguments[0], n2 = arguments[1];
          this.elt[e2].setAllLocationsIfNull(n2);
        }
      }, isLine: function(t2) {
        return this.elt[t2].isLine();
      }, merge: function(t2) {
        for (var e2 = 0; 2 > e2; e2++)
          null === this.elt[e2] && null !== t2.elt[e2] ? this.elt[e2] = new fn(t2.elt[e2]) : this.elt[e2].merge(t2.elt[e2]);
      }, flip: function() {
        this.elt[0].flip(), this.elt[1].flip();
      }, getLocation: function() {
        if (1 === arguments.length) {
          var t2 = arguments[0];
          return this.elt[t2].get(cn.ON);
        }
        if (2 === arguments.length) {
          var e2 = arguments[0], n2 = arguments[1];
          return this.elt[e2].get(n2);
        }
      }, toString: function() {
        var t2 = new P();
        return null !== this.elt[0] && (t2.append("A:"), t2.append(this.elt[0].toString())), null !== this.elt[1] && (t2.append(" B:"), t2.append(this.elt[1].toString())), t2.toString();
      }, isArea: function() {
        if (0 === arguments.length)
          return this.elt[0].isArea() || this.elt[1].isArea();
        if (1 === arguments.length) {
          var t2 = arguments[0];
          return this.elt[t2].isArea();
        }
      }, isAnyNull: function(t2) {
        return this.elt[t2].isAnyNull();
      }, setLocation: function() {
        if (2 === arguments.length) {
          var t2 = arguments[0], e2 = arguments[1];
          this.elt[t2].setLocation(cn.ON, e2);
        } else if (3 === arguments.length) {
          var n2 = arguments[0], i3 = arguments[1], r2 = arguments[2];
          this.elt[n2].setLocation(i3, r2);
        }
      }, isEqualOnSide: function(t2, e2) {
        return this.elt[0].isEqualOnSide(t2.elt[0], e2) && this.elt[1].isEqualOnSide(t2.elt[1], e2);
      }, allPositionsEqual: function(t2, e2) {
        return this.elt[t2].allPositionsEqual(e2);
      }, toLine: function(t2) {
        this.elt[t2].isArea() && (this.elt[t2] = new fn(this.elt[t2].location[0]));
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return gn;
      } }), gn.toLineLabel = function(t2) {
        for (var e2 = new gn(L.NONE), n2 = 0; 2 > n2; n2++)
          e2.setLocation(n2, t2.getLocation(n2));
        return e2;
      }, e(dn.prototype, { computeRing: function() {
        if (null !== this.ring)
          return null;
        for (var t2 = new Array(this.pts.size()).fill(null), e2 = 0; e2 < this.pts.size(); e2++)
          t2[e2] = this.pts.get(e2);
        this.ring = this.geometryFactory.createLinearRing(t2), this._isHole = he.isCCW(this.ring.getCoordinates());
      }, isIsolated: function() {
        return 1 === this.label.getGeometryCount();
      }, computePoints: function(t2) {
        this.startDe = t2;
        var e2 = t2, n2 = true;
        do {
          if (null === e2)
            throw new sn("Found null DirectedEdge");
          if (e2.getEdgeRing() === this)
            throw new sn("Directed Edge visited twice during ring-building at " + e2.getCoordinate());
          this.edges.add(e2);
          var i3 = e2.getLabel();
          f.isTrue(i3.isArea()), this.mergeLabel(i3), this.addPoints(e2.getEdge(), e2.isForward(), n2), n2 = false, this.setEdgeRing(e2, this), e2 = this.getNext(e2);
        } while (e2 !== this.startDe);
      }, getLinearRing: function() {
        return this.ring;
      }, getCoordinate: function(t2) {
        return this.pts.get(t2);
      }, computeMaxNodeDegree: function() {
        this.maxNodeDegree = 0;
        var t2 = this.startDe;
        do {
          var e2 = t2.getNode(), n2 = e2.getEdges().getOutgoingDegree(this);
          n2 > this.maxNodeDegree && (this.maxNodeDegree = n2), t2 = this.getNext(t2);
        } while (t2 !== this.startDe);
        this.maxNodeDegree *= 2;
      }, addPoints: function(t2, e2, n2) {
        var i3 = t2.getCoordinates();
        if (e2) {
          var r2 = 1;
          n2 && (r2 = 0);
          for (var s2 = r2; s2 < i3.length; s2++)
            this.pts.add(i3[s2]);
        } else {
          var r2 = i3.length - 2;
          n2 && (r2 = i3.length - 1);
          for (var s2 = r2; s2 >= 0; s2--)
            this.pts.add(i3[s2]);
        }
      }, isHole: function() {
        return this._isHole;
      }, setInResult: function() {
        var t2 = this.startDe;
        do
          t2.getEdge().setInResult(true), t2 = t2.getNext();
        while (t2 !== this.startDe);
      }, containsPoint: function(t2) {
        var e2 = this.getLinearRing(), n2 = e2.getEnvelopeInternal();
        if (!n2.contains(t2))
          return false;
        if (!he.isPointInRing(t2, e2.getCoordinates()))
          return false;
        for (var i3 = this.holes.iterator(); i3.hasNext(); ) {
          var r2 = i3.next();
          if (r2.containsPoint(t2))
            return false;
        }
        return true;
      }, addHole: function(t2) {
        this.holes.add(t2);
      }, isShell: function() {
        return null === this.shell;
      }, getLabel: function() {
        return this.label;
      }, getEdges: function() {
        return this.edges;
      }, getMaxNodeDegree: function() {
        return this.maxNodeDegree < 0 && this.computeMaxNodeDegree(), this.maxNodeDegree;
      }, getShell: function() {
        return this.shell;
      }, mergeLabel: function() {
        if (1 === arguments.length) {
          var t2 = arguments[0];
          this.mergeLabel(t2, 0), this.mergeLabel(t2, 1);
        } else if (2 === arguments.length) {
          var e2 = arguments[0], n2 = arguments[1], i3 = e2.getLocation(n2, cn.RIGHT);
          if (i3 === L.NONE)
            return null;
          if (this.label.getLocation(n2) === L.NONE)
            return this.label.setLocation(n2, i3), null;
        }
      }, setShell: function(t2) {
        this.shell = t2, null !== t2 && t2.addHole(this);
      }, toPolygon: function(t2) {
        for (var e2 = new Array(this.holes.size()).fill(null), n2 = 0; n2 < this.holes.size(); n2++)
          e2[n2] = this.holes.get(n2).getLinearRing();
        var i3 = t2.createPolygon(this.getLinearRing(), e2);
        return i3;
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return dn;
      } }), h(pn, dn), e(pn.prototype, { setEdgeRing: function(t2, e2) {
        t2.setMinEdgeRing(e2);
      }, getNext: function(t2) {
        return t2.getNextMin();
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return pn;
      } }), h(vn, dn), e(vn.prototype, { buildMinimalRings: function() {
        var t2 = new I(), e2 = this.startDe;
        do {
          if (null === e2.getMinEdgeRing()) {
            var n2 = new pn(e2, this.geometryFactory);
            t2.add(n2);
          }
          e2 = e2.getNext();
        } while (e2 !== this.startDe);
        return t2;
      }, setEdgeRing: function(t2, e2) {
        t2.setEdgeRing(e2);
      }, linkDirectedEdgesForMinimalEdgeRings: function() {
        var t2 = this.startDe;
        do {
          var e2 = t2.getNode();
          e2.getEdges().linkMinimalDirectedEdges(this), t2 = t2.getNext();
        } while (t2 !== this.startDe);
      }, getNext: function(t2) {
        return t2.getNext();
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return vn;
      } }), e(mn.prototype, { setVisited: function(t2) {
        this._isVisited = t2;
      }, setInResult: function(t2) {
        this._isInResult = t2;
      }, isCovered: function() {
        return this._isCovered;
      }, isCoveredSet: function() {
        return this._isCoveredSet;
      }, setLabel: function(t2) {
        this.label = t2;
      }, getLabel: function() {
        return this.label;
      }, setCovered: function(t2) {
        this._isCovered = t2, this._isCoveredSet = true;
      }, updateIM: function(t2) {
        f.isTrue(this.label.getGeometryCount() >= 2, "found partial label"), this.computeIM(t2);
      }, isInResult: function() {
        return this._isInResult;
      }, isVisited: function() {
        return this._isVisited;
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return mn;
      } }), h(yn, mn), e(yn.prototype, { isIncidentEdgeInResult: function() {
        for (var t2 = this.getEdges().getEdges().iterator(); t2.hasNext(); ) {
          var e2 = t2.next();
          if (e2.getEdge().isInResult())
            return true;
        }
        return false;
      }, isIsolated: function() {
        return 1 === this.label.getGeometryCount();
      }, getCoordinate: function() {
        return this.coord;
      }, print: function(t2) {
        t2.println("node " + this.coord + " lbl: " + this.label);
      }, computeIM: function(t2) {
      }, computeMergedLocation: function(t2, e2) {
        var n2 = L.NONE;
        if (n2 = this.label.getLocation(e2), !t2.isNull(e2)) {
          var i3 = t2.getLocation(e2);
          n2 !== L.BOUNDARY && (n2 = i3);
        }
        return n2;
      }, setLabel: function() {
        if (2 !== arguments.length)
          return mn.prototype.setLabel.apply(this, arguments);
        var t2 = arguments[0], e2 = arguments[1];
        null === this.label ? this.label = new gn(t2, e2) : this.label.setLocation(t2, e2);
      }, getEdges: function() {
        return this.edges;
      }, mergeLabel: function() {
        if (arguments[0] instanceof yn) {
          var t2 = arguments[0];
          this.mergeLabel(t2.label);
        } else if (arguments[0] instanceof gn)
          for (var e2 = arguments[0], n2 = 0; 2 > n2; n2++) {
            var i3 = this.computeMergedLocation(e2, n2), r2 = this.label.getLocation(n2);
            r2 === L.NONE && this.label.setLocation(n2, i3);
          }
      }, add: function(t2) {
        this.edges.insert(t2), t2.setNode(this);
      }, setLabelBoundary: function(t2) {
        if (null === this.label)
          return null;
        var e2 = L.NONE;
        null !== this.label && (e2 = this.label.getLocation(t2));
        var n2 = null;
        switch (e2) {
          case L.BOUNDARY:
            n2 = L.INTERIOR;
            break;
          case L.INTERIOR:
            n2 = L.BOUNDARY;
            break;
          default:
            n2 = L.BOUNDARY;
        }
        this.label.setLocation(t2, n2);
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return yn;
      } }), e(xn.prototype, { find: function(t2) {
        return this.nodeMap.get(t2);
      }, addNode: function() {
        if (arguments[0] instanceof g) {
          var t2 = arguments[0], e2 = this.nodeMap.get(t2);
          return null === e2 && (e2 = this.nodeFact.createNode(t2), this.nodeMap.put(t2, e2)), e2;
        }
        if (arguments[0] instanceof yn) {
          var n2 = arguments[0], e2 = this.nodeMap.get(n2.getCoordinate());
          return null === e2 ? (this.nodeMap.put(n2.getCoordinate(), n2), n2) : (e2.mergeLabel(n2), e2);
        }
      }, print: function(t2) {
        for (var e2 = this.iterator(); e2.hasNext(); ) {
          var n2 = e2.next();
          n2.print(t2);
        }
      }, iterator: function() {
        return this.nodeMap.values().iterator();
      }, values: function() {
        return this.nodeMap.values();
      }, getBoundaryNodes: function(t2) {
        for (var e2 = new I(), n2 = this.iterator(); n2.hasNext(); ) {
          var i3 = n2.next();
          i3.getLabel().getLocation(t2) === L.BOUNDARY && e2.add(i3);
        }
        return e2;
      }, add: function(t2) {
        var e2 = t2.getCoordinate(), n2 = this.addNode(e2);
        n2.add(t2);
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return xn;
      } }), e(En.prototype, { compareDirection: function(t2) {
        return this.dx === t2.dx && this.dy === t2.dy ? 0 : this.quadrant > t2.quadrant ? 1 : this.quadrant < t2.quadrant ? -1 : he.computeOrientation(t2.p0, t2.p1, this.p1);
      }, getDy: function() {
        return this.dy;
      }, getCoordinate: function() {
        return this.p0;
      }, setNode: function(t2) {
        this.node = t2;
      }, print: function(t2) {
        var e2 = Math.atan2(this.dy, this.dx), n2 = this.getClass().getName(), i3 = n2.lastIndexOf("."), r2 = n2.substring(i3 + 1);
        t2.print("  " + r2 + ": " + this.p0 + " - " + this.p1 + " " + this.quadrant + ":" + e2 + "   " + this.label);
      }, compareTo: function(t2) {
        var e2 = t2;
        return this.compareDirection(e2);
      }, getDirectedCoordinate: function() {
        return this.p1;
      }, getDx: function() {
        return this.dx;
      }, getLabel: function() {
        return this.label;
      }, getEdge: function() {
        return this.edge;
      }, getQuadrant: function() {
        return this.quadrant;
      }, getNode: function() {
        return this.node;
      }, toString: function() {
        var t2 = Math.atan2(this.dy, this.dx), e2 = this.getClass().getName(), n2 = e2.lastIndexOf("."), i3 = e2.substring(n2 + 1);
        return "  " + i3 + ": " + this.p0 + " - " + this.p1 + " " + this.quadrant + ":" + t2 + "   " + this.label;
      }, computeLabel: function(t2) {
      }, init: function(t2, e2) {
        this.p0 = t2, this.p1 = e2, this.dx = e2.x - t2.x, this.dy = e2.y - t2.y, this.quadrant = Je.quadrant(this.dx, this.dy), f.isTrue(!(0 === this.dx && 0 === this.dy), "EdgeEnd with identical endpoints found");
      }, interfaces_: function() {
        return [s];
      }, getClass: function() {
        return En;
      } }), h(In, En), e(In.prototype, { getNextMin: function() {
        return this.nextMin;
      }, getDepth: function(t2) {
        return this.depth[t2];
      }, setVisited: function(t2) {
        this._isVisited = t2;
      }, computeDirectedLabel: function() {
        this.label = new gn(this.edge.getLabel()), this._isForward || this.label.flip();
      }, getNext: function() {
        return this.next;
      }, setDepth: function(t2, e2) {
        if (-999 !== this.depth[t2] && this.depth[t2] !== e2)
          throw new sn("assigned depths do not match", this.getCoordinate());
        this.depth[t2] = e2;
      }, isInteriorAreaEdge: function t2() {
        for (var t3 = true, e2 = 0; 2 > e2; e2++)
          this.label.isArea(e2) && this.label.getLocation(e2, cn.LEFT) === L.INTERIOR && this.label.getLocation(e2, cn.RIGHT) === L.INTERIOR || (t3 = false);
        return t3;
      }, setNextMin: function(t2) {
        this.nextMin = t2;
      }, print: function(t2) {
        En.prototype.print.call(this, t2), t2.print(" " + this.depth[cn.LEFT] + "/" + this.depth[cn.RIGHT]), t2.print(" (" + this.getDepthDelta() + ")"), this._isInResult && t2.print(" inResult");
      }, setMinEdgeRing: function(t2) {
        this.minEdgeRing = t2;
      }, isLineEdge: function() {
        var t2 = this.label.isLine(0) || this.label.isLine(1), e2 = !this.label.isArea(0) || this.label.allPositionsEqual(0, L.EXTERIOR), n2 = !this.label.isArea(1) || this.label.allPositionsEqual(1, L.EXTERIOR);
        return t2 && e2 && n2;
      }, setEdgeRing: function(t2) {
        this.edgeRing = t2;
      }, getMinEdgeRing: function() {
        return this.minEdgeRing;
      }, getDepthDelta: function() {
        var t2 = this.edge.getDepthDelta();
        return this._isForward || (t2 = -t2), t2;
      }, setInResult: function(t2) {
        this._isInResult = t2;
      }, getSym: function() {
        return this.sym;
      }, isForward: function() {
        return this._isForward;
      }, getEdge: function() {
        return this.edge;
      }, printEdge: function(t2) {
        this.print(t2), t2.print(" "), this._isForward ? this.edge.print(t2) : this.edge.printReverse(t2);
      }, setSym: function(t2) {
        this.sym = t2;
      }, setVisitedEdge: function(t2) {
        this.setVisited(t2), this.sym.setVisited(t2);
      }, setEdgeDepths: function(t2, e2) {
        var n2 = this.getEdge().getDepthDelta();
        this._isForward || (n2 = -n2);
        var i3 = 1;
        t2 === cn.LEFT && (i3 = -1);
        var r2 = cn.opposite(t2), s2 = n2 * i3, o2 = e2 + s2;
        this.setDepth(t2, e2), this.setDepth(r2, o2);
      }, getEdgeRing: function() {
        return this.edgeRing;
      }, isInResult: function() {
        return this._isInResult;
      }, setNext: function(t2) {
        this.next = t2;
      }, isVisited: function() {
        return this._isVisited;
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return In;
      } }), In.depthFactor = function(t2, e2) {
        return t2 === L.EXTERIOR && e2 === L.INTERIOR ? 1 : t2 === L.INTERIOR && e2 === L.EXTERIOR ? -1 : 0;
      }, e(Nn.prototype, { createNode: function(t2) {
        return new yn(t2, null);
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return Nn;
      } }), e(Cn.prototype, { printEdges: function(t2) {
        t2.println("Edges:");
        for (var e2 = 0; e2 < this.edges.size(); e2++) {
          t2.println("edge " + e2 + ":");
          var n2 = this.edges.get(e2);
          n2.print(t2), n2.eiList.print(t2);
        }
      }, find: function(t2) {
        return this.nodes.find(t2);
      }, addNode: function() {
        if (arguments[0] instanceof yn) {
          var t2 = arguments[0];
          return this.nodes.addNode(t2);
        }
        if (arguments[0] instanceof g) {
          var e2 = arguments[0];
          return this.nodes.addNode(e2);
        }
      }, getNodeIterator: function() {
        return this.nodes.iterator();
      }, linkResultDirectedEdges: function() {
        for (var t2 = this.nodes.iterator(); t2.hasNext(); ) {
          var e2 = t2.next();
          e2.getEdges().linkResultDirectedEdges();
        }
      }, debugPrintln: function(t2) {
        A.out.println(t2);
      }, isBoundaryNode: function(t2, e2) {
        var n2 = this.nodes.find(e2);
        if (null === n2)
          return false;
        var i3 = n2.getLabel();
        return null !== i3 && i3.getLocation(t2) === L.BOUNDARY;
      }, linkAllDirectedEdges: function() {
        for (var t2 = this.nodes.iterator(); t2.hasNext(); ) {
          var e2 = t2.next();
          e2.getEdges().linkAllDirectedEdges();
        }
      }, matchInSameDirection: function(t2, e2, n2, i3) {
        return t2.equals(n2) ? he.computeOrientation(t2, e2, i3) === he.COLLINEAR && Je.quadrant(t2, e2) === Je.quadrant(n2, i3) : false;
      }, getEdgeEnds: function() {
        return this.edgeEndList;
      }, debugPrint: function(t2) {
        A.out.print(t2);
      }, getEdgeIterator: function() {
        return this.edges.iterator();
      }, findEdgeInSameDirection: function(t2, e2) {
        for (var n2 = 0; n2 < this.edges.size(); n2++) {
          var i3 = this.edges.get(n2), r2 = i3.getCoordinates();
          if (this.matchInSameDirection(t2, e2, r2[0], r2[1]))
            return i3;
          if (this.matchInSameDirection(t2, e2, r2[r2.length - 1], r2[r2.length - 2]))
            return i3;
        }
        return null;
      }, insertEdge: function(t2) {
        this.edges.add(t2);
      }, findEdgeEnd: function(t2) {
        for (var e2 = this.getEdgeEnds().iterator(); e2.hasNext(); ) {
          var n2 = e2.next();
          if (n2.getEdge() === t2)
            return n2;
        }
        return null;
      }, addEdges: function(t2) {
        for (var e2 = t2.iterator(); e2.hasNext(); ) {
          var n2 = e2.next();
          this.edges.add(n2);
          var i3 = new In(n2, true), r2 = new In(n2, false);
          i3.setSym(r2), r2.setSym(i3), this.add(i3), this.add(r2);
        }
      }, add: function(t2) {
        this.nodes.add(t2), this.edgeEndList.add(t2);
      }, getNodes: function() {
        return this.nodes.values();
      }, findEdge: function(t2, e2) {
        for (var n2 = 0; n2 < this.edges.size(); n2++) {
          var i3 = this.edges.get(n2), r2 = i3.getCoordinates();
          if (t2.equals(r2[0]) && e2.equals(r2[1]))
            return i3;
        }
        return null;
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return Cn;
      } }), Cn.linkResultDirectedEdges = function(t2) {
        for (var e2 = t2.iterator(); e2.hasNext(); ) {
          var n2 = e2.next();
          n2.getEdges().linkResultDirectedEdges();
        }
      }, e(Sn.prototype, { sortShellsAndHoles: function(t2, e2, n2) {
        for (var i3 = t2.iterator(); i3.hasNext(); ) {
          var r2 = i3.next();
          r2.isHole() ? n2.add(r2) : e2.add(r2);
        }
      }, computePolygons: function(t2) {
        for (var e2 = new I(), n2 = t2.iterator(); n2.hasNext(); ) {
          var i3 = n2.next(), r2 = i3.toPolygon(this.geometryFactory);
          e2.add(r2);
        }
        return e2;
      }, placeFreeHoles: function(t2, e2) {
        for (var n2 = e2.iterator(); n2.hasNext(); ) {
          var i3 = n2.next();
          if (null === i3.getShell()) {
            var r2 = this.findEdgeRingContaining(i3, t2);
            if (null === r2)
              throw new sn("unable to assign hole to a shell", i3.getCoordinate(0));
            i3.setShell(r2);
          }
        }
      }, buildMinimalEdgeRings: function(t2, e2, n2) {
        for (var i3 = new I(), r2 = t2.iterator(); r2.hasNext(); ) {
          var s2 = r2.next();
          if (s2.getMaxNodeDegree() > 2) {
            s2.linkDirectedEdgesForMinimalEdgeRings();
            var o2 = s2.buildMinimalRings(), a2 = this.findShell(o2);
            null !== a2 ? (this.placePolygonHoles(a2, o2), e2.add(a2)) : n2.addAll(o2);
          } else
            i3.add(s2);
        }
        return i3;
      }, containsPoint: function(t2) {
        for (var e2 = this.shellList.iterator(); e2.hasNext(); ) {
          var n2 = e2.next();
          if (n2.containsPoint(t2))
            return true;
        }
        return false;
      }, buildMaximalEdgeRings: function(t2) {
        for (var e2 = new I(), n2 = t2.iterator(); n2.hasNext(); ) {
          var i3 = n2.next();
          if (i3.isInResult() && i3.getLabel().isArea() && null === i3.getEdgeRing()) {
            var r2 = new vn(i3, this.geometryFactory);
            e2.add(r2), r2.setInResult();
          }
        }
        return e2;
      }, placePolygonHoles: function(t2, e2) {
        for (var n2 = e2.iterator(); n2.hasNext(); ) {
          var i3 = n2.next();
          i3.isHole() && i3.setShell(t2);
        }
      }, getPolygons: function() {
        var t2 = this.computePolygons(this.shellList);
        return t2;
      }, findEdgeRingContaining: function(t2, e2) {
        for (var n2 = t2.getLinearRing(), i3 = n2.getEnvelopeInternal(), r2 = n2.getCoordinateN(0), s2 = null, o2 = null, a2 = e2.iterator(); a2.hasNext(); ) {
          var u2 = a2.next(), l2 = u2.getLinearRing(), h2 = l2.getEnvelopeInternal();
          null !== s2 && (o2 = s2.getLinearRing().getEnvelopeInternal());
          var c2 = false;
          h2.contains(i3) && he.isPointInRing(r2, l2.getCoordinates()) && (c2 = true), c2 && (null === s2 || o2.contains(h2)) && (s2 = u2);
        }
        return s2;
      }, findShell: function(t2) {
        for (var e2 = 0, n2 = null, i3 = t2.iterator(); i3.hasNext(); ) {
          var r2 = i3.next();
          r2.isHole() || (n2 = r2, e2++);
        }
        return f.isTrue(1 >= e2, "found two shells in MinimalEdgeRing list"), n2;
      }, add: function() {
        if (1 === arguments.length) {
          var t2 = arguments[0];
          this.add(t2.getEdgeEnds(), t2.getNodes());
        } else if (2 === arguments.length) {
          var e2 = arguments[0], n2 = arguments[1];
          Cn.linkResultDirectedEdges(n2);
          var i3 = this.buildMaximalEdgeRings(e2), r2 = new I(), s2 = this.buildMinimalEdgeRings(i3, this.shellList, r2);
          this.sortShellsAndHoles(s2, this.shellList, r2), this.placeFreeHoles(this.shellList, r2);
        }
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return Sn;
      } }), e(wn.prototype, { collectLines: function(t2) {
        for (var e2 = this.op.getGraph().getEdgeEnds().iterator(); e2.hasNext(); ) {
          var n2 = e2.next();
          this.collectLineEdge(n2, t2, this.lineEdgesList), this.collectBoundaryTouchEdge(n2, t2, this.lineEdgesList);
        }
      }, labelIsolatedLine: function(t2, e2) {
        var n2 = this.ptLocator.locate(t2.getCoordinate(), this.op.getArgGeometry(e2));
        t2.getLabel().setLocation(e2, n2);
      }, build: function(t2) {
        return this.findCoveredLineEdges(), this.collectLines(t2), this.buildLines(t2), this.resultLineList;
      }, collectLineEdge: function(t2, e2, n2) {
        var i3 = t2.getLabel(), r2 = t2.getEdge();
        t2.isLineEdge() && (t2.isVisited() || !ii.isResultOfOp(i3, e2) || r2.isCovered() || (n2.add(r2), t2.setVisitedEdge(true)));
      }, findCoveredLineEdges: function() {
        for (var t2 = this.op.getGraph().getNodes().iterator(); t2.hasNext(); ) {
          var e2 = t2.next();
          e2.getEdges().findCoveredLineEdges();
        }
        for (var n2 = this.op.getGraph().getEdgeEnds().iterator(); n2.hasNext(); ) {
          var i3 = n2.next(), r2 = i3.getEdge();
          if (i3.isLineEdge() && !r2.isCoveredSet()) {
            var s2 = this.op.isCoveredByA(i3.getCoordinate());
            r2.setCovered(s2);
          }
        }
      }, labelIsolatedLines: function(t2) {
        for (var e2 = t2.iterator(); e2.hasNext(); ) {
          var n2 = e2.next(), i3 = n2.getLabel();
          n2.isIsolated() && (i3.isNull(0) ? this.labelIsolatedLine(n2, 0) : this.labelIsolatedLine(n2, 1));
        }
      }, buildLines: function(t2) {
        for (var e2 = this.lineEdgesList.iterator(); e2.hasNext(); ) {
          var n2 = e2.next(), i3 = (n2.getLabel(), this.geometryFactory.createLineString(n2.getCoordinates()));
          this.resultLineList.add(i3), n2.setInResult(true);
        }
      }, collectBoundaryTouchEdge: function(t2, e2, n2) {
        var i3 = t2.getLabel();
        return t2.isLineEdge() ? null : t2.isVisited() ? null : t2.isInteriorAreaEdge() ? null : t2.getEdge().isInResult() ? null : (f.isTrue(!(t2.isInResult() || t2.getSym().isInResult()) || !t2.getEdge().isInResult()), void (ii.isResultOfOp(i3, e2) && e2 === ii.INTERSECTION && (n2.add(t2.getEdge()), t2.setVisitedEdge(true))));
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return wn;
      } }), e(Ln.prototype, { filterCoveredNodeToPoint: function(t2) {
        var e2 = t2.getCoordinate();
        if (!this.op.isCoveredByLA(e2)) {
          var n2 = this.geometryFactory.createPoint(e2);
          this.resultPointList.add(n2);
        }
      }, extractNonCoveredResultNodes: function(t2) {
        for (var e2 = this.op.getGraph().getNodes().iterator(); e2.hasNext(); ) {
          var n2 = e2.next();
          if (!(n2.isInResult() || n2.isIncidentEdgeInResult() || 0 !== n2.getEdges().getDegree() && t2 !== ii.INTERSECTION)) {
            var i3 = n2.getLabel();
            ii.isResultOfOp(i3, t2) && this.filterCoveredNodeToPoint(n2);
          }
        }
      }, build: function(t2) {
        return this.extractNonCoveredResultNodes(t2), this.resultPointList;
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return Ln;
      } }), e(Rn.prototype, { locate: function(t2) {
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return Rn;
      } }), e(Tn.prototype, { locate: function(t2) {
        return Tn.locate(t2, this.geom);
      }, interfaces_: function() {
        return [Rn];
      }, getClass: function() {
        return Tn;
      } }), Tn.isPointInRing = function(t2, e2) {
        return e2.getEnvelopeInternal().intersects(t2) ? he.isPointInRing(t2, e2.getCoordinates()) : false;
      }, Tn.containsPointInPolygon = function(t2, e2) {
        if (e2.isEmpty())
          return false;
        var n2 = e2.getExteriorRing();
        if (!Tn.isPointInRing(t2, n2))
          return false;
        for (var i3 = 0; i3 < e2.getNumInteriorRing(); i3++) {
          var r2 = e2.getInteriorRingN(i3);
          if (Tn.isPointInRing(t2, r2))
            return false;
        }
        return true;
      }, Tn.containsPoint = function(t2, e2) {
        if (e2 instanceof Tt)
          return Tn.containsPointInPolygon(t2, e2);
        if (e2 instanceof ft)
          for (var n2 = new Re(e2); n2.hasNext(); ) {
            var i3 = n2.next();
            if (i3 !== e2 && Tn.containsPoint(t2, i3))
              return true;
          }
        return false;
      }, Tn.locate = function(t2, e2) {
        return e2.isEmpty() ? L.EXTERIOR : Tn.containsPoint(t2, e2) ? L.INTERIOR : L.EXTERIOR;
      }, e(Pn.prototype, { getNextCW: function(t2) {
        this.getEdges();
        var e2 = this.edgeList.indexOf(t2), n2 = e2 - 1;
        return 0 === e2 && (n2 = this.edgeList.size() - 1), this.edgeList.get(n2);
      }, propagateSideLabels: function(t2) {
        for (var e2 = L.NONE, n2 = this.iterator(); n2.hasNext(); ) {
          var i3 = n2.next(), r2 = i3.getLabel();
          r2.isArea(t2) && r2.getLocation(t2, cn.LEFT) !== L.NONE && (e2 = r2.getLocation(t2, cn.LEFT));
        }
        if (e2 === L.NONE)
          return null;
        for (var s2 = e2, n2 = this.iterator(); n2.hasNext(); ) {
          var i3 = n2.next(), r2 = i3.getLabel();
          if (r2.getLocation(t2, cn.ON) === L.NONE && r2.setLocation(t2, cn.ON, s2), r2.isArea(t2)) {
            var o2 = r2.getLocation(t2, cn.LEFT), a2 = r2.getLocation(t2, cn.RIGHT);
            if (a2 !== L.NONE) {
              if (a2 !== s2)
                throw new sn("side location conflict", i3.getCoordinate());
              o2 === L.NONE && f.shouldNeverReachHere("found single null side (at " + i3.getCoordinate() + ")"), s2 = o2;
            } else
              f.isTrue(r2.getLocation(t2, cn.LEFT) === L.NONE, "found single null side"), r2.setLocation(t2, cn.RIGHT, s2), r2.setLocation(t2, cn.LEFT, s2);
          }
        }
      }, getCoordinate: function() {
        var t2 = this.iterator();
        if (!t2.hasNext())
          return null;
        var e2 = t2.next();
        return e2.getCoordinate();
      }, print: function(t2) {
        A.out.println("EdgeEndStar:   " + this.getCoordinate());
        for (var e2 = this.iterator(); e2.hasNext(); ) {
          var n2 = e2.next();
          n2.print(t2);
        }
      }, isAreaLabelsConsistent: function(t2) {
        return this.computeEdgeEndLabels(t2.getBoundaryNodeRule()), this.checkAreaLabelsConsistent(0);
      }, checkAreaLabelsConsistent: function(t2) {
        var e2 = this.getEdges();
        if (e2.size() <= 0)
          return true;
        var n2 = e2.size() - 1, i3 = e2.get(n2).getLabel(), r2 = i3.getLocation(t2, cn.LEFT);
        f.isTrue(r2 !== L.NONE, "Found unlabelled area edge");
        for (var s2 = r2, o2 = this.iterator(); o2.hasNext(); ) {
          var a2 = o2.next(), u2 = a2.getLabel();
          f.isTrue(u2.isArea(t2), "Found non-area edge");
          var l2 = u2.getLocation(t2, cn.LEFT), h2 = u2.getLocation(t2, cn.RIGHT);
          if (l2 === h2)
            return false;
          if (h2 !== s2)
            return false;
          s2 = l2;
        }
        return true;
      }, findIndex: function(t2) {
        this.iterator();
        for (var e2 = 0; e2 < this.edgeList.size(); e2++) {
          var n2 = this.edgeList.get(e2);
          if (n2 === t2)
            return e2;
        }
        return -1;
      }, iterator: function() {
        return this.getEdges().iterator();
      }, getEdges: function() {
        return null === this.edgeList && (this.edgeList = new I(this.edgeMap.values())), this.edgeList;
      }, getLocation: function(t2, e2, n2) {
        return this.ptInAreaLocation[t2] === L.NONE && (this.ptInAreaLocation[t2] = Tn.locate(e2, n2[t2].getGeometry())), this.ptInAreaLocation[t2];
      }, toString: function() {
        var t2 = new P();
        t2.append("EdgeEndStar:   " + this.getCoordinate()), t2.append("\n");
        for (var e2 = this.iterator(); e2.hasNext(); ) {
          var n2 = e2.next();
          t2.append(n2), t2.append("\n");
        }
        return t2.toString();
      }, computeEdgeEndLabels: function(t2) {
        for (var e2 = this.iterator(); e2.hasNext(); ) {
          var n2 = e2.next();
          n2.computeLabel(t2);
        }
      }, computeLabelling: function(t2) {
        this.computeEdgeEndLabels(t2[0].getBoundaryNodeRule()), this.propagateSideLabels(0), this.propagateSideLabels(1);
        for (var e2 = [false, false], n2 = this.iterator(); n2.hasNext(); )
          for (var i3 = n2.next(), r2 = i3.getLabel(), s2 = 0; 2 > s2; s2++)
            r2.isLine(s2) && r2.getLocation(s2) === L.BOUNDARY && (e2[s2] = true);
        for (var n2 = this.iterator(); n2.hasNext(); )
          for (var i3 = n2.next(), r2 = i3.getLabel(), s2 = 0; 2 > s2; s2++)
            if (r2.isAnyNull(s2)) {
              var o2 = L.NONE;
              if (e2[s2])
                o2 = L.EXTERIOR;
              else {
                var a2 = i3.getCoordinate();
                o2 = this.getLocation(s2, a2, t2);
              }
              r2.setAllLocationsIfNull(s2, o2);
            }
      }, getDegree: function() {
        return this.edgeMap.size();
      }, insertEdgeEnd: function(t2, e2) {
        this.edgeMap.put(t2, e2), this.edgeList = null;
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return Pn;
      } }), h(bn, Pn), e(bn.prototype, { linkResultDirectedEdges: function() {
        this.getResultAreaEdges();
        for (var t2 = null, e2 = null, n2 = this.SCANNING_FOR_INCOMING, i3 = 0; i3 < this.resultAreaEdgeList.size(); i3++) {
          var r2 = this.resultAreaEdgeList.get(i3), s2 = r2.getSym();
          if (r2.getLabel().isArea())
            switch (null === t2 && r2.isInResult() && (t2 = r2), n2) {
              case this.SCANNING_FOR_INCOMING:
                if (!s2.isInResult())
                  continue;
                e2 = s2, n2 = this.LINKING_TO_OUTGOING;
                break;
              case this.LINKING_TO_OUTGOING:
                if (!r2.isInResult())
                  continue;
                e2.setNext(r2), n2 = this.SCANNING_FOR_INCOMING;
            }
        }
        if (n2 === this.LINKING_TO_OUTGOING) {
          if (null === t2)
            throw new sn("no outgoing dirEdge found", this.getCoordinate());
          f.isTrue(t2.isInResult(), "unable to link last incoming dirEdge"), e2.setNext(t2);
        }
      }, insert: function(t2) {
        var e2 = t2;
        this.insertEdgeEnd(e2, e2);
      }, getRightmostEdge: function() {
        var t2 = this.getEdges(), e2 = t2.size();
        if (1 > e2)
          return null;
        var n2 = t2.get(0);
        if (1 === e2)
          return n2;
        var i3 = t2.get(e2 - 1), r2 = n2.getQuadrant(), s2 = i3.getQuadrant();
        if (Je.isNorthern(r2) && Je.isNorthern(s2))
          return n2;
        if (!Je.isNorthern(r2) && !Je.isNorthern(s2))
          return i3;
        return 0 !== n2.getDy() ? n2 : 0 !== i3.getDy() ? i3 : (f.shouldNeverReachHere("found two horizontal edges incident on node"), null);
      }, print: function(t2) {
        A.out.println("DirectedEdgeStar: " + this.getCoordinate());
        for (var e2 = this.iterator(); e2.hasNext(); ) {
          var n2 = e2.next();
          t2.print("out "), n2.print(t2), t2.println(), t2.print("in "), n2.getSym().print(t2), t2.println();
        }
      }, getResultAreaEdges: function() {
        if (null !== this.resultAreaEdgeList)
          return this.resultAreaEdgeList;
        this.resultAreaEdgeList = new I();
        for (var t2 = this.iterator(); t2.hasNext(); ) {
          var e2 = t2.next();
          (e2.isInResult() || e2.getSym().isInResult()) && this.resultAreaEdgeList.add(e2);
        }
        return this.resultAreaEdgeList;
      }, updateLabelling: function(t2) {
        for (var e2 = this.iterator(); e2.hasNext(); ) {
          var n2 = e2.next(), i3 = n2.getLabel();
          i3.setAllLocationsIfNull(0, t2.getLocation(0)), i3.setAllLocationsIfNull(1, t2.getLocation(1));
        }
      }, linkAllDirectedEdges: function() {
        this.getEdges();
        for (var t2 = null, e2 = null, n2 = this.edgeList.size() - 1; n2 >= 0; n2--) {
          var i3 = this.edgeList.get(n2), r2 = i3.getSym();
          null === e2 && (e2 = r2), null !== t2 && r2.setNext(t2), t2 = i3;
        }
        e2.setNext(t2);
      }, computeDepths: function() {
        if (1 === arguments.length) {
          var t2 = arguments[0], e2 = this.findIndex(t2), n2 = (t2.getLabel(), t2.getDepth(cn.LEFT)), i3 = t2.getDepth(cn.RIGHT), r2 = this.computeDepths(e2 + 1, this.edgeList.size(), n2), s2 = this.computeDepths(0, e2, r2);
          if (s2 !== i3)
            throw new sn("depth mismatch at " + t2.getCoordinate());
        } else if (3 === arguments.length) {
          for (var o2 = arguments[0], a2 = arguments[1], u2 = arguments[2], l2 = u2, h2 = o2; a2 > h2; h2++) {
            var c2 = this.edgeList.get(h2);
            c2.getLabel();
            c2.setEdgeDepths(cn.RIGHT, l2), l2 = c2.getDepth(cn.LEFT);
          }
          return l2;
        }
      }, mergeSymLabels: function() {
        for (var t2 = this.iterator(); t2.hasNext(); ) {
          var e2 = t2.next(), n2 = e2.getLabel();
          n2.merge(e2.getSym().getLabel());
        }
      }, linkMinimalDirectedEdges: function(t2) {
        for (var e2 = null, n2 = null, i3 = this.SCANNING_FOR_INCOMING, r2 = this.resultAreaEdgeList.size() - 1; r2 >= 0; r2--) {
          var s2 = this.resultAreaEdgeList.get(r2), o2 = s2.getSym();
          switch (null === e2 && s2.getEdgeRing() === t2 && (e2 = s2), i3) {
            case this.SCANNING_FOR_INCOMING:
              if (o2.getEdgeRing() !== t2)
                continue;
              n2 = o2, i3 = this.LINKING_TO_OUTGOING;
              break;
            case this.LINKING_TO_OUTGOING:
              if (s2.getEdgeRing() !== t2)
                continue;
              n2.setNextMin(s2), i3 = this.SCANNING_FOR_INCOMING;
          }
        }
        i3 === this.LINKING_TO_OUTGOING && (f.isTrue(null !== e2, "found null for first outgoing dirEdge"), f.isTrue(e2.getEdgeRing() === t2, "unable to link last incoming dirEdge"), n2.setNextMin(e2));
      }, getOutgoingDegree: function() {
        if (0 === arguments.length) {
          for (var t2 = 0, e2 = this.iterator(); e2.hasNext(); ) {
            var n2 = e2.next();
            n2.isInResult() && t2++;
          }
          return t2;
        }
        if (1 === arguments.length) {
          for (var i3 = arguments[0], t2 = 0, e2 = this.iterator(); e2.hasNext(); ) {
            var n2 = e2.next();
            n2.getEdgeRing() === i3 && t2++;
          }
          return t2;
        }
      }, getLabel: function() {
        return this.label;
      }, findCoveredLineEdges: function() {
        for (var t2 = L.NONE, e2 = this.iterator(); e2.hasNext(); ) {
          var n2 = e2.next(), i3 = n2.getSym();
          if (!n2.isLineEdge()) {
            if (n2.isInResult()) {
              t2 = L.INTERIOR;
              break;
            }
            if (i3.isInResult()) {
              t2 = L.EXTERIOR;
              break;
            }
          }
        }
        if (t2 === L.NONE)
          return null;
        for (var r2 = t2, e2 = this.iterator(); e2.hasNext(); ) {
          var n2 = e2.next(), i3 = n2.getSym();
          n2.isLineEdge() ? n2.getEdge().setCovered(r2 === L.INTERIOR) : (n2.isInResult() && (r2 = L.EXTERIOR), i3.isInResult() && (r2 = L.INTERIOR));
        }
      }, computeLabelling: function(t2) {
        Pn.prototype.computeLabelling.call(this, t2), this.label = new gn(L.NONE);
        for (var e2 = this.iterator(); e2.hasNext(); )
          for (var n2 = e2.next(), i3 = n2.getEdge(), r2 = i3.getLabel(), s2 = 0; 2 > s2; s2++) {
            var o2 = r2.getLocation(s2);
            o2 !== L.INTERIOR && o2 !== L.BOUNDARY || this.label.setLocation(s2, L.INTERIOR);
          }
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return bn;
      } }), h(On, Nn), e(On.prototype, { createNode: function(t2) {
        return new yn(t2, new bn());
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return On;
      } }), e(_n.prototype, { computeIntersections: function(t2, e2) {
        this.mce.computeIntersectsForChain(this.chainIndex, t2.mce, t2.chainIndex, e2);
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return _n;
      } }), e(Mn.prototype, { isDelete: function() {
        return this.eventType === Mn.DELETE;
      }, setDeleteEventIndex: function(t2) {
        this.deleteEventIndex = t2;
      }, getObject: function() {
        return this.obj;
      }, compareTo: function(t2) {
        var e2 = t2;
        return this.xValue < e2.xValue ? -1 : this.xValue > e2.xValue ? 1 : this.eventType < e2.eventType ? -1 : this.eventType > e2.eventType ? 1 : 0;
      }, getInsertEvent: function() {
        return this.insertEvent;
      }, isInsert: function() {
        return this.eventType === Mn.INSERT;
      }, isSameLabel: function(t2) {
        return null === this.label ? false : this.label === t2.label;
      }, getDeleteEventIndex: function() {
        return this.deleteEventIndex;
      }, interfaces_: function() {
        return [s];
      }, getClass: function() {
        return Mn;
      } }), Mn.INSERT = 1, Mn.DELETE = 2, e(Dn.prototype, { interfaces_: function() {
        return [];
      }, getClass: function() {
        return Dn;
      } }), e(An.prototype, { isTrivialIntersection: function(t2, e2, n2, i3) {
        if (t2 === n2 && 1 === this.li.getIntersectionNum()) {
          if (An.isAdjacentSegments(e2, i3))
            return true;
          if (t2.isClosed()) {
            var r2 = t2.getNumPoints() - 1;
            if (0 === e2 && i3 === r2 || 0 === i3 && e2 === r2)
              return true;
          }
        }
        return false;
      }, getProperIntersectionPoint: function() {
        return this.properIntersectionPoint;
      }, setIsDoneIfProperInt: function(t2) {
        this.isDoneWhenProperInt = t2;
      }, hasProperInteriorIntersection: function() {
        return this.hasProperInterior;
      }, isBoundaryPointInternal: function(t2, e2) {
        for (var n2 = e2.iterator(); n2.hasNext(); ) {
          var i3 = n2.next(), r2 = i3.getCoordinate();
          if (t2.isIntersection(r2))
            return true;
        }
        return false;
      }, hasProperIntersection: function() {
        return this.hasProper;
      }, hasIntersection: function() {
        return this._hasIntersection;
      }, isDone: function() {
        return this._isDone;
      }, isBoundaryPoint: function(t2, e2) {
        return null === e2 ? false : this.isBoundaryPointInternal(t2, e2[0]) ? true : !!this.isBoundaryPointInternal(t2, e2[1]);
      }, setBoundaryNodes: function(t2, e2) {
        this.bdyNodes = new Array(2).fill(null), this.bdyNodes[0] = t2, this.bdyNodes[1] = e2;
      }, addIntersections: function(t2, e2, n2, i3) {
        if (t2 === n2 && e2 === i3)
          return null;
        this.numTests++;
        var r2 = t2.getCoordinates()[e2], s2 = t2.getCoordinates()[e2 + 1], o2 = n2.getCoordinates()[i3], a2 = n2.getCoordinates()[i3 + 1];
        this.li.computeIntersection(r2, s2, o2, a2), this.li.hasIntersection() && (this.recordIsolated && (t2.setIsolated(false), n2.setIsolated(false)), this.numIntersections++, this.isTrivialIntersection(t2, e2, n2, i3) || (this._hasIntersection = true, !this.includeProper && this.li.isProper() || (t2.addIntersections(this.li, e2, 0), n2.addIntersections(this.li, i3, 1)), this.li.isProper() && (this.properIntersectionPoint = this.li.getIntersection(0).copy(), this.hasProper = true, this.isDoneWhenProperInt && (this._isDone = true), this.isBoundaryPoint(this.li, this.bdyNodes) || (this.hasProperInterior = true))));
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return An;
      } }), An.isAdjacentSegments = function(t2, e2) {
        return 1 === Math.abs(t2 - e2);
      }, h(Fn, Dn), e(Fn.prototype, { prepareEvents: function() {
        ho.sort(this.events);
        for (var t2 = 0; t2 < this.events.size(); t2++) {
          var e2 = this.events.get(t2);
          e2.isDelete() && e2.getInsertEvent().setDeleteEventIndex(t2);
        }
      }, computeIntersections: function() {
        if (1 === arguments.length) {
          var t2 = arguments[0];
          this.nOverlaps = 0, this.prepareEvents();
          for (var e2 = 0; e2 < this.events.size(); e2++) {
            var n2 = this.events.get(e2);
            if (n2.isInsert() && this.processOverlaps(e2, n2.getDeleteEventIndex(), n2, t2), t2.isDone())
              break;
          }
        } else if (3 === arguments.length) {
          if (arguments[2] instanceof An && R(arguments[0], y) && R(arguments[1], y)) {
            var i3 = arguments[0], r2 = arguments[1], s2 = arguments[2];
            this.addEdges(i3, i3), this.addEdges(r2, r2), this.computeIntersections(s2);
          } else if ("boolean" == typeof arguments[2] && R(arguments[0], y) && arguments[1] instanceof An) {
            var o2 = arguments[0], a2 = arguments[1], u2 = arguments[2];
            u2 ? this.addEdges(o2, null) : this.addEdges(o2), this.computeIntersections(a2);
          }
        }
      }, addEdge: function(t2, e2) {
        for (var n2 = t2.getMonotoneChainEdge(), i3 = n2.getStartIndexes(), r2 = 0; r2 < i3.length - 1; r2++) {
          var s2 = new _n(n2, r2), o2 = new Mn(e2, n2.getMinX(r2), s2);
          this.events.add(o2), this.events.add(new Mn(n2.getMaxX(r2), o2));
        }
      }, processOverlaps: function(t2, e2, n2, i3) {
        for (var r2 = n2.getObject(), s2 = t2; e2 > s2; s2++) {
          var o2 = this.events.get(s2);
          if (o2.isInsert()) {
            var a2 = o2.getObject();
            n2.isSameLabel(o2) || (r2.computeIntersections(a2, i3), this.nOverlaps++);
          }
        }
      }, addEdges: function() {
        if (1 === arguments.length)
          for (var t2 = arguments[0], e2 = t2.iterator(); e2.hasNext(); ) {
            var n2 = e2.next();
            this.addEdge(n2, n2);
          }
        else if (2 === arguments.length)
          for (var i3 = arguments[0], r2 = arguments[1], e2 = i3.iterator(); e2.hasNext(); ) {
            var n2 = e2.next();
            this.addEdge(n2, r2);
          }
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return Fn;
      } }), e(Gn.prototype, { getMin: function() {
        return this.min;
      }, intersects: function(t2, e2) {
        return !(this.min > e2 || this.max < t2);
      }, getMax: function() {
        return this.max;
      }, toString: function() {
        return se.toLineString(new g(this.min, 0), new g(this.max, 0));
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return Gn;
      } }), e(qn.prototype, { compare: function(t2, e2) {
        var n2 = t2, i3 = e2, r2 = (n2.min + n2.max) / 2, s2 = (i3.min + i3.max) / 2;
        return s2 > r2 ? -1 : r2 > s2 ? 1 : 0;
      }, interfaces_: function() {
        return [a];
      }, getClass: function() {
        return qn;
      } }), Gn.NodeComparator = qn, h(Bn, Gn), e(Bn.prototype, { query: function(t2, e2, n2) {
        return this.intersects(t2, e2) ? void n2.visitItem(this.item) : null;
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return Bn;
      } }), h(zn, Gn), e(zn.prototype, { buildExtent: function(t2, e2) {
        this.min = Math.min(t2.min, e2.min), this.max = Math.max(t2.max, e2.max);
      }, query: function(t2, e2, n2) {
        return this.intersects(t2, e2) ? (null !== this.node1 && this.node1.query(t2, e2, n2), void (null !== this.node2 && this.node2.query(t2, e2, n2))) : null;
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return zn;
      } }), e(Vn.prototype, { buildTree: function() {
        ho.sort(this.leaves, new IntervalRTreeNode.NodeComparator());
        for (var t2 = this.leaves, e2 = null, n2 = new I(); ; ) {
          if (this.buildLevel(t2, n2), 1 === n2.size())
            return n2.get(0);
          e2 = t2, t2 = n2, n2 = e2;
        }
      }, insert: function(t2, e2, n2) {
        if (null !== this.root)
          throw new IllegalStateException("Index cannot be added to once it has been queried");
        this.leaves.add(new Bn(t2, e2, n2));
      }, query: function(t2, e2, n2) {
        this.init(), this.root.query(t2, e2, n2);
      }, buildRoot: function() {
        return null !== this.root ? null : void (this.root = this.buildTree());
      }, printNode: function(t2) {
        A.out.println(se.toLineString(new g(t2.min, this.level), new g(t2.max, this.level)));
      }, init: function() {
        return null !== this.root ? null : void this.buildRoot();
      }, buildLevel: function(t2, e2) {
        this.level++, e2.clear();
        for (var n2 = 0; n2 < t2.size(); n2 += 2) {
          var i3 = t2.get(n2), r2 = n2 + 1 < t2.size() ? t2.get(n2) : null;
          if (null === r2)
            e2.add(i3);
          else {
            var s2 = new zn(t2.get(n2), t2.get(n2 + 1));
            e2.add(s2);
          }
        }
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return Vn;
      } }), e(kn.prototype, { filter: function(t2) {
        if (this.isForcedToLineString && t2 instanceof bt) {
          var e2 = t2.getFactory().createLineString(t2.getCoordinateSequence());
          return this.lines.add(e2), null;
        }
        t2 instanceof St && this.lines.add(t2);
      }, setForceToLineString: function(t2) {
        this.isForcedToLineString = t2;
      }, interfaces_: function() {
        return [q];
      }, getClass: function() {
        return kn;
      } }), kn.getGeometry = function() {
        if (1 === arguments.length) {
          var t2 = arguments[0];
          return t2.getFactory().buildGeometry(kn.getLines(t2));
        }
        if (2 === arguments.length) {
          var e2 = arguments[0], n2 = arguments[1];
          return e2.getFactory().buildGeometry(kn.getLines(e2, n2));
        }
      }, kn.getLines = function() {
        if (1 === arguments.length) {
          var t2 = arguments[0];
          return kn.getLines(t2, false);
        }
        if (2 === arguments.length) {
          if (R(arguments[0], v) && R(arguments[1], v)) {
            for (var e2 = arguments[0], n2 = arguments[1], i3 = e2.iterator(); i3.hasNext(); ) {
              var r2 = i3.next();
              kn.getLines(r2, n2);
            }
            return n2;
          }
          if (arguments[0] instanceof B && "boolean" == typeof arguments[1]) {
            var s2 = arguments[0], o2 = arguments[1], a2 = new I();
            return s2.apply(new kn(a2, o2)), a2;
          }
          if (arguments[0] instanceof B && R(arguments[1], v)) {
            var u2 = arguments[0], l2 = arguments[1];
            return u2 instanceof St ? l2.add(u2) : u2.apply(new kn(l2)), l2;
          }
        } else if (3 === arguments.length) {
          if ("boolean" == typeof arguments[2] && R(arguments[0], v) && R(arguments[1], v)) {
            for (var h2 = arguments[0], c2 = arguments[1], f2 = arguments[2], i3 = h2.iterator(); i3.hasNext(); ) {
              var r2 = i3.next();
              kn.getLines(r2, c2, f2);
            }
            return c2;
          }
          if ("boolean" == typeof arguments[2] && arguments[0] instanceof B && R(arguments[1], v)) {
            var g2 = arguments[0], d2 = arguments[1], p2 = arguments[2];
            return g2.apply(new kn(d2, p2)), d2;
          }
        }
      }, e(Yn.prototype, { visitItem: function(t2) {
        this.items.add(t2);
      }, getItems: function() {
        return this.items;
      }, interfaces_: function() {
        return [Ae];
      }, getClass: function() {
        return Yn;
      } }), e(Un.prototype, { locate: function(t2) {
        var e2 = new le(t2), n2 = new Xn(e2);
        return this.index.query(t2.y, t2.y, n2), e2.getLocation();
      }, interfaces_: function() {
        return [Rn];
      }, getClass: function() {
        return Un;
      } }), e(Xn.prototype, { visitItem: function(t2) {
        var e2 = t2;
        this.counter.countSegment(e2.getCoordinate(0), e2.getCoordinate(1));
      }, interfaces_: function() {
        return [Ae];
      }, getClass: function() {
        return Xn;
      } }), e(Hn.prototype, { init: function(t2) {
        for (var e2 = kn.getLines(t2), n2 = e2.iterator(); n2.hasNext(); ) {
          var i3 = n2.next(), r2 = i3.getCoordinates();
          this.addLine(r2);
        }
      }, addLine: function(t2) {
        for (var e2 = 1; e2 < t2.length; e2++) {
          var n2 = new ce(t2[e2 - 1], t2[e2]), i3 = Math.min(n2.p0.y, n2.p1.y), r2 = Math.max(n2.p0.y, n2.p1.y);
          this.index.insert(i3, r2, n2);
        }
      }, query: function() {
        if (2 === arguments.length) {
          var t2 = arguments[0], e2 = arguments[1], n2 = new Yn();
          return this.index.query(t2, e2, n2), n2.getItems();
        }
        if (3 === arguments.length) {
          var i3 = arguments[0], r2 = arguments[1], s2 = arguments[2];
          this.index.query(i3, r2, s2);
        }
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return Hn;
      } }), Un.SegmentVisitor = Xn, Un.IntervalIndexedGeometry = Hn, e(Wn.prototype, { getSegmentIndex: function() {
        return this.segmentIndex;
      }, getCoordinate: function() {
        return this.coord;
      }, print: function(t2) {
        t2.print(this.coord), t2.print(" seg # = " + this.segmentIndex), t2.println(" dist = " + this.dist);
      }, compareTo: function(t2) {
        var e2 = t2;
        return this.compare(e2.segmentIndex, e2.dist);
      }, isEndPoint: function(t2) {
        return 0 === this.segmentIndex && 0 === this.dist ? true : this.segmentIndex === t2;
      }, toString: function() {
        return this.coord + " seg # = " + this.segmentIndex + " dist = " + this.dist;
      }, getDistance: function() {
        return this.dist;
      }, compare: function(t2, e2) {
        return this.segmentIndex < t2 ? -1 : this.segmentIndex > t2 ? 1 : this.dist < e2 ? -1 : this.dist > e2 ? 1 : 0;
      }, interfaces_: function() {
        return [s];
      }, getClass: function() {
        return Wn;
      } }), e(jn.prototype, { print: function(t2) {
        t2.println("Intersections:");
        for (var e2 = this.iterator(); e2.hasNext(); ) {
          var n2 = e2.next();
          n2.print(t2);
        }
      }, iterator: function() {
        return this.nodeMap.values().iterator();
      }, addSplitEdges: function(t2) {
        this.addEndpoints();
        for (var e2 = this.iterator(), n2 = e2.next(); e2.hasNext(); ) {
          var i3 = e2.next(), r2 = this.createSplitEdge(n2, i3);
          t2.add(r2), n2 = i3;
        }
      }, addEndpoints: function() {
        var t2 = this.edge.pts.length - 1;
        this.add(this.edge.pts[0], 0, 0), this.add(this.edge.pts[t2], t2, 0);
      }, createSplitEdge: function(t2, e2) {
        var n2 = e2.segmentIndex - t2.segmentIndex + 2, i3 = this.edge.pts[e2.segmentIndex], r2 = e2.dist > 0 || !e2.coord.equals2D(i3);
        r2 || n2--;
        var s2 = new Array(n2).fill(null), o2 = 0;
        s2[o2++] = new g(t2.coord);
        for (var a2 = t2.segmentIndex + 1; a2 <= e2.segmentIndex; a2++)
          s2[o2++] = this.edge.pts[a2];
        return r2 && (s2[o2] = e2.coord), new Jn(s2, new gn(this.edge.label));
      }, add: function(t2, e2, n2) {
        var i3 = new Wn(t2, e2, n2), r2 = this.nodeMap.get(i3);
        return null !== r2 ? r2 : (this.nodeMap.put(i3, i3), i3);
      }, isIntersection: function(t2) {
        for (var e2 = this.iterator(); e2.hasNext(); ) {
          var n2 = e2.next();
          if (n2.coord.equals(t2))
            return true;
        }
        return false;
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return jn;
      } }), e(Kn.prototype, { getChainStartIndices: function(t2) {
        var e2 = 0, n2 = new I();
        n2.add(new b(e2));
        do {
          var i3 = this.findChainEnd(t2, e2);
          n2.add(new b(i3)), e2 = i3;
        } while (e2 < t2.length - 1);
        var r2 = Kn.toIntArray(n2);
        return r2;
      }, findChainEnd: function(t2, e2) {
        for (var n2 = Je.quadrant(t2[e2], t2[e2 + 1]), i3 = e2 + 1; i3 < t2.length; ) {
          var r2 = Je.quadrant(t2[i3 - 1], t2[i3]);
          if (r2 !== n2)
            break;
          i3++;
        }
        return i3 - 1;
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return Kn;
      } }), Kn.toIntArray = function(t2) {
        for (var e2 = new Array(t2.size()).fill(null), n2 = 0; n2 < e2.length; n2++)
          e2[n2] = t2.get(n2).intValue();
        return e2;
      }, e(Zn.prototype, { getCoordinates: function() {
        return this.pts;
      }, getMaxX: function(t2) {
        var e2 = this.pts[this.startIndex[t2]].x, n2 = this.pts[this.startIndex[t2 + 1]].x;
        return e2 > n2 ? e2 : n2;
      }, getMinX: function(t2) {
        var e2 = this.pts[this.startIndex[t2]].x, n2 = this.pts[this.startIndex[t2 + 1]].x;
        return n2 > e2 ? e2 : n2;
      }, computeIntersectsForChain: function() {
        if (4 === arguments.length) {
          var t2 = arguments[0], e2 = arguments[1], n2 = arguments[2], i3 = arguments[3];
          this.computeIntersectsForChain(this.startIndex[t2], this.startIndex[t2 + 1], e2, e2.startIndex[n2], e2.startIndex[n2 + 1], i3);
        } else if (6 === arguments.length) {
          var r2 = arguments[0], s2 = arguments[1], o2 = arguments[2], a2 = arguments[3], u2 = arguments[4], l2 = arguments[5], h2 = this.pts[r2], c2 = this.pts[s2], f2 = o2.pts[a2], g2 = o2.pts[u2];
          if (s2 - r2 === 1 && u2 - a2 === 1)
            return l2.addIntersections(this.e, r2, o2.e, a2), null;
          if (this.env1.init(h2, c2), this.env2.init(f2, g2), !this.env1.intersects(this.env2))
            return null;
          var d2 = Math.trunc((r2 + s2) / 2), p2 = Math.trunc((a2 + u2) / 2);
          d2 > r2 && (p2 > a2 && this.computeIntersectsForChain(r2, d2, o2, a2, p2, l2), u2 > p2 && this.computeIntersectsForChain(r2, d2, o2, p2, u2, l2)), s2 > d2 && (p2 > a2 && this.computeIntersectsForChain(d2, s2, o2, a2, p2, l2), u2 > p2 && this.computeIntersectsForChain(d2, s2, o2, p2, u2, l2));
        }
      }, getStartIndexes: function() {
        return this.startIndex;
      }, computeIntersects: function(t2, e2) {
        for (var n2 = 0; n2 < this.startIndex.length - 1; n2++)
          for (var i3 = 0; i3 < t2.startIndex.length - 1; i3++)
            this.computeIntersectsForChain(n2, t2, i3, e2);
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return Zn;
      } }), e(Qn.prototype, { getDepth: function(t2, e2) {
        return this.depth[t2][e2];
      }, setDepth: function(t2, e2, n2) {
        this.depth[t2][e2] = n2;
      }, isNull: function() {
        if (0 === arguments.length) {
          for (var t2 = 0; 2 > t2; t2++)
            for (var e2 = 0; 3 > e2; e2++)
              if (this.depth[t2][e2] !== Qn.NULL_VALUE)
                return false;
          return true;
        }
        if (1 === arguments.length) {
          var n2 = arguments[0];
          return this.depth[n2][1] === Qn.NULL_VALUE;
        }
        if (2 === arguments.length) {
          var i3 = arguments[0], r2 = arguments[1];
          return this.depth[i3][r2] === Qn.NULL_VALUE;
        }
      }, normalize: function() {
        for (var t2 = 0; 2 > t2; t2++)
          if (!this.isNull(t2)) {
            var e2 = this.depth[t2][1];
            this.depth[t2][2] < e2 && (e2 = this.depth[t2][2]), 0 > e2 && (e2 = 0);
            for (var n2 = 1; 3 > n2; n2++) {
              var i3 = 0;
              this.depth[t2][n2] > e2 && (i3 = 1), this.depth[t2][n2] = i3;
            }
          }
      }, getDelta: function(t2) {
        return this.depth[t2][cn.RIGHT] - this.depth[t2][cn.LEFT];
      }, getLocation: function(t2, e2) {
        return this.depth[t2][e2] <= 0 ? L.EXTERIOR : L.INTERIOR;
      }, toString: function() {
        return "A: " + this.depth[0][1] + "," + this.depth[0][2] + " B: " + this.depth[1][1] + "," + this.depth[1][2];
      }, add: function() {
        if (1 === arguments.length)
          for (var t2 = arguments[0], e2 = 0; 2 > e2; e2++)
            for (var n2 = 1; 3 > n2; n2++) {
              var i3 = t2.getLocation(e2, n2);
              i3 !== L.EXTERIOR && i3 !== L.INTERIOR || (this.isNull(e2, n2) ? this.depth[e2][n2] = Qn.depthAtLocation(i3) : this.depth[e2][n2] += Qn.depthAtLocation(i3));
            }
        else if (3 === arguments.length) {
          var r2 = arguments[0], s2 = arguments[1], o2 = arguments[2];
          o2 === L.INTERIOR && this.depth[r2][s2]++;
        }
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return Qn;
      } }), Qn.depthAtLocation = function(t2) {
        return t2 === L.EXTERIOR ? 0 : t2 === L.INTERIOR ? 1 : Qn.NULL_VALUE;
      }, Qn.NULL_VALUE = -1, h(Jn, mn), e(Jn.prototype, { getDepth: function() {
        return this.depth;
      }, getCollapsedEdge: function() {
        var t2 = new Array(2).fill(null);
        t2[0] = this.pts[0], t2[1] = this.pts[1];
        var e2 = new Jn(t2, gn.toLineLabel(this.label));
        return e2;
      }, isIsolated: function() {
        return this._isIsolated;
      }, getCoordinates: function() {
        return this.pts;
      }, setIsolated: function(t2) {
        this._isIsolated = t2;
      }, setName: function(t2) {
        this.name = t2;
      }, equals: function(t2) {
        if (!(t2 instanceof Jn))
          return false;
        var e2 = t2;
        if (this.pts.length !== e2.pts.length)
          return false;
        for (var n2 = true, i3 = true, r2 = this.pts.length, s2 = 0; s2 < this.pts.length; s2++)
          if (this.pts[s2].equals2D(e2.pts[s2]) || (n2 = false), this.pts[s2].equals2D(e2.pts[--r2]) || (i3 = false), !n2 && !i3)
            return false;
        return true;
      }, getCoordinate: function() {
        if (0 === arguments.length)
          return this.pts.length > 0 ? this.pts[0] : null;
        if (1 === arguments.length) {
          var t2 = arguments[0];
          return this.pts[t2];
        }
      }, print: function(t2) {
        t2.print("edge " + this.name + ": "), t2.print("LINESTRING (");
        for (var e2 = 0; e2 < this.pts.length; e2++)
          e2 > 0 && t2.print(","), t2.print(this.pts[e2].x + " " + this.pts[e2].y);
        t2.print(")  " + this.label + " " + this.depthDelta);
      }, computeIM: function(t2) {
        Jn.updateIM(this.label, t2);
      }, isCollapsed: function() {
        return this.label.isArea() ? 3 !== this.pts.length ? false : !!this.pts[0].equals(this.pts[2]) : false;
      }, isClosed: function() {
        return this.pts[0].equals(this.pts[this.pts.length - 1]);
      }, getMaximumSegmentIndex: function() {
        return this.pts.length - 1;
      }, getDepthDelta: function() {
        return this.depthDelta;
      }, getNumPoints: function() {
        return this.pts.length;
      }, printReverse: function(t2) {
        t2.print("edge " + this.name + ": ");
        for (var e2 = this.pts.length - 1; e2 >= 0; e2--)
          t2.print(this.pts[e2] + " ");
        t2.println("");
      }, getMonotoneChainEdge: function() {
        return null === this.mce && (this.mce = new Zn(this)), this.mce;
      }, getEnvelope: function() {
        if (null === this.env) {
          this.env = new C();
          for (var t2 = 0; t2 < this.pts.length; t2++)
            this.env.expandToInclude(this.pts[t2]);
        }
        return this.env;
      }, addIntersection: function(t2, e2, n2, i3) {
        var r2 = new g(t2.getIntersection(i3)), s2 = e2, o2 = t2.getEdgeDistance(n2, i3), a2 = s2 + 1;
        if (a2 < this.pts.length) {
          var u2 = this.pts[a2];
          r2.equals2D(u2) && (s2 = a2, o2 = 0);
        }
        this.eiList.add(r2, s2, o2);
      }, toString: function() {
        var t2 = new P();
        t2.append("edge " + this.name + ": "), t2.append("LINESTRING (");
        for (var e2 = 0; e2 < this.pts.length; e2++)
          e2 > 0 && t2.append(","), t2.append(this.pts[e2].x + " " + this.pts[e2].y);
        return t2.append(")  " + this.label + " " + this.depthDelta), t2.toString();
      }, isPointwiseEqual: function(t2) {
        if (this.pts.length !== t2.pts.length)
          return false;
        for (var e2 = 0; e2 < this.pts.length; e2++)
          if (!this.pts[e2].equals2D(t2.pts[e2]))
            return false;
        return true;
      }, setDepthDelta: function(t2) {
        this.depthDelta = t2;
      }, getEdgeIntersectionList: function() {
        return this.eiList;
      }, addIntersections: function(t2, e2, n2) {
        for (var i3 = 0; i3 < t2.getIntersectionNum(); i3++)
          this.addIntersection(t2, e2, n2, i3);
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return Jn;
      } }), Jn.updateIM = function() {
        if (2 !== arguments.length)
          return mn.prototype.updateIM.apply(this, arguments);
        var t2 = arguments[0], e2 = arguments[1];
        e2.setAtLeastIfValid(t2.getLocation(0, cn.ON), t2.getLocation(1, cn.ON), 1), t2.isArea() && (e2.setAtLeastIfValid(t2.getLocation(0, cn.LEFT), t2.getLocation(1, cn.LEFT), 2), e2.setAtLeastIfValid(t2.getLocation(0, cn.RIGHT), t2.getLocation(1, cn.RIGHT), 2));
      }, h($n, Cn), e($n.prototype, { insertBoundaryPoint: function(t2, e2) {
        var n2 = this.nodes.addNode(e2), i3 = n2.getLabel(), r2 = 1, s2 = L.NONE;
        s2 = i3.getLocation(t2, cn.ON), s2 === L.BOUNDARY && r2++;
        var o2 = $n.determineBoundary(this.boundaryNodeRule, r2);
        i3.setLocation(t2, o2);
      }, computeSelfNodes: function() {
        if (2 === arguments.length) {
          var t2 = arguments[0], e2 = arguments[1];
          return this.computeSelfNodes(t2, e2, false);
        }
        if (3 === arguments.length) {
          var n2 = arguments[0], i3 = arguments[1], r2 = arguments[2], s2 = new An(n2, true, false);
          s2.setIsDoneIfProperInt(r2);
          var o2 = this.createEdgeSetIntersector(), a2 = this.parentGeom instanceof bt || this.parentGeom instanceof Tt || this.parentGeom instanceof Ot, u2 = i3 || !a2;
          return o2.computeIntersections(this.edges, s2, u2), this.addSelfIntersectionNodes(this.argIndex), s2;
        }
      }, computeSplitEdges: function(t2) {
        for (var e2 = this.edges.iterator(); e2.hasNext(); ) {
          var n2 = e2.next();
          n2.eiList.addSplitEdges(t2);
        }
      }, computeEdgeIntersections: function(t2, e2, n2) {
        var i3 = new An(e2, n2, true);
        i3.setBoundaryNodes(this.getBoundaryNodes(), t2.getBoundaryNodes());
        var r2 = this.createEdgeSetIntersector();
        return r2.computeIntersections(this.edges, t2.edges, i3), i3;
      }, getGeometry: function() {
        return this.parentGeom;
      }, getBoundaryNodeRule: function() {
        return this.boundaryNodeRule;
      }, hasTooFewPoints: function() {
        return this._hasTooFewPoints;
      }, addPoint: function() {
        if (arguments[0] instanceof Lt) {
          var t2 = arguments[0], e2 = t2.getCoordinate();
          this.insertPoint(this.argIndex, e2, L.INTERIOR);
        } else if (arguments[0] instanceof g) {
          var n2 = arguments[0];
          this.insertPoint(this.argIndex, n2, L.INTERIOR);
        }
      }, addPolygon: function(t2) {
        this.addPolygonRing(t2.getExteriorRing(), L.EXTERIOR, L.INTERIOR);
        for (var e2 = 0; e2 < t2.getNumInteriorRing(); e2++) {
          var n2 = t2.getInteriorRingN(e2);
          this.addPolygonRing(n2, L.INTERIOR, L.EXTERIOR);
        }
      }, addEdge: function(t2) {
        this.insertEdge(t2);
        var e2 = t2.getCoordinates();
        this.insertPoint(this.argIndex, e2[0], L.BOUNDARY), this.insertPoint(this.argIndex, e2[e2.length - 1], L.BOUNDARY);
      }, addLineString: function(t2) {
        var e2 = H.removeRepeatedPoints(t2.getCoordinates());
        if (e2.length < 2)
          return this._hasTooFewPoints = true, this.invalidPoint = e2[0], null;
        var n2 = new Jn(e2, new gn(this.argIndex, L.INTERIOR));
        this.lineEdgeMap.put(t2, n2), this.insertEdge(n2), f.isTrue(e2.length >= 2, "found LineString with single point"), this.insertBoundaryPoint(this.argIndex, e2[0]), this.insertBoundaryPoint(this.argIndex, e2[e2.length - 1]);
      }, getInvalidPoint: function() {
        return this.invalidPoint;
      }, getBoundaryPoints: function() {
        for (var t2 = this.getBoundaryNodes(), e2 = new Array(t2.size()).fill(null), n2 = 0, i3 = t2.iterator(); i3.hasNext(); ) {
          var r2 = i3.next();
          e2[n2++] = r2.getCoordinate().copy();
        }
        return e2;
      }, getBoundaryNodes: function() {
        return null === this.boundaryNodes && (this.boundaryNodes = this.nodes.getBoundaryNodes(this.argIndex)), this.boundaryNodes;
      }, addSelfIntersectionNode: function(t2, e2, n2) {
        return this.isBoundaryNode(t2, e2) ? null : void (n2 === L.BOUNDARY && this.useBoundaryDeterminationRule ? this.insertBoundaryPoint(t2, e2) : this.insertPoint(t2, e2, n2));
      }, addPolygonRing: function(t2, e2, n2) {
        if (t2.isEmpty())
          return null;
        var i3 = H.removeRepeatedPoints(t2.getCoordinates());
        if (i3.length < 4)
          return this._hasTooFewPoints = true, this.invalidPoint = i3[0], null;
        var r2 = e2, s2 = n2;
        he.isCCW(i3) && (r2 = n2, s2 = e2);
        var o2 = new Jn(i3, new gn(this.argIndex, L.BOUNDARY, r2, s2));
        this.lineEdgeMap.put(t2, o2), this.insertEdge(o2), this.insertPoint(this.argIndex, i3[0], L.BOUNDARY);
      }, insertPoint: function(t2, e2, n2) {
        var i3 = this.nodes.addNode(e2), r2 = i3.getLabel();
        null === r2 ? i3.label = new gn(t2, n2) : r2.setLocation(t2, n2);
      }, createEdgeSetIntersector: function() {
        return new Fn();
      }, addSelfIntersectionNodes: function(t2) {
        for (var e2 = this.edges.iterator(); e2.hasNext(); )
          for (var n2 = e2.next(), i3 = n2.getLabel().getLocation(t2), r2 = n2.eiList.iterator(); r2.hasNext(); ) {
            var s2 = r2.next();
            this.addSelfIntersectionNode(t2, s2.coord, i3);
          }
      }, add: function() {
        if (1 !== arguments.length)
          return Cn.prototype.add.apply(this, arguments);
        var t2 = arguments[0];
        if (t2.isEmpty())
          return null;
        if (t2 instanceof Ot && (this.useBoundaryDeterminationRule = false), t2 instanceof Tt)
          this.addPolygon(t2);
        else if (t2 instanceof St)
          this.addLineString(t2);
        else if (t2 instanceof Lt)
          this.addPoint(t2);
        else if (t2 instanceof Pt)
          this.addCollection(t2);
        else if (t2 instanceof gt)
          this.addCollection(t2);
        else if (t2 instanceof Ot)
          this.addCollection(t2);
        else {
          if (!(t2 instanceof ft))
            throw new UnsupportedOperationException(t2.getClass().getName());
          this.addCollection(t2);
        }
      }, addCollection: function(t2) {
        for (var e2 = 0; e2 < t2.getNumGeometries(); e2++) {
          var n2 = t2.getGeometryN(e2);
          this.add(n2);
        }
      }, locate: function(t2) {
        return R(this.parentGeom, Rt) && this.parentGeom.getNumGeometries() > 50 ? (null === this.areaPtLocator && (this.areaPtLocator = new Un(this.parentGeom)), this.areaPtLocator.locate(t2)) : this.ptLocator.locate(t2, this.parentGeom);
      }, findEdge: function() {
        if (1 === arguments.length) {
          var t2 = arguments[0];
          return this.lineEdgeMap.get(t2);
        }
        return Cn.prototype.findEdge.apply(this, arguments);
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return $n;
      } }), $n.determineBoundary = function(t2, e2) {
        return t2.isInBoundary(e2) ? L.BOUNDARY : L.INTERIOR;
      }, e(ti.prototype, { getArgGeometry: function(t2) {
        return this.arg[t2].getGeometry();
      }, setComputationPrecision: function(t2) {
        this.resultPrecisionModel = t2, this.li.setPrecisionModel(this.resultPrecisionModel);
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return ti;
      } }), e(ei.prototype, { compareTo: function(t2) {
        var e2 = t2, n2 = ei.compareOriented(this.pts, this._orientation, e2.pts, e2._orientation);
        return n2;
      }, interfaces_: function() {
        return [s];
      }, getClass: function() {
        return ei;
      } }), ei.orientation = function(t2) {
        return 1 === H.increasingDirection(t2);
      }, ei.compareOriented = function(t2, e2, n2, i3) {
        for (var r2 = e2 ? 1 : -1, s2 = i3 ? 1 : -1, o2 = e2 ? t2.length : -1, a2 = i3 ? n2.length : -1, u2 = e2 ? 0 : t2.length - 1, l2 = i3 ? 0 : n2.length - 1; ; ) {
          var h2 = t2[u2].compareTo(n2[l2]);
          if (0 !== h2)
            return h2;
          u2 += r2, l2 += s2;
          var c2 = u2 === o2, f2 = l2 === a2;
          if (c2 && !f2)
            return -1;
          if (!c2 && f2)
            return 1;
          if (c2 && f2)
            return 0;
        }
      }, e(ni.prototype, { print: function(t2) {
        t2.print("MULTILINESTRING ( ");
        for (var e2 = 0; e2 < this.edges.size(); e2++) {
          var n2 = this.edges.get(e2);
          e2 > 0 && t2.print(","), t2.print("(");
          for (var i3 = n2.getCoordinates(), r2 = 0; r2 < i3.length; r2++)
            r2 > 0 && t2.print(","), t2.print(i3[r2].x + " " + i3[r2].y);
          t2.println(")");
        }
        t2.print(")  ");
      }, addAll: function(t2) {
        for (var e2 = t2.iterator(); e2.hasNext(); )
          this.add(e2.next());
      }, findEdgeIndex: function(t2) {
        for (var e2 = 0; e2 < this.edges.size(); e2++)
          if (this.edges.get(e2).equals(t2))
            return e2;
        return -1;
      }, iterator: function() {
        return this.edges.iterator();
      }, getEdges: function() {
        return this.edges;
      }, get: function(t2) {
        return this.edges.get(t2);
      }, findEqualEdge: function(t2) {
        var e2 = new ei(t2.getCoordinates()), n2 = this.ocaMap.get(e2);
        return n2;
      }, add: function(t2) {
        this.edges.add(t2);
        var e2 = new ei(t2.getCoordinates());
        this.ocaMap.put(e2, t2);
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return ni;
      } }), h(ii, ti), e(ii.prototype, { insertUniqueEdge: function(t2) {
        var e2 = this.edgeList.findEqualEdge(t2);
        if (null !== e2) {
          var n2 = e2.getLabel(), i3 = t2.getLabel();
          e2.isPointwiseEqual(t2) || (i3 = new gn(t2.getLabel()), i3.flip());
          var r2 = e2.getDepth();
          r2.isNull() && r2.add(n2), r2.add(i3), n2.merge(i3);
        } else
          this.edgeList.add(t2);
      }, getGraph: function() {
        return this.graph;
      }, cancelDuplicateResultEdges: function() {
        for (var t2 = this.graph.getEdgeEnds().iterator(); t2.hasNext(); ) {
          var e2 = t2.next(), n2 = e2.getSym();
          e2.isInResult() && n2.isInResult() && (e2.setInResult(false), n2.setInResult(false));
        }
      }, isCoveredByLA: function(t2) {
        return this.isCovered(t2, this.resultLineList) ? true : !!this.isCovered(t2, this.resultPolyList);
      }, computeGeometry: function(t2, e2, n2, i3) {
        var r2 = new I();
        return r2.addAll(t2), r2.addAll(e2), r2.addAll(n2), r2.isEmpty() ? ii.createEmptyResult(i3, this.arg[0].getGeometry(), this.arg[1].getGeometry(), this.geomFact) : this.geomFact.buildGeometry(r2);
      }, mergeSymLabels: function() {
        for (var t2 = this.graph.getNodes().iterator(); t2.hasNext(); ) {
          var e2 = t2.next();
          e2.getEdges().mergeSymLabels();
        }
      }, isCovered: function(t2, e2) {
        for (var n2 = e2.iterator(); n2.hasNext(); ) {
          var i3 = n2.next(), r2 = this.ptLocator.locate(t2, i3);
          if (r2 !== L.EXTERIOR)
            return true;
        }
        return false;
      }, replaceCollapsedEdges: function() {
        for (var t2 = new I(), e2 = this.edgeList.iterator(); e2.hasNext(); ) {
          var n2 = e2.next();
          n2.isCollapsed() && (e2.remove(), t2.add(n2.getCollapsedEdge()));
        }
        this.edgeList.addAll(t2);
      }, updateNodeLabelling: function() {
        for (var t2 = this.graph.getNodes().iterator(); t2.hasNext(); ) {
          var e2 = t2.next(), n2 = e2.getEdges().getLabel();
          e2.getLabel().merge(n2);
        }
      }, getResultGeometry: function(t2) {
        return this.computeOverlay(t2), this.resultGeom;
      }, insertUniqueEdges: function(t2) {
        for (var e2 = t2.iterator(); e2.hasNext(); ) {
          var n2 = e2.next();
          this.insertUniqueEdge(n2);
        }
      }, computeOverlay: function(t2) {
        this.copyPoints(0), this.copyPoints(1), this.arg[0].computeSelfNodes(this.li, false), this.arg[1].computeSelfNodes(this.li, false), this.arg[0].computeEdgeIntersections(this.arg[1], this.li, true);
        var e2 = new I();
        this.arg[0].computeSplitEdges(e2), this.arg[1].computeSplitEdges(e2);
        this.insertUniqueEdges(e2), this.computeLabelsFromDepths(), this.replaceCollapsedEdges(), ln.checkValid(this.edgeList.getEdges()), this.graph.addEdges(this.edgeList.getEdges()), this.computeLabelling(), this.labelIncompleteNodes(), this.findResultAreaEdges(t2), this.cancelDuplicateResultEdges();
        var n2 = new Sn(this.geomFact);
        n2.add(this.graph), this.resultPolyList = n2.getPolygons();
        var i3 = new wn(this, this.geomFact, this.ptLocator);
        this.resultLineList = i3.build(t2);
        var r2 = new Ln(this, this.geomFact, this.ptLocator);
        this.resultPointList = r2.build(t2), this.resultGeom = this.computeGeometry(this.resultPointList, this.resultLineList, this.resultPolyList, t2);
      }, labelIncompleteNode: function(t2, e2) {
        var n2 = this.ptLocator.locate(t2.getCoordinate(), this.arg[e2].getGeometry());
        t2.getLabel().setLocation(e2, n2);
      }, copyPoints: function(t2) {
        for (var e2 = this.arg[t2].getNodeIterator(); e2.hasNext(); ) {
          var n2 = e2.next(), i3 = this.graph.addNode(n2.getCoordinate());
          i3.setLabel(t2, n2.getLabel().getLocation(t2));
        }
      }, findResultAreaEdges: function(t2) {
        for (var e2 = this.graph.getEdgeEnds().iterator(); e2.hasNext(); ) {
          var n2 = e2.next(), i3 = n2.getLabel();
          i3.isArea() && !n2.isInteriorAreaEdge() && ii.isResultOfOp(i3.getLocation(0, cn.RIGHT), i3.getLocation(1, cn.RIGHT), t2) && n2.setInResult(true);
        }
      }, computeLabelsFromDepths: function() {
        for (var t2 = this.edgeList.iterator(); t2.hasNext(); ) {
          var e2 = t2.next(), n2 = e2.getLabel(), i3 = e2.getDepth();
          if (!i3.isNull()) {
            i3.normalize();
            for (var r2 = 0; 2 > r2; r2++)
              n2.isNull(r2) || !n2.isArea() || i3.isNull(r2) || (0 === i3.getDelta(r2) ? n2.toLine(r2) : (f.isTrue(!i3.isNull(r2, cn.LEFT), "depth of LEFT side has not been initialized"), n2.setLocation(r2, cn.LEFT, i3.getLocation(r2, cn.LEFT)), f.isTrue(!i3.isNull(r2, cn.RIGHT), "depth of RIGHT side has not been initialized"), n2.setLocation(r2, cn.RIGHT, i3.getLocation(r2, cn.RIGHT))));
          }
        }
      }, computeLabelling: function() {
        for (var t2 = this.graph.getNodes().iterator(); t2.hasNext(); ) {
          var e2 = t2.next();
          e2.getEdges().computeLabelling(this.arg);
        }
        this.mergeSymLabels(), this.updateNodeLabelling();
      }, labelIncompleteNodes: function() {
        for (var t2 = 0, e2 = this.graph.getNodes().iterator(); e2.hasNext(); ) {
          var n2 = e2.next(), i3 = n2.getLabel();
          n2.isIsolated() && (t2++, i3.isNull(0) ? this.labelIncompleteNode(n2, 0) : this.labelIncompleteNode(n2, 1)), n2.getEdges().updateLabelling(i3);
        }
      }, isCoveredByA: function(t2) {
        return !!this.isCovered(t2, this.resultPolyList);
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return ii;
      } }), ii.overlayOp = function(t2, e2, n2) {
        var i3 = new ii(t2, e2), r2 = i3.getResultGeometry(n2);
        return r2;
      }, ii.intersection = function(t2, e2) {
        if (t2.isEmpty() || e2.isEmpty())
          return ii.createEmptyResult(ii.INTERSECTION, t2, e2, t2.getFactory());
        if (t2.isGeometryCollection()) {
          var n2 = e2;
          return hn.map(t2, { interfaces_: function() {
            return [MapOp];
          }, map: function(t3) {
            return t3.intersection(n2);
          } });
        }
        return t2.checkNotGeometryCollection(t2), t2.checkNotGeometryCollection(e2), si.overlayOp(t2, e2, ii.INTERSECTION);
      }, ii.symDifference = function(t2, e2) {
        if (t2.isEmpty() || e2.isEmpty()) {
          if (t2.isEmpty() && e2.isEmpty())
            return ii.createEmptyResult(ii.SYMDIFFERENCE, t2, e2, t2.getFactory());
          if (t2.isEmpty())
            return e2.copy();
          if (e2.isEmpty())
            return t2.copy();
        }
        return t2.checkNotGeometryCollection(t2), t2.checkNotGeometryCollection(e2), si.overlayOp(t2, e2, ii.SYMDIFFERENCE);
      }, ii.resultDimension = function(t2, e2, n2) {
        var i3 = e2.getDimension(), r2 = n2.getDimension(), s2 = -1;
        switch (t2) {
          case ii.INTERSECTION:
            s2 = Math.min(i3, r2);
            break;
          case ii.UNION:
            s2 = Math.max(i3, r2);
            break;
          case ii.DIFFERENCE:
            s2 = i3;
            break;
          case ii.SYMDIFFERENCE:
            s2 = Math.max(i3, r2);
        }
        return s2;
      }, ii.createEmptyResult = function(t2, e2, n2, i3) {
        var r2 = null;
        switch (ii.resultDimension(t2, e2, n2)) {
          case -1:
            r2 = i3.createGeometryCollection(new Array(0).fill(null));
            break;
          case 0:
            r2 = i3.createPoint();
            break;
          case 1:
            r2 = i3.createLineString();
            break;
          case 2:
            r2 = i3.createPolygon();
        }
        return r2;
      }, ii.difference = function(t2, e2) {
        return t2.isEmpty() ? ii.createEmptyResult(ii.DIFFERENCE, t2, e2, t2.getFactory()) : e2.isEmpty() ? t2.copy() : (t2.checkNotGeometryCollection(t2), t2.checkNotGeometryCollection(e2), si.overlayOp(t2, e2, ii.DIFFERENCE));
      }, ii.isResultOfOp = function() {
        if (2 === arguments.length) {
          var t2 = arguments[0], e2 = arguments[1], n2 = t2.getLocation(0), i3 = t2.getLocation(1);
          return ii.isResultOfOp(n2, i3, e2);
        }
        if (3 === arguments.length) {
          var r2 = arguments[0], s2 = arguments[1], o2 = arguments[2];
          switch (r2 === L.BOUNDARY && (r2 = L.INTERIOR), s2 === L.BOUNDARY && (s2 = L.INTERIOR), o2) {
            case ii.INTERSECTION:
              return r2 === L.INTERIOR && s2 === L.INTERIOR;
            case ii.UNION:
              return r2 === L.INTERIOR || s2 === L.INTERIOR;
            case ii.DIFFERENCE:
              return r2 === L.INTERIOR && s2 !== L.INTERIOR;
            case ii.SYMDIFFERENCE:
              return r2 === L.INTERIOR && s2 !== L.INTERIOR || r2 !== L.INTERIOR && s2 === L.INTERIOR;
          }
          return false;
        }
      }, ii.INTERSECTION = 1, ii.UNION = 2, ii.DIFFERENCE = 3, ii.SYMDIFFERENCE = 4, e(ri.prototype, { selfSnap: function(t2) {
        var e2 = new Ie(t2), n2 = e2.snapTo(t2, this.snapTolerance);
        return n2;
      }, removeCommonBits: function(t2) {
        this.cbr = new Se(), this.cbr.add(t2[0]), this.cbr.add(t2[1]);
        var e2 = new Array(2).fill(null);
        return e2[0] = this.cbr.removeCommonBits(t2[0].copy()), e2[1] = this.cbr.removeCommonBits(t2[1].copy()), e2;
      }, prepareResult: function(t2) {
        return this.cbr.addCommonBits(t2), t2;
      }, getResultGeometry: function(t2) {
        var e2 = this.snap(this.geom), n2 = ii.overlayOp(e2[0], e2[1], t2);
        return this.prepareResult(n2);
      }, checkValid: function(t2) {
        t2.isValid() || A.out.println("Snapped geometry is invalid");
      }, computeSnapTolerance: function() {
        this.snapTolerance = Ie.computeOverlaySnapTolerance(this.geom[0], this.geom[1]);
      }, snap: function(t2) {
        var e2 = this.removeCommonBits(t2), n2 = Ie.snap(e2[0], e2[1], this.snapTolerance);
        return n2;
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return ri;
      } }), ri.overlayOp = function(t2, e2, n2) {
        var i3 = new ri(t2, e2);
        return i3.getResultGeometry(n2);
      }, ri.union = function(t2, e2) {
        return ri.overlayOp(t2, e2, ii.UNION);
      }, ri.intersection = function(t2, e2) {
        return ri.overlayOp(t2, e2, ii.INTERSECTION);
      }, ri.symDifference = function(t2, e2) {
        return ri.overlayOp(t2, e2, ii.SYMDIFFERENCE);
      }, ri.difference = function(t2, e2) {
        return ri.overlayOp(t2, e2, ii.DIFFERENCE);
      }, e(si.prototype, { getResultGeometry: function(t2) {
        var e2 = null, n2 = false, i3 = null;
        try {
          e2 = ii.overlayOp(this.geom[0], this.geom[1], t2);
          var r2 = true;
          r2 && (n2 = true);
        } catch (t3) {
          if (!(t3 instanceof l))
            throw t3;
          i3 = t3;
        } finally {
        }
        if (!n2)
          try {
            e2 = ri.overlayOp(this.geom[0], this.geom[1], t2);
          } catch (t3) {
            throw t3 instanceof l ? i3 : t3;
          } finally {
          }
        return e2;
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return si;
      } }), si.overlayOp = function(t2, e2, n2) {
        var i3 = new si(t2, e2);
        return i3.getResultGeometry(n2);
      }, si.union = function(t2, e2) {
        return si.overlayOp(t2, e2, ii.UNION);
      }, si.intersection = function(t2, e2) {
        return si.overlayOp(t2, e2, ii.INTERSECTION);
      }, si.symDifference = function(t2, e2) {
        return si.overlayOp(t2, e2, ii.SYMDIFFERENCE);
      }, si.difference = function(t2, e2) {
        return si.overlayOp(t2, e2, ii.DIFFERENCE);
      }, e(oi.prototype, { addPolygon: function(t2) {
        if (t2.isEmpty())
          return null;
        var e2 = null, n2 = 0, i3 = this.horizontalBisector(t2);
        if (0 === i3.getLength())
          n2 = 0, e2 = i3.getCoordinate();
        else {
          var r2 = si.overlayOp(i3, t2, ii.INTERSECTION), s2 = this.widestGeometry(r2);
          n2 = s2.getEnvelopeInternal().getWidth(), e2 = oi.centre(s2.getEnvelopeInternal());
        }
        (null === this.interiorPoint || n2 > this.maxWidth) && (this.interiorPoint = e2, this.maxWidth = n2);
      }, getInteriorPoint: function() {
        return this.interiorPoint;
      }, widestGeometry: function t2() {
        if (arguments[0] instanceof ft) {
          var e2 = arguments[0];
          if (e2.isEmpty())
            return e2;
          for (var t3 = e2.getGeometryN(0), n2 = 1; n2 < e2.getNumGeometries(); n2++)
            e2.getGeometryN(n2).getEnvelopeInternal().getWidth() > t3.getEnvelopeInternal().getWidth() && (t3 = e2.getGeometryN(n2));
          return t3;
        }
        if (arguments[0] instanceof B) {
          var i3 = arguments[0];
          return i3 instanceof ft ? this.widestGeometry(i3) : i3;
        }
      }, horizontalBisector: function(t2) {
        var e2 = t2.getEnvelopeInternal(), n2 = ai.getBisectorY(t2);
        return this.factory.createLineString([new g(e2.getMinX(), n2), new g(e2.getMaxX(), n2)]);
      }, add: function(t2) {
        if (t2 instanceof Tt)
          this.addPolygon(t2);
        else if (t2 instanceof ft)
          for (var e2 = t2, n2 = 0; n2 < e2.getNumGeometries(); n2++)
            this.add(e2.getGeometryN(n2));
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return oi;
      } }), oi.centre = function(t2) {
        return new g(oi.avg(t2.getMinX(), t2.getMaxX()), oi.avg(t2.getMinY(), t2.getMaxY()));
      }, oi.avg = function(t2, e2) {
        return (t2 + e2) / 2;
      }, e(ai.prototype, { updateInterval: function(t2) {
        t2 <= this.centreY ? t2 > this.loY && (this.loY = t2) : t2 > this.centreY && t2 < this.hiY && (this.hiY = t2);
      }, getBisectorY: function() {
        this.process(this.poly.getExteriorRing());
        for (var t2 = 0; t2 < this.poly.getNumInteriorRing(); t2++)
          this.process(this.poly.getInteriorRingN(t2));
        var e2 = oi.avg(this.hiY, this.loY);
        return e2;
      }, process: function(t2) {
        for (var e2 = t2.getCoordinateSequence(), n2 = 0; n2 < e2.size(); n2++) {
          var i3 = e2.getY(n2);
          this.updateInterval(i3);
        }
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return ai;
      } }), ai.getBisectorY = function(t2) {
        var e2 = new ai(t2);
        return e2.getBisectorY();
      }, oi.SafeBisectorFinder = ai, e(ui.prototype, { addEndpoints: function() {
        if (arguments[0] instanceof B) {
          var t2 = arguments[0];
          if (t2 instanceof St)
            this.addEndpoints(t2.getCoordinates());
          else if (t2 instanceof ft)
            for (var e2 = t2, n2 = 0; n2 < e2.getNumGeometries(); n2++)
              this.addEndpoints(e2.getGeometryN(n2));
        } else if (arguments[0] instanceof Array) {
          var i3 = arguments[0];
          this.add(i3[0]), this.add(i3[i3.length - 1]);
        }
      }, getInteriorPoint: function() {
        return this.interiorPoint;
      }, addInterior: function() {
        if (arguments[0] instanceof B) {
          var t2 = arguments[0];
          if (t2 instanceof St)
            this.addInterior(t2.getCoordinates());
          else if (t2 instanceof ft)
            for (var e2 = t2, n2 = 0; n2 < e2.getNumGeometries(); n2++)
              this.addInterior(e2.getGeometryN(n2));
        } else if (arguments[0] instanceof Array)
          for (var i3 = arguments[0], n2 = 1; n2 < i3.length - 1; n2++)
            this.add(i3[n2]);
      }, add: function(t2) {
        var e2 = t2.distance(this.centroid);
        e2 < this.minDistance && (this.interiorPoint = new g(t2), this.minDistance = e2);
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return ui;
      } }), e(li.prototype, { getInteriorPoint: function() {
        return this.interiorPoint;
      }, add: function() {
        if (arguments[0] instanceof B) {
          var t2 = arguments[0];
          if (t2 instanceof Lt)
            this.add(t2.getCoordinate());
          else if (t2 instanceof ft)
            for (var e2 = t2, n2 = 0; n2 < e2.getNumGeometries(); n2++)
              this.add(e2.getGeometryN(n2));
        } else if (arguments[0] instanceof g) {
          var i3 = arguments[0], r2 = i3.distance(this.centroid);
          r2 < this.minDistance && (this.interiorPoint = new g(i3), this.minDistance = r2);
        }
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return li;
      } }), e(hi.prototype, { interfaces_: function() {
        return [];
      }, getClass: function() {
        return hi;
      } }), hi.toDegrees = function(t2) {
        return 180 * t2 / Math.PI;
      }, hi.normalize = function(t2) {
        for (; t2 > Math.PI; )
          t2 -= hi.PI_TIMES_2;
        for (; t2 <= -Math.PI; )
          t2 += hi.PI_TIMES_2;
        return t2;
      }, hi.angle = function() {
        if (1 === arguments.length) {
          var t2 = arguments[0];
          return Math.atan2(t2.y, t2.x);
        }
        if (2 === arguments.length) {
          var e2 = arguments[0], n2 = arguments[1], i3 = n2.x - e2.x, r2 = n2.y - e2.y;
          return Math.atan2(r2, i3);
        }
      }, hi.isAcute = function(t2, e2, n2) {
        var i3 = t2.x - e2.x, r2 = t2.y - e2.y, s2 = n2.x - e2.x, o2 = n2.y - e2.y, a2 = i3 * s2 + r2 * o2;
        return a2 > 0;
      }, hi.isObtuse = function(t2, e2, n2) {
        var i3 = t2.x - e2.x, r2 = t2.y - e2.y, s2 = n2.x - e2.x, o2 = n2.y - e2.y, a2 = i3 * s2 + r2 * o2;
        return 0 > a2;
      }, hi.interiorAngle = function(t2, e2, n2) {
        var i3 = hi.angle(e2, t2), r2 = hi.angle(e2, n2);
        return Math.abs(r2 - i3);
      }, hi.normalizePositive = function(t2) {
        if (0 > t2) {
          for (; 0 > t2; )
            t2 += hi.PI_TIMES_2;
          t2 >= hi.PI_TIMES_2 && (t2 = 0);
        } else {
          for (; t2 >= hi.PI_TIMES_2; )
            t2 -= hi.PI_TIMES_2;
          0 > t2 && (t2 = 0);
        }
        return t2;
      }, hi.angleBetween = function(t2, e2, n2) {
        var i3 = hi.angle(e2, t2), r2 = hi.angle(e2, n2);
        return hi.diff(i3, r2);
      }, hi.diff = function(t2, e2) {
        var n2 = null;
        return n2 = e2 > t2 ? e2 - t2 : t2 - e2, n2 > Math.PI && (n2 = 2 * Math.PI - n2), n2;
      }, hi.toRadians = function(t2) {
        return t2 * Math.PI / 180;
      }, hi.getTurn = function(t2, e2) {
        var n2 = Math.sin(e2 - t2);
        return n2 > 0 ? hi.COUNTERCLOCKWISE : 0 > n2 ? hi.CLOCKWISE : hi.NONE;
      }, hi.angleBetweenOriented = function(t2, e2, n2) {
        var i3 = hi.angle(e2, t2), r2 = hi.angle(e2, n2), s2 = r2 - i3;
        return s2 <= -Math.PI ? s2 + hi.PI_TIMES_2 : s2 > Math.PI ? s2 - hi.PI_TIMES_2 : s2;
      }, hi.PI_TIMES_2 = 2 * Math.PI, hi.PI_OVER_2 = Math.PI / 2, hi.PI_OVER_4 = Math.PI / 4, hi.COUNTERCLOCKWISE = he.COUNTERCLOCKWISE, hi.CLOCKWISE = he.CLOCKWISE, hi.NONE = he.COLLINEAR, e(ci.prototype, { area: function() {
        return ci.area(this.p0, this.p1, this.p2);
      }, signedArea: function() {
        return ci.signedArea(this.p0, this.p1, this.p2);
      }, interpolateZ: function(t2) {
        if (null === t2)
          throw new i2("Supplied point is null.");
        return ci.interpolateZ(t2, this.p0, this.p1, this.p2);
      }, longestSideLength: function() {
        return ci.longestSideLength(this.p0, this.p1, this.p2);
      }, isAcute: function() {
        return ci.isAcute(this.p0, this.p1, this.p2);
      }, circumcentre: function() {
        return ci.circumcentre(this.p0, this.p1, this.p2);
      }, area3D: function() {
        return ci.area3D(this.p0, this.p1, this.p2);
      }, centroid: function() {
        return ci.centroid(this.p0, this.p1, this.p2);
      }, inCentre: function() {
        return ci.inCentre(this.p0, this.p1, this.p2);
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return ci;
      } }), ci.area = function(t2, e2, n2) {
        return Math.abs(((n2.x - t2.x) * (e2.y - t2.y) - (e2.x - t2.x) * (n2.y - t2.y)) / 2);
      }, ci.signedArea = function(t2, e2, n2) {
        return ((n2.x - t2.x) * (e2.y - t2.y) - (e2.x - t2.x) * (n2.y - t2.y)) / 2;
      }, ci.det = function(t2, e2, n2, i3) {
        return t2 * i3 - e2 * n2;
      }, ci.interpolateZ = function(t2, e2, n2, i3) {
        var r2 = e2.x, s2 = e2.y, o2 = n2.x - r2, a2 = i3.x - r2, u2 = n2.y - s2, l2 = i3.y - s2, h2 = o2 * l2 - a2 * u2, c2 = t2.x - r2, f2 = t2.y - s2, g2 = (l2 * c2 - a2 * f2) / h2, d2 = (-u2 * c2 + o2 * f2) / h2, p2 = e2.z + g2 * (n2.z - e2.z) + d2 * (i3.z - e2.z);
        return p2;
      }, ci.longestSideLength = function(t2, e2, n2) {
        var i3 = t2.distance(e2), r2 = e2.distance(n2), s2 = n2.distance(t2), o2 = i3;
        return r2 > o2 && (o2 = r2), s2 > o2 && (o2 = s2), o2;
      }, ci.isAcute = function(t2, e2, n2) {
        return hi.isAcute(t2, e2, n2) && hi.isAcute(e2, n2, t2) ? !!hi.isAcute(n2, t2, e2) : false;
      }, ci.circumcentre = function(t2, e2, n2) {
        var i3 = n2.x, r2 = n2.y, s2 = t2.x - i3, o2 = t2.y - r2, a2 = e2.x - i3, u2 = e2.y - r2, l2 = 2 * ci.det(s2, o2, a2, u2), h2 = ci.det(o2, s2 * s2 + o2 * o2, u2, a2 * a2 + u2 * u2), c2 = ci.det(s2, s2 * s2 + o2 * o2, a2, a2 * a2 + u2 * u2), f2 = i3 - h2 / l2, d2 = r2 + c2 / l2;
        return new g(f2, d2);
      }, ci.perpendicularBisector = function(t2, e2) {
        var n2 = e2.x - t2.x, i3 = e2.y - t2.y, r2 = new F(t2.x + n2 / 2, t2.y + i3 / 2, 1), s2 = new F(t2.x - i3 + n2 / 2, t2.y + n2 + i3 / 2, 1);
        return new F(r2, s2);
      }, ci.angleBisector = function(t2, e2, n2) {
        var i3 = e2.distance(t2), r2 = e2.distance(n2), s2 = i3 / (i3 + r2), o2 = n2.x - t2.x, a2 = n2.y - t2.y, u2 = new g(t2.x + s2 * o2, t2.y + s2 * a2);
        return u2;
      }, ci.area3D = function(t2, e2, n2) {
        var i3 = e2.x - t2.x, r2 = e2.y - t2.y, s2 = e2.z - t2.z, o2 = n2.x - t2.x, a2 = n2.y - t2.y, u2 = n2.z - t2.z, l2 = r2 * u2 - s2 * a2, h2 = s2 * o2 - i3 * u2, c2 = i3 * a2 - r2 * o2, f2 = l2 * l2 + h2 * h2 + c2 * c2, g2 = Math.sqrt(f2) / 2;
        return g2;
      }, ci.centroid = function(t2, e2, n2) {
        var i3 = (t2.x + e2.x + n2.x) / 3, r2 = (t2.y + e2.y + n2.y) / 3;
        return new g(i3, r2);
      }, ci.inCentre = function(t2, e2, n2) {
        var i3 = e2.distance(n2), r2 = t2.distance(n2), s2 = t2.distance(e2), o2 = i3 + r2 + s2, a2 = (i3 * t2.x + r2 * e2.x + s2 * n2.x) / o2, u2 = (i3 * t2.y + r2 * e2.y + s2 * n2.y) / o2;
        return new g(a2, u2);
      }, e(fi.prototype, { getRadius: function() {
        return this.compute(), this.radius;
      }, getDiameter: function() {
        switch (this.compute(), this.extremalPts.length) {
          case 0:
            return this.input.getFactory().createLineString();
          case 1:
            return this.input.getFactory().createPoint(this.centre);
        }
        var t2 = this.extremalPts[0], e2 = this.extremalPts[1];
        return this.input.getFactory().createLineString([t2, e2]);
      }, getExtremalPoints: function() {
        return this.compute(), this.extremalPts;
      }, computeCirclePoints: function() {
        if (this.input.isEmpty())
          return this.extremalPts = new Array(0).fill(null), null;
        if (1 === this.input.getNumPoints()) {
          var t2 = this.input.getCoordinates();
          return this.extremalPts = [new g(t2[0])], null;
        }
        var e2 = this.input.convexHull(), n2 = e2.getCoordinates(), t2 = n2;
        if (n2[0].equals2D(n2[n2.length - 1]) && (t2 = new Array(n2.length - 1).fill(null), H.copyDeep(n2, 0, t2, 0, n2.length - 1)), t2.length <= 2)
          return this.extremalPts = H.copyDeep(t2), null;
        for (var i3 = fi.lowestPoint(t2), r2 = fi.pointWitMinAngleWithX(t2, i3), s2 = 0; s2 < t2.length; s2++) {
          var o2 = fi.pointWithMinAngleWithSegment(t2, i3, r2);
          if (hi.isObtuse(i3, o2, r2))
            return this.extremalPts = [new g(i3), new g(r2)], null;
          if (hi.isObtuse(o2, i3, r2))
            i3 = o2;
          else {
            if (!hi.isObtuse(o2, r2, i3))
              return this.extremalPts = [new g(i3), new g(r2), new g(o2)], null;
            r2 = o2;
          }
        }
        f.shouldNeverReachHere("Logic failure in Minimum Bounding Circle algorithm!");
      }, compute: function() {
        return null !== this.extremalPts ? null : (this.computeCirclePoints(), this.computeCentre(), void (null !== this.centre && (this.radius = this.centre.distance(this.extremalPts[0]))));
      }, getFarthestPoints: function() {
        switch (this.compute(), this.extremalPts.length) {
          case 0:
            return this.input.getFactory().createLineString();
          case 1:
            return this.input.getFactory().createPoint(this.centre);
        }
        var t2 = this.extremalPts[0], e2 = this.extremalPts[this.extremalPts.length - 1];
        return this.input.getFactory().createLineString([t2, e2]);
      }, getCircle: function() {
        if (this.compute(), null === this.centre)
          return this.input.getFactory().createPolygon();
        var t2 = this.input.getFactory().createPoint(this.centre);
        return 0 === this.radius ? t2 : t2.buffer(this.radius);
      }, getCentre: function() {
        return this.compute(), this.centre;
      }, computeCentre: function() {
        switch (this.extremalPts.length) {
          case 0:
            this.centre = null;
            break;
          case 1:
            this.centre = this.extremalPts[0];
            break;
          case 2:
            this.centre = new g((this.extremalPts[0].x + this.extremalPts[1].x) / 2, (this.extremalPts[0].y + this.extremalPts[1].y) / 2);
            break;
          case 3:
            this.centre = ci.circumcentre(this.extremalPts[0], this.extremalPts[1], this.extremalPts[2]);
        }
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return fi;
      } }), fi.pointWitMinAngleWithX = function(t2, e2) {
        for (var n2 = r.MAX_VALUE, i3 = null, s2 = 0; s2 < t2.length; s2++) {
          var o2 = t2[s2];
          if (o2 !== e2) {
            var a2 = o2.x - e2.x, u2 = o2.y - e2.y;
            0 > u2 && (u2 = -u2);
            var l2 = Math.sqrt(a2 * a2 + u2 * u2), h2 = u2 / l2;
            n2 > h2 && (n2 = h2, i3 = o2);
          }
        }
        return i3;
      }, fi.lowestPoint = function(t2) {
        for (var e2 = t2[0], n2 = 1; n2 < t2.length; n2++)
          t2[n2].y < e2.y && (e2 = t2[n2]);
        return e2;
      }, fi.pointWithMinAngleWithSegment = function(t2, e2, n2) {
        for (var i3 = r.MAX_VALUE, s2 = null, o2 = 0; o2 < t2.length; o2++) {
          var a2 = t2[o2];
          if (a2 !== e2 && a2 !== n2) {
            var u2 = hi.angleBetween(e2, a2, n2);
            i3 > u2 && (i3 = u2, s2 = a2);
          }
        }
        return s2;
      }, e(gi.prototype, { getWidthCoordinate: function() {
        return this.computeMinimumDiameter(), this.minWidthPt;
      }, getSupportingSegment: function() {
        return this.computeMinimumDiameter(), this.inputGeom.getFactory().createLineString([this.minBaseSeg.p0, this.minBaseSeg.p1]);
      }, getDiameter: function() {
        if (this.computeMinimumDiameter(), null === this.minWidthPt)
          return this.inputGeom.getFactory().createLineString(null);
        var t2 = this.minBaseSeg.project(this.minWidthPt);
        return this.inputGeom.getFactory().createLineString([t2, this.minWidthPt]);
      }, computeWidthConvex: function(t2) {
        t2 instanceof Tt ? this.convexHullPts = t2.getExteriorRing().getCoordinates() : this.convexHullPts = t2.getCoordinates(), 0 === this.convexHullPts.length ? (this.minWidth = 0, this.minWidthPt = null, this.minBaseSeg = null) : 1 === this.convexHullPts.length ? (this.minWidth = 0, this.minWidthPt = this.convexHullPts[0], this.minBaseSeg.p0 = this.convexHullPts[0], this.minBaseSeg.p1 = this.convexHullPts[0]) : 2 === this.convexHullPts.length || 3 === this.convexHullPts.length ? (this.minWidth = 0, this.minWidthPt = this.convexHullPts[0], this.minBaseSeg.p0 = this.convexHullPts[0], this.minBaseSeg.p1 = this.convexHullPts[1]) : this.computeConvexRingMinDiameter(this.convexHullPts);
      }, computeConvexRingMinDiameter: function(t2) {
        this.minWidth = r.MAX_VALUE;
        for (var e2 = 1, n2 = new ce(), i3 = 0; i3 < t2.length - 1; i3++)
          n2.p0 = t2[i3], n2.p1 = t2[i3 + 1], e2 = this.findMaxPerpDistance(t2, n2, e2);
      }, computeMinimumDiameter: function() {
        if (null !== this.minWidthPt)
          return null;
        if (this.isConvex)
          this.computeWidthConvex(this.inputGeom);
        else {
          var t2 = new me(this.inputGeom).getConvexHull();
          this.computeWidthConvex(t2);
        }
      }, getLength: function() {
        return this.computeMinimumDiameter(), this.minWidth;
      }, findMaxPerpDistance: function(t2, e2, n2) {
        for (var i3 = e2.distancePerpendicular(t2[n2]), r2 = i3, s2 = n2, o2 = s2; r2 >= i3; )
          i3 = r2, s2 = o2, o2 = gi.nextIndex(t2, s2), r2 = e2.distancePerpendicular(t2[o2]);
        return i3 < this.minWidth && (this.minPtIndex = s2, this.minWidth = i3, this.minWidthPt = t2[this.minPtIndex], this.minBaseSeg = new ce(e2)), s2;
      }, getMinimumRectangle: function() {
        if (this.computeMinimumDiameter(), 0 === this.minWidth)
          return this.minBaseSeg.p0.equals2D(this.minBaseSeg.p1) ? this.inputGeom.getFactory().createPoint(this.minBaseSeg.p0) : this.minBaseSeg.toGeometry(this.inputGeom.getFactory());
        for (var t2 = this.minBaseSeg.p1.x - this.minBaseSeg.p0.x, e2 = this.minBaseSeg.p1.y - this.minBaseSeg.p0.y, n2 = r.MAX_VALUE, i3 = -r.MAX_VALUE, s2 = r.MAX_VALUE, o2 = -r.MAX_VALUE, a2 = 0; a2 < this.convexHullPts.length; a2++) {
          var u2 = gi.computeC(t2, e2, this.convexHullPts[a2]);
          u2 > i3 && (i3 = u2), n2 > u2 && (n2 = u2);
          var l2 = gi.computeC(-e2, t2, this.convexHullPts[a2]);
          l2 > o2 && (o2 = l2), s2 > l2 && (s2 = l2);
        }
        var h2 = gi.computeSegmentForLine(-t2, -e2, o2), c2 = gi.computeSegmentForLine(-t2, -e2, s2), f2 = gi.computeSegmentForLine(-e2, t2, i3), g2 = gi.computeSegmentForLine(-e2, t2, n2), d2 = f2.lineIntersection(h2), p2 = g2.lineIntersection(h2), v2 = g2.lineIntersection(c2), m2 = f2.lineIntersection(c2), y2 = this.inputGeom.getFactory().createLinearRing([d2, p2, v2, m2, d2]);
        return this.inputGeom.getFactory().createPolygon(y2, null);
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return gi;
      } }), gi.nextIndex = function(t2, e2) {
        return e2++, e2 >= t2.length && (e2 = 0), e2;
      }, gi.computeC = function(t2, e2, n2) {
        return t2 * n2.y - e2 * n2.x;
      }, gi.getMinimumDiameter = function(t2) {
        return new gi(t2).getDiameter();
      }, gi.getMinimumRectangle = function(t2) {
        return new gi(t2).getMinimumRectangle();
      }, gi.computeSegmentForLine = function(t2, e2, n2) {
        var i3 = null, r2 = null;
        return Math.abs(e2) > Math.abs(t2) ? (i3 = new g(0, n2 / e2), r2 = new g(1, n2 / e2 - t2 / e2)) : (i3 = new g(n2 / t2, 0), r2 = new g(n2 / t2 - e2 / t2, 1)), new ce(i3, r2);
      };
      var co = Object.freeze({ Centroid: ge, CGAlgorithms: he, ConvexHull: me, InteriorPointArea: oi, InteriorPointLine: ui, InteriorPointPoint: li, RobustLineIntersector: ae, MinimumBoundingCircle: fi, MinimumDiameter: gi });
      e(di.prototype, { getResultGeometry: function() {
        return new pi(this.distanceTolerance).transform(this.inputGeom);
      }, setDistanceTolerance: function(t2) {
        if (0 >= t2)
          throw new i2("Tolerance must be positive");
        this.distanceTolerance = t2;
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return di;
      } }), di.densifyPoints = function(t2, e2, n2) {
        for (var i3 = new ce(), r2 = new N(), s2 = 0; s2 < t2.length - 1; s2++) {
          i3.p0 = t2[s2], i3.p1 = t2[s2 + 1], r2.add(i3.p0, false);
          var o2 = i3.getLength(), a2 = Math.trunc(o2 / e2) + 1;
          if (a2 > 1)
            for (var u2 = o2 / a2, l2 = 1; a2 > l2; l2++) {
              var h2 = l2 * u2 / o2, c2 = i3.pointAlong(h2);
              n2.makePrecise(c2), r2.add(c2, false);
            }
        }
        return r2.add(t2[t2.length - 1], false), r2.toCoordinateArray();
      }, di.densify = function(t2, e2) {
        var n2 = new di(t2);
        return n2.setDistanceTolerance(e2), n2.getResultGeometry();
      }, h(pi, xe), e(pi.prototype, { transformMultiPolygon: function(t2, e2) {
        var n2 = xe.prototype.transformMultiPolygon.call(this, t2, e2);
        return this.createValidArea(n2);
      }, transformPolygon: function(t2, e2) {
        var n2 = xe.prototype.transformPolygon.call(this, t2, e2);
        return e2 instanceof Ot ? n2 : this.createValidArea(n2);
      }, transformCoordinates: function(t2, e2) {
        var n2 = t2.toCoordinateArray(), i3 = di.densifyPoints(n2, this.distanceTolerance, e2.getPrecisionModel());
        return e2 instanceof St && 1 === i3.length && (i3 = new Array(0).fill(null)), this.factory.getCoordinateSequenceFactory().create(i3);
      }, createValidArea: function(t2) {
        return t2.buffer(0);
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return pi;
      } }), di.DensifyTransformer = pi;
      var fo = Object.freeze({ Densifier: di });
      e(vi.prototype, { find: function(t2) {
        var e2 = this;
        do {
          if (null === e2)
            return null;
          if (e2.dest().equals2D(t2))
            return e2;
          e2 = e2.oNext();
        } while (e2 !== this);
        return null;
      }, dest: function() {
        return this._sym._orig;
      }, oNext: function() {
        return this._sym._next;
      }, insert: function(t2) {
        if (this.oNext() === this)
          return this.insertAfter(t2), null;
        var e2 = this.compareTo(t2), n2 = this;
        do {
          var i3 = n2.oNext(), r2 = i3.compareTo(t2);
          if (r2 !== e2 || i3 === this)
            return n2.insertAfter(t2), null;
          n2 = i3;
        } while (n2 !== this);
        f.shouldNeverReachHere();
      }, insertAfter: function(t2) {
        f.equals(this._orig, t2.orig());
        var e2 = this.oNext();
        this._sym.setNext(t2), t2.sym().setNext(e2);
      }, degree: function t2() {
        var t3 = 0, e2 = this;
        do
          t3++, e2 = e2.oNext();
        while (e2 !== this);
        return t3;
      }, equals: function() {
        if (2 === arguments.length) {
          var t2 = arguments[0], e2 = arguments[1];
          return this._orig.equals2D(t2) && this._sym._orig.equals(e2);
        }
      }, deltaY: function() {
        return this._sym._orig.y - this._orig.y;
      }, sym: function() {
        return this._sym;
      }, prev: function() {
        return this._sym.next()._sym;
      }, compareAngularDirection: function(t2) {
        var e2 = this.deltaX(), n2 = this.deltaY(), i3 = t2.deltaX(), r2 = t2.deltaY();
        if (e2 === i3 && n2 === r2)
          return 0;
        var s2 = Je.quadrant(e2, n2), o2 = Je.quadrant(i3, r2);
        return s2 > o2 ? 1 : o2 > s2 ? -1 : he.computeOrientation(t2._orig, t2.dest(), this.dest());
      }, prevNode: function() {
        for (var t2 = this; 2 === t2.degree(); )
          if (t2 = t2.prev(), t2 === this)
            return null;
        return t2;
      }, compareTo: function(t2) {
        var e2 = t2, n2 = this.compareAngularDirection(e2);
        return n2;
      }, next: function() {
        return this._next;
      }, setSym: function(t2) {
        this._sym = t2;
      }, orig: function() {
        return this._orig;
      }, toString: function() {
        return "HE(" + this._orig.x + " " + this._orig.y + ", " + this._sym._orig.x + " " + this._sym._orig.y + ")";
      }, setNext: function(t2) {
        this._next = t2;
      }, init: function(t2) {
        this.setSym(t2), t2.setSym(this), this.setNext(t2), t2.setNext(this);
      }, deltaX: function() {
        return this._sym._orig.x - this._orig.x;
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return vi;
      } }), vi.init = function(t2, e2) {
        if (null !== t2._sym || null !== e2._sym || null !== t2._next || null !== e2._next)
          throw new IllegalStateException("Edges are already initialized");
        return t2.init(e2), t2;
      }, vi.create = function(t2, e2) {
        var n2 = new vi(t2), i3 = new vi(e2);
        return n2.init(i3), n2;
      }, h(mi, vi), e(mi.prototype, { mark: function() {
        this._isMarked = true;
      }, setMark: function(t2) {
        this._isMarked = t2;
      }, isMarked: function() {
        return this._isMarked;
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return mi;
      } }), mi.setMarkBoth = function(t2, e2) {
        t2.setMark(e2), t2.sym().setMark(e2);
      }, mi.isMarked = function(t2) {
        return t2.isMarked();
      }, mi.setMark = function(t2, e2) {
        t2.setMark(e2);
      }, mi.markBoth = function(t2) {
        t2.mark(), t2.sym().mark();
      }, mi.mark = function(t2) {
        t2.mark();
      }, e(yi.prototype, { insert: function(t2, e2, n2) {
        var i3 = this.create(t2, e2);
        null !== n2 ? n2.insert(i3) : this.vertexMap.put(t2, i3);
        var r2 = this.vertexMap.get(e2);
        return null !== r2 ? r2.insert(i3.sym()) : this.vertexMap.put(e2, i3.sym()), i3;
      }, create: function(t2, e2) {
        var n2 = this.createEdge(t2), i3 = this.createEdge(e2);
        return vi.init(n2, i3), n2;
      }, createEdge: function(t2) {
        return new vi(t2);
      }, addEdge: function(t2, e2) {
        if (!yi.isValidEdge(t2, e2))
          return null;
        var n2 = this.vertexMap.get(t2), i3 = null;
        if (null !== n2 && (i3 = n2.find(e2)), null !== i3)
          return i3;
        var r2 = this.insert(t2, e2, n2);
        return r2;
      }, getVertexEdges: function() {
        return this.vertexMap.values();
      }, findEdge: function(t2, e2) {
        var n2 = this.vertexMap.get(t2);
        return null === n2 ? null : n2.find(e2);
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return yi;
      } }), yi.isValidEdge = function(t2, e2) {
        var n2 = e2.compareTo(t2);
        return 0 !== n2;
      }, h(xi, mi), e(xi.prototype, { setStart: function() {
        this._isStart = true;
      }, isStart: function() {
        return this._isStart;
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return xi;
      } }), h(Ei, yi), e(Ei.prototype, { createEdge: function(t2) {
        return new xi(t2);
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return Ei;
      } }), e(Ii.prototype, { addLine: function(t2) {
        this.lines.add(this.factory.createLineString(t2.toCoordinateArray()));
      }, updateRingStartEdge: function(t2) {
        return t2.isStart() || (t2 = t2.sym(), t2.isStart()) ? null === this.ringStartEdge ? (this.ringStartEdge = t2, null) : void (t2.orig().compareTo(this.ringStartEdge.orig()) < 0 && (this.ringStartEdge = t2)) : null;
      }, getResult: function() {
        return null === this.result && this.computeResult(), this.result;
      }, process: function(t2) {
        var e2 = t2.prevNode();
        null === e2 && (e2 = t2), this.stackEdges(e2), this.buildLines();
      }, buildRing: function(t2) {
        var e2 = new N(), n2 = t2;
        for (e2.add(n2.orig().copy(), false); 2 === n2.sym().degree(); ) {
          var i3 = n2.next();
          if (i3 === t2)
            break;
          e2.add(i3.orig().copy(), false), n2 = i3;
        }
        e2.add(n2.dest().copy(), false), this.addLine(e2);
      }, buildLine: function(t2) {
        var e2 = new N(), n2 = t2;
        for (this.ringStartEdge = null, mi.markBoth(n2), e2.add(n2.orig().copy(), false); 2 === n2.sym().degree(); ) {
          this.updateRingStartEdge(n2);
          var i3 = n2.next();
          if (i3 === t2)
            return this.buildRing(this.ringStartEdge), null;
          e2.add(i3.orig().copy(), false), n2 = i3, mi.markBoth(n2);
        }
        e2.add(n2.dest().copy(), false), this.stackEdges(n2.sym()), this.addLine(e2);
      }, stackEdges: function(t2) {
        var e2 = t2;
        do
          mi.isMarked(e2) || this.nodeEdgeStack.add(e2), e2 = e2.oNext();
        while (e2 !== t2);
      }, computeResult: function() {
        for (var t2 = this.graph.getVertexEdges(), e2 = t2.iterator(); e2.hasNext(); ) {
          var n2 = e2.next();
          mi.isMarked(n2) || this.process(n2);
        }
        this.result = this.factory.buildGeometry(this.lines);
      }, buildLines: function() {
        for (; !this.nodeEdgeStack.empty(); ) {
          var t2 = this.nodeEdgeStack.pop();
          mi.isMarked(t2) || this.buildLine(t2);
        }
      }, add: function() {
        if (arguments[0] instanceof B) {
          var t2 = arguments[0];
          t2.apply({ interfaces_: function() {
            return [q];
          }, filter: function(t3) {
            t3 instanceof St && this.add(t3);
          } });
        } else if (R(arguments[0], v))
          for (var e2 = arguments[0], n2 = e2.iterator(); n2.hasNext(); ) {
            var i3 = n2.next();
            this.add(i3);
          }
        else if (arguments[0] instanceof St) {
          var r2 = arguments[0];
          null === this.factory && (this.factory = r2.getFactory());
          for (var s2 = r2.getCoordinateSequence(), o2 = false, n2 = 1; n2 < s2.size(); n2++) {
            var a2 = this.graph.addEdge(s2.getCoordinate(n2 - 1), s2.getCoordinate(n2));
            null !== a2 && (o2 || (a2.setStart(), o2 = true));
          }
        }
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return Ii;
      } }), Ii.dissolve = function(t2) {
        var e2 = new Ii();
        return e2.add(t2), e2.getResult();
      };
      var go = Object.freeze({ LineDissolver: Ii });
      e(Ni.prototype, { hasChildren: function() {
        for (var t2 = 0; 4 > t2; t2++)
          if (null !== this.subnode[t2])
            return true;
        return false;
      }, isPrunable: function() {
        return !(this.hasChildren() || this.hasItems());
      }, addAllItems: function(t2) {
        t2.addAll(this.items);
        for (var e2 = 0; 4 > e2; e2++)
          null !== this.subnode[e2] && this.subnode[e2].addAllItems(t2);
        return t2;
      }, getNodeCount: function() {
        for (var t2 = 0, e2 = 0; 4 > e2; e2++)
          null !== this.subnode[e2] && (t2 += this.subnode[e2].size());
        return t2 + 1;
      }, size: function() {
        for (var t2 = 0, e2 = 0; 4 > e2; e2++)
          null !== this.subnode[e2] && (t2 += this.subnode[e2].size());
        return t2 + this.items.size();
      }, addAllItemsFromOverlapping: function(t2, e2) {
        if (!this.isSearchMatch(t2))
          return null;
        e2.addAll(this.items);
        for (var n2 = 0; 4 > n2; n2++)
          null !== this.subnode[n2] && this.subnode[n2].addAllItemsFromOverlapping(t2, e2);
      }, visitItems: function(t2, e2) {
        for (var n2 = this.items.iterator(); n2.hasNext(); )
          e2.visitItem(n2.next());
      }, hasItems: function() {
        return !this.items.isEmpty();
      }, remove: function(t2, e2) {
        if (!this.isSearchMatch(t2))
          return false;
        for (var n2 = false, i3 = 0; 4 > i3; i3++)
          if (null !== this.subnode[i3] && (n2 = this.subnode[i3].remove(t2, e2))) {
            this.subnode[i3].isPrunable() && (this.subnode[i3] = null);
            break;
          }
        return n2 ? n2 : n2 = this.items.remove(e2);
      }, visit: function(t2, e2) {
        if (!this.isSearchMatch(t2))
          return null;
        this.visitItems(t2, e2);
        for (var n2 = 0; 4 > n2; n2++)
          null !== this.subnode[n2] && this.subnode[n2].visit(t2, e2);
      }, getItems: function() {
        return this.items;
      }, depth: function() {
        for (var t2 = 0, e2 = 0; 4 > e2; e2++)
          if (null !== this.subnode[e2]) {
            var n2 = this.subnode[e2].depth();
            n2 > t2 && (t2 = n2);
          }
        return t2 + 1;
      }, isEmpty: function t2() {
        var t3 = true;
        this.items.isEmpty() || (t3 = false);
        for (var e2 = 0; 4 > e2; e2++)
          null !== this.subnode[e2] && (this.subnode[e2].isEmpty() || (t3 = false));
        return t3;
      }, add: function(t2) {
        this.items.add(t2);
      }, interfaces_: function() {
        return [u];
      }, getClass: function() {
        return Ni;
      } }), Ni.getSubnodeIndex = function(t2, e2, n2) {
        var i3 = -1;
        return t2.getMinX() >= e2 && (t2.getMinY() >= n2 && (i3 = 3), t2.getMaxY() <= n2 && (i3 = 1)), t2.getMaxX() <= e2 && (t2.getMinY() >= n2 && (i3 = 2), t2.getMaxY() <= n2 && (i3 = 0)), i3;
      }, Ci.exponent = function(t2) {
        return Si(64, t2) - 1023;
      }, Ci.powerOf2 = function(t2) {
        return Math.pow(2, t2);
      }, e(wi.prototype, { getLevel: function() {
        return this.level;
      }, computeKey: function() {
        if (1 === arguments.length) {
          var t2 = arguments[0];
          for (this.level = wi.computeQuadLevel(t2), this.env = new C(), this.computeKey(this.level, t2); !this.env.contains(t2); )
            this.level += 1, this.computeKey(this.level, t2);
        } else if (2 === arguments.length) {
          var e2 = arguments[0], n2 = arguments[1], i3 = Ci.powerOf2(e2);
          this.pt.x = Math.floor(n2.getMinX() / i3) * i3, this.pt.y = Math.floor(n2.getMinY() / i3) * i3, this.env.init(this.pt.x, this.pt.x + i3, this.pt.y, this.pt.y + i3);
        }
      }, getEnvelope: function() {
        return this.env;
      }, getCentre: function() {
        return new g((this.env.getMinX() + this.env.getMaxX()) / 2, (this.env.getMinY() + this.env.getMaxY()) / 2);
      }, getPoint: function() {
        return this.pt;
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return wi;
      } }), wi.computeQuadLevel = function(t2) {
        var e2 = t2.getWidth(), n2 = t2.getHeight(), i3 = e2 > n2 ? e2 : n2, r2 = Ci.exponent(i3) + 1;
        return r2;
      }, h(Li, Ni), e(Li.prototype, { find: function(t2) {
        var e2 = Ni.getSubnodeIndex(t2, this.centrex, this.centrey);
        if (-1 === e2)
          return this;
        if (null !== this.subnode[e2]) {
          var n2 = this.subnode[e2];
          return n2.find(t2);
        }
        return this;
      }, isSearchMatch: function(t2) {
        return this.env.intersects(t2);
      }, getSubnode: function(t2) {
        return null === this.subnode[t2] && (this.subnode[t2] = this.createSubnode(t2)), this.subnode[t2];
      }, getEnvelope: function() {
        return this.env;
      }, getNode: function(t2) {
        var e2 = Ni.getSubnodeIndex(t2, this.centrex, this.centrey);
        if (-1 !== e2) {
          var n2 = this.getSubnode(e2);
          return n2.getNode(t2);
        }
        return this;
      }, createSubnode: function(t2) {
        var e2 = 0, n2 = 0, i3 = 0, r2 = 0;
        switch (t2) {
          case 0:
            e2 = this.env.getMinX(), n2 = this.centrex, i3 = this.env.getMinY(), r2 = this.centrey;
            break;
          case 1:
            e2 = this.centrex, n2 = this.env.getMaxX(), i3 = this.env.getMinY(), r2 = this.centrey;
            break;
          case 2:
            e2 = this.env.getMinX(), n2 = this.centrex, i3 = this.centrey, r2 = this.env.getMaxY();
            break;
          case 3:
            e2 = this.centrex, n2 = this.env.getMaxX(), i3 = this.centrey, r2 = this.env.getMaxY();
        }
        var s2 = new C(e2, n2, i3, r2), o2 = new Li(s2, this.level - 1);
        return o2;
      }, insertNode: function(t2) {
        f.isTrue(null === this.env || this.env.contains(t2.env));
        var e2 = Ni.getSubnodeIndex(t2.env, this.centrex, this.centrey);
        if (t2.level === this.level - 1)
          this.subnode[e2] = t2;
        else {
          var n2 = this.createSubnode(e2);
          n2.insertNode(t2), this.subnode[e2] = n2;
        }
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return Li;
      } }), Li.createNode = function(t2) {
        var e2 = new wi(t2), n2 = new Li(e2.getEnvelope(), e2.getLevel());
        return n2;
      }, Li.createExpanded = function(t2, e2) {
        var n2 = new C(e2);
        null !== t2 && n2.expandToInclude(t2.env);
        var i3 = Li.createNode(n2);
        return null !== t2 && i3.insertNode(t2), i3;
      }, e(Ri.prototype, { interfaces_: function() {
        return [];
      }, getClass: function() {
        return Ri;
      } }), Ri.isZeroWidth = function(t2, e2) {
        var n2 = e2 - t2;
        if (0 === n2)
          return true;
        var i3 = Math.max(Math.abs(t2), Math.abs(e2)), r2 = n2 / i3, s2 = Ci.exponent(r2);
        return s2 <= Ri.MIN_BINARY_EXPONENT;
      }, Ri.MIN_BINARY_EXPONENT = -50, h(Ti, Ni), e(Ti.prototype, { insert: function(t2, e2) {
        var n2 = Ni.getSubnodeIndex(t2, Ti.origin.x, Ti.origin.y);
        if (-1 === n2)
          return this.add(e2), null;
        var i3 = this.subnode[n2];
        if (null === i3 || !i3.getEnvelope().contains(t2)) {
          var r2 = Li.createExpanded(i3, t2);
          this.subnode[n2] = r2;
        }
        this.insertContained(this.subnode[n2], t2, e2);
      }, isSearchMatch: function(t2) {
        return true;
      }, insertContained: function(t2, e2, n2) {
        f.isTrue(t2.getEnvelope().contains(e2));
        var i3 = Ri.isZeroWidth(e2.getMinX(), e2.getMaxX()), r2 = Ri.isZeroWidth(e2.getMinY(), e2.getMaxY()), s2 = null;
        s2 = i3 || r2 ? t2.find(e2) : t2.getNode(e2), s2.add(n2);
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return Ti;
      } }), Ti.origin = new g(0, 0), e(Pi.prototype, { size: function() {
        return null !== this.root ? this.root.size() : 0;
      }, insert: function(t2, e2) {
        this.collectStats(t2);
        var n2 = Pi.ensureExtent(t2, this.minExtent);
        this.root.insert(n2, e2);
      }, query: function() {
        if (1 === arguments.length) {
          var t2 = arguments[0], e2 = new Yn();
          return this.query(t2, e2), e2.getItems();
        }
        if (2 === arguments.length) {
          var n2 = arguments[0], i3 = arguments[1];
          this.root.visit(n2, i3);
        }
      }, queryAll: function() {
        var t2 = new I();
        return this.root.addAllItems(t2), t2;
      }, remove: function(t2, e2) {
        var n2 = Pi.ensureExtent(t2, this.minExtent);
        return this.root.remove(n2, e2);
      }, collectStats: function(t2) {
        var e2 = t2.getWidth();
        e2 < this.minExtent && e2 > 0 && (this.minExtent = e2);
        var n2 = t2.getHeight();
        n2 < this.minExtent && n2 > 0 && (this.minExtent = n2);
      }, depth: function() {
        return null !== this.root ? this.root.depth() : 0;
      }, isEmpty: function() {
        return null === this.root;
      }, interfaces_: function() {
        return [Fe, u];
      }, getClass: function() {
        return Pi;
      } }), Pi.ensureExtent = function(t2, e2) {
        var n2 = t2.getMinX(), i3 = t2.getMaxX(), r2 = t2.getMinY(), s2 = t2.getMaxY();
        return n2 !== i3 && r2 !== s2 ? t2 : (n2 === i3 && (n2 -= e2 / 2, i3 = n2 + e2 / 2), r2 === s2 && (r2 -= e2 / 2, s2 = r2 + e2 / 2), new C(n2, i3, r2, s2));
      }, Pi.serialVersionUID = -7461163625812743e3;
      var po = Object.freeze({ Quadtree: Pi }), vo = Object.freeze({ STRtree: ke }), mo = Object.freeze({ quadtree: po, strtree: vo }), yo = ["Point", "MultiPoint", "LineString", "MultiLineString", "Polygon", "MultiPolygon"];
      e(bi.prototype, { read: function(t2) {
        var e2 = void 0;
        e2 = "string" == typeof t2 ? JSON.parse(t2) : t2;
        var n2 = e2.type;
        if (!xo[n2])
          throw new Error("Unknown GeoJSON type: " + e2.type);
        return -1 !== yo.indexOf(n2) ? xo[n2].apply(this, [e2.coordinates]) : "GeometryCollection" === n2 ? xo[n2].apply(this, [e2.geometries]) : xo[n2].apply(this, [e2]);
      }, write: function(t2) {
        var e2 = t2.getGeometryType();
        if (!Eo[e2])
          throw new Error("Geometry is not supported");
        return Eo[e2].apply(this, [t2]);
      } });
      var xo = { Feature: function(t2) {
        var e2 = {};
        for (var n2 in t2)
          e2[n2] = t2[n2];
        if (t2.geometry) {
          var i3 = t2.geometry.type;
          if (!xo[i3])
            throw new Error("Unknown GeoJSON type: " + t2.type);
          e2.geometry = this.read(t2.geometry);
        }
        return t2.bbox && (e2.bbox = xo.bbox.apply(this, [t2.bbox])), e2;
      }, FeatureCollection: function(t2) {
        var e2 = {};
        if (t2.features) {
          e2.features = [];
          for (var n2 = 0; n2 < t2.features.length; ++n2)
            e2.features.push(this.read(t2.features[n2]));
        }
        return t2.bbox && (e2.bbox = this.parse.bbox.apply(this, [t2.bbox])), e2;
      }, coordinates: function t2(e2) {
        for (var t3 = [], n2 = 0; n2 < e2.length; ++n2) {
          var i3 = e2[n2];
          t3.push(new g(i3[0], i3[1]));
        }
        return t3;
      }, bbox: function(t2) {
        return this.geometryFactory.createLinearRing([new g(t2[0], t2[1]), new g(t2[2], t2[1]), new g(t2[2], t2[3]), new g(t2[0], t2[3]), new g(t2[0], t2[1])]);
      }, Point: function(t2) {
        var e2 = new g(t2[0], t2[1]);
        return this.geometryFactory.createPoint(e2);
      }, MultiPoint: function(t2) {
        for (var e2 = [], n2 = 0; n2 < t2.length; ++n2)
          e2.push(xo.Point.apply(this, [t2[n2]]));
        return this.geometryFactory.createMultiPoint(e2);
      }, LineString: function(t2) {
        var e2 = xo.coordinates.apply(this, [t2]);
        return this.geometryFactory.createLineString(e2);
      }, MultiLineString: function(t2) {
        for (var e2 = [], n2 = 0; n2 < t2.length; ++n2)
          e2.push(xo.LineString.apply(this, [t2[n2]]));
        return this.geometryFactory.createMultiLineString(e2);
      }, Polygon: function(t2) {
        for (var e2 = xo.coordinates.apply(this, [t2[0]]), n2 = this.geometryFactory.createLinearRing(e2), i3 = [], r2 = 1; r2 < t2.length; ++r2) {
          var s2 = t2[r2], o2 = xo.coordinates.apply(this, [s2]), a2 = this.geometryFactory.createLinearRing(o2);
          i3.push(a2);
        }
        return this.geometryFactory.createPolygon(n2, i3);
      }, MultiPolygon: function(t2) {
        for (var e2 = [], n2 = 0; n2 < t2.length; ++n2) {
          var i3 = t2[n2];
          e2.push(xo.Polygon.apply(this, [i3]));
        }
        return this.geometryFactory.createMultiPolygon(e2);
      }, GeometryCollection: function(t2) {
        for (var e2 = [], n2 = 0; n2 < t2.length; ++n2) {
          var i3 = t2[n2];
          e2.push(this.read(i3));
        }
        return this.geometryFactory.createGeometryCollection(e2);
      } }, Eo = { coordinate: function(t2) {
        return [t2.x, t2.y];
      }, Point: function(t2) {
        var e2 = Eo.coordinate.apply(this, [t2.getCoordinate()]);
        return { type: "Point", coordinates: e2 };
      }, MultiPoint: function(t2) {
        for (var e2 = [], n2 = 0; n2 < t2.geometries.length; ++n2) {
          var i3 = t2.geometries[n2], r2 = Eo.Point.apply(this, [i3]);
          e2.push(r2.coordinates);
        }
        return { type: "MultiPoint", coordinates: e2 };
      }, LineString: function(t2) {
        for (var e2 = [], n2 = t2.getCoordinates(), i3 = 0; i3 < n2.length; ++i3) {
          var r2 = n2[i3];
          e2.push(Eo.coordinate.apply(this, [r2]));
        }
        return { type: "LineString", coordinates: e2 };
      }, MultiLineString: function(t2) {
        for (var e2 = [], n2 = 0; n2 < t2.geometries.length; ++n2) {
          var i3 = t2.geometries[n2], r2 = Eo.LineString.apply(this, [i3]);
          e2.push(r2.coordinates);
        }
        return { type: "MultiLineString", coordinates: e2 };
      }, Polygon: function(t2) {
        var e2 = [], n2 = Eo.LineString.apply(this, [t2.shell]);
        e2.push(n2.coordinates);
        for (var i3 = 0; i3 < t2.holes.length; ++i3) {
          var r2 = t2.holes[i3], s2 = Eo.LineString.apply(this, [r2]);
          e2.push(s2.coordinates);
        }
        return { type: "Polygon", coordinates: e2 };
      }, MultiPolygon: function(t2) {
        for (var e2 = [], n2 = 0; n2 < t2.geometries.length; ++n2) {
          var i3 = t2.geometries[n2], r2 = Eo.Polygon.apply(this, [i3]);
          e2.push(r2.coordinates);
        }
        return { type: "MultiPolygon", coordinates: e2 };
      }, GeometryCollection: function(t2) {
        for (var e2 = [], n2 = 0; n2 < t2.geometries.length; ++n2) {
          var i3 = t2.geometries[n2], r2 = i3.getGeometryType();
          e2.push(Eo[r2].apply(this, [i3]));
        }
        return { type: "GeometryCollection", geometries: e2 };
      } };
      e(Oi.prototype, { read: function(t2) {
        var e2 = this.parser.read(t2);
        return this.precisionModel.getType() === ee.FIXED && this.reducePrecision(e2), e2;
      }, reducePrecision: function(t2) {
        var e2, n2;
        if (t2.coordinate)
          this.precisionModel.makePrecise(t2.coordinate);
        else if (t2.points)
          for (e2 = 0, n2 = t2.points.length; n2 > e2; e2++)
            this.precisionModel.makePrecise(t2.points[e2]);
        else if (t2.geometries)
          for (e2 = 0, n2 = t2.geometries.length; n2 > e2; e2++)
            this.reducePrecision(t2.geometries[e2]);
      } }), e(_i.prototype, { write: function(t2) {
        return this.parser.write(t2);
      } }), e(Mi.prototype, { read: function(t2) {
        var e2 = this.parser.read(t2);
        return this.precisionModel.getType() === ee.FIXED && this.reducePrecision(e2), e2;
      }, reducePrecision: function(t2) {
        if (t2.coordinate)
          this.precisionModel.makePrecise(t2.coordinate);
        else if (t2.points)
          for (var e2 = 0, n2 = t2.points.coordinates.length; n2 > e2; e2++)
            this.precisionModel.makePrecise(t2.points.coordinates[e2]);
        else if (t2.geometries)
          for (var i3 = 0, r2 = t2.geometries.length; r2 > i3; i3++)
            this.reducePrecision(t2.geometries[i3]);
      } }), e(Ai.prototype, { read: function(t2) {
        return t2 instanceof ol.geom.Point ? this.convertFromPoint(t2) : t2 instanceof ol.geom.LineString ? this.convertFromLineString(t2) : t2 instanceof ol.geom.LinearRing ? this.convertFromLinearRing(t2) : t2 instanceof ol.geom.Polygon ? this.convertFromPolygon(t2) : t2 instanceof ol.geom.MultiPoint ? this.convertFromMultiPoint(t2) : t2 instanceof ol.geom.MultiLineString ? this.convertFromMultiLineString(t2) : t2 instanceof ol.geom.MultiPolygon ? this.convertFromMultiPolygon(t2) : t2 instanceof ol.geom.GeometryCollection ? this.convertFromCollection(t2) : void 0;
      }, convertFromPoint: function(t2) {
        var e2 = t2.getCoordinates();
        return this.geometryFactory.createPoint(new g(e2[0], e2[1]));
      }, convertFromLineString: function(t2) {
        return this.geometryFactory.createLineString(t2.getCoordinates().map(function(t3) {
          return new g(t3[0], t3[1]);
        }));
      }, convertFromLinearRing: function(t2) {
        return this.geometryFactory.createLinearRing(t2.getCoordinates().map(function(t3) {
          return new g(t3[0], t3[1]);
        }));
      }, convertFromPolygon: function(t2) {
        for (var e2 = t2.getLinearRings(), n2 = null, i3 = [], r2 = 0; r2 < e2.length; r2++) {
          var s2 = this.convertFromLinearRing(e2[r2]);
          0 === r2 ? n2 = s2 : i3.push(s2);
        }
        return this.geometryFactory.createPolygon(n2, i3);
      }, convertFromMultiPoint: function(t2) {
        var e2 = t2.getPoints().map(function(t3) {
          return this.convertFromPoint(t3);
        }, this);
        return this.geometryFactory.createMultiPoint(e2);
      }, convertFromMultiLineString: function(t2) {
        var e2 = t2.getLineStrings().map(function(t3) {
          return this.convertFromLineString(t3);
        }, this);
        return this.geometryFactory.createMultiLineString(e2);
      }, convertFromMultiPolygon: function(t2) {
        var e2 = t2.getPolygons().map(function(t3) {
          return this.convertFromPolygon(t3);
        }, this);
        return this.geometryFactory.createMultiPolygon(e2);
      }, convertFromCollection: function(t2) {
        var e2 = t2.getGeometries().map(function(t3) {
          return this.read(t3);
        }, this);
        return this.geometryFactory.createGeometryCollection(e2);
      }, write: function(t2) {
        return "Point" === t2.getGeometryType() ? this.convertToPoint(t2.getCoordinate()) : "LineString" === t2.getGeometryType() ? this.convertToLineString(t2) : "LinearRing" === t2.getGeometryType() ? this.convertToLinearRing(t2) : "Polygon" === t2.getGeometryType() ? this.convertToPolygon(t2) : "MultiPoint" === t2.getGeometryType() ? this.convertToMultiPoint(t2) : "MultiLineString" === t2.getGeometryType() ? this.convertToMultiLineString(t2) : "MultiPolygon" === t2.getGeometryType() ? this.convertToMultiPolygon(t2) : "GeometryCollection" === t2.getGeometryType() ? this.convertToCollection(t2) : void 0;
      }, convertToPoint: function(t2) {
        return new ol.geom.Point([t2.x, t2.y]);
      }, convertToLineString: function(t2) {
        var e2 = t2.points.coordinates.map(Di);
        return new ol.geom.LineString(e2);
      }, convertToLinearRing: function(t2) {
        var e2 = t2.points.coordinates.map(Di);
        return new ol.geom.LinearRing(e2);
      }, convertToPolygon: function(t2) {
        for (var e2 = [t2.shell.points.coordinates.map(Di)], n2 = 0; n2 < t2.holes.length; n2++)
          e2.push(t2.holes[n2].points.coordinates.map(Di));
        return new ol.geom.Polygon(e2);
      }, convertToMultiPoint: function(t2) {
        return new ol.geom.MultiPoint(t2.getCoordinates().map(Di));
      }, convertToMultiLineString: function(t2) {
        for (var e2 = [], n2 = 0; n2 < t2.geometries.length; n2++)
          e2.push(this.convertToLineString(t2.geometries[n2]).getCoordinates());
        return new ol.geom.MultiLineString(e2);
      }, convertToMultiPolygon: function(t2) {
        for (var e2 = [], n2 = 0; n2 < t2.geometries.length; n2++)
          e2.push(this.convertToPolygon(t2.geometries[n2]).getCoordinates());
        return new ol.geom.MultiPolygon(e2);
      }, convertToCollection: function(t2) {
        for (var e2 = [], n2 = 0; n2 < t2.geometries.length; n2++) {
          var i3 = t2.geometries[n2];
          e2.push(this.write(i3));
        }
        return new ol.geom.GeometryCollection(e2);
      } });
      var Io = Object.freeze({ GeoJSONReader: Oi, GeoJSONWriter: _i, OL3Parser: Ai, WKTReader: Mi, WKTWriter: se });
      e(Fi.prototype, { rescale: function() {
        if (R(arguments[0], v))
          for (var t2 = arguments[0], e2 = t2.iterator(); e2.hasNext(); ) {
            var n2 = e2.next();
            this.rescale(n2.getCoordinates());
          }
        else if (arguments[0] instanceof Array) {
          var i3 = arguments[0], r2 = null, s2 = null;
          2 === i3.length && (r2 = new g(i3[0]), s2 = new g(i3[1]));
          for (var e2 = 0; e2 < i3.length; e2++)
            i3[e2].x = i3[e2].x / this.scaleFactor + this.offsetX, i3[e2].y = i3[e2].y / this.scaleFactor + this.offsetY;
          2 === i3.length && i3[0].equals2D(i3[1]) && A.out.println(i3);
        }
      }, scale: function() {
        if (R(arguments[0], v)) {
          for (var t2 = arguments[0], e2 = new I(), n2 = t2.iterator(); n2.hasNext(); ) {
            var i3 = n2.next();
            e2.add(new Ke(this.scale(i3.getCoordinates()), i3.getData()));
          }
          return e2;
        }
        if (arguments[0] instanceof Array) {
          for (var r2 = arguments[0], s2 = new Array(r2.length).fill(null), n2 = 0; n2 < r2.length; n2++)
            s2[n2] = new g(Math.round((r2[n2].x - this.offsetX) * this.scaleFactor), Math.round((r2[n2].y - this.offsetY) * this.scaleFactor), r2[n2].z);
          var o2 = H.removeRepeatedPoints(s2);
          return o2;
        }
      }, isIntegerPrecision: function() {
        return 1 === this.scaleFactor;
      }, getNodedSubstrings: function() {
        var t2 = this.noder.getNodedSubstrings();
        return this.isScaled && this.rescale(t2), t2;
      }, computeNodes: function(t2) {
        var e2 = t2;
        this.isScaled && (e2 = this.scale(t2)), this.noder.computeNodes(e2);
      }, interfaces_: function() {
        return [tn];
      }, getClass: function() {
        return Fi;
      } });
      var No = Object.freeze({ MCIndexNoder: nn, ScaledNoder: Fi, SegmentString: be });
      e(Gi.prototype, { isSimpleMultiPoint: function(t2) {
        if (t2.isEmpty())
          return true;
        for (var e2 = new at(), n2 = 0; n2 < t2.getNumGeometries(); n2++) {
          var i3 = t2.getGeometryN(n2), r2 = i3.getCoordinate();
          if (e2.contains(r2))
            return this.nonSimpleLocation = r2, false;
          e2.add(r2);
        }
        return true;
      }, isSimplePolygonal: function(t2) {
        for (var e2 = kn.getLines(t2), n2 = e2.iterator(); n2.hasNext(); ) {
          var i3 = n2.next();
          if (!this.isSimpleLinearGeometry(i3))
            return false;
        }
        return true;
      }, hasClosedEndpointIntersection: function(t2) {
        for (var e2 = new rt(), n2 = t2.getEdgeIterator(); n2.hasNext(); ) {
          var i3 = n2.next(), r2 = (i3.getMaximumSegmentIndex(), i3.isClosed()), s2 = i3.getCoordinate(0);
          this.addEndpoint(e2, s2, r2);
          var o2 = i3.getCoordinate(i3.getNumPoints() - 1);
          this.addEndpoint(e2, o2, r2);
        }
        for (var n2 = e2.values().iterator(); n2.hasNext(); ) {
          var a2 = n2.next();
          if (a2.isClosed && 2 !== a2.degree)
            return this.nonSimpleLocation = a2.getCoordinate(), true;
        }
        return false;
      }, getNonSimpleLocation: function() {
        return this.nonSimpleLocation;
      }, isSimpleLinearGeometry: function(t2) {
        if (t2.isEmpty())
          return true;
        var e2 = new $n(0, t2), n2 = new ae(), i3 = e2.computeSelfNodes(n2, true);
        return i3.hasIntersection() ? i3.hasProperIntersection() ? (this.nonSimpleLocation = i3.getProperIntersectionPoint(), false) : this.hasNonEndpointIntersection(e2) ? false : !this.isClosedEndpointsInInterior || !this.hasClosedEndpointIntersection(e2) : true;
      }, hasNonEndpointIntersection: function(t2) {
        for (var e2 = t2.getEdgeIterator(); e2.hasNext(); )
          for (var n2 = e2.next(), i3 = n2.getMaximumSegmentIndex(), r2 = n2.getEdgeIntersectionList().iterator(); r2.hasNext(); ) {
            var s2 = r2.next();
            if (!s2.isEndPoint(i3))
              return this.nonSimpleLocation = s2.getCoordinate(), true;
          }
        return false;
      }, addEndpoint: function(t2, e2, n2) {
        var i3 = t2.get(e2);
        null === i3 && (i3 = new qi(e2), t2.put(e2, i3)), i3.addEndpoint(n2);
      }, computeSimple: function(t2) {
        return this.nonSimpleLocation = null, t2.isEmpty() ? true : t2 instanceof St ? this.isSimpleLinearGeometry(t2) : t2 instanceof gt ? this.isSimpleLinearGeometry(t2) : t2 instanceof Pt ? this.isSimpleMultiPoint(t2) : R(t2, Rt) ? this.isSimplePolygonal(t2) : t2 instanceof ft ? this.isSimpleGeometryCollection(t2) : true;
      }, isSimple: function() {
        return this.nonSimpleLocation = null, this.computeSimple(this.inputGeom);
      }, isSimpleGeometryCollection: function(t2) {
        for (var e2 = 0; e2 < t2.getNumGeometries(); e2++) {
          var n2 = t2.getGeometryN(e2);
          if (!this.computeSimple(n2))
            return false;
        }
        return true;
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return Gi;
      } }), e(qi.prototype, { addEndpoint: function(t2) {
        this.degree++, this.isClosed |= t2;
      }, getCoordinate: function() {
        return this.pt;
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return qi;
      } }), Gi.EndpointInfo = qi, e(Bi.prototype, { getEndCapStyle: function() {
        return this.endCapStyle;
      }, isSingleSided: function() {
        return this._isSingleSided;
      }, setQuadrantSegments: function(t2) {
        this.quadrantSegments = t2, 0 === this.quadrantSegments && (this.joinStyle = Bi.JOIN_BEVEL), this.quadrantSegments < 0 && (this.joinStyle = Bi.JOIN_MITRE, this.mitreLimit = Math.abs(this.quadrantSegments)), 0 >= t2 && (this.quadrantSegments = 1), this.joinStyle !== Bi.JOIN_ROUND && (this.quadrantSegments = Bi.DEFAULT_QUADRANT_SEGMENTS);
      }, getJoinStyle: function() {
        return this.joinStyle;
      }, setJoinStyle: function(t2) {
        this.joinStyle = t2;
      }, setSimplifyFactor: function(t2) {
        this.simplifyFactor = 0 > t2 ? 0 : t2;
      }, getSimplifyFactor: function() {
        return this.simplifyFactor;
      }, getQuadrantSegments: function() {
        return this.quadrantSegments;
      }, setEndCapStyle: function(t2) {
        this.endCapStyle = t2;
      }, getMitreLimit: function() {
        return this.mitreLimit;
      }, setMitreLimit: function(t2) {
        this.mitreLimit = t2;
      }, setSingleSided: function(t2) {
        this._isSingleSided = t2;
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return Bi;
      } }), Bi.bufferDistanceError = function(t2) {
        var e2 = Math.PI / 2 / t2;
        return 1 - Math.cos(e2 / 2);
      }, Bi.CAP_ROUND = 1, Bi.CAP_FLAT = 2, Bi.CAP_SQUARE = 3, Bi.JOIN_ROUND = 1, Bi.JOIN_MITRE = 2, Bi.JOIN_BEVEL = 3, Bi.DEFAULT_QUADRANT_SEGMENTS = 8, Bi.DEFAULT_MITRE_LIMIT = 5, Bi.DEFAULT_SIMPLIFY_FACTOR = 0.01, e(zi.prototype, { getCoordinate: function() {
        return this.minCoord;
      }, getRightmostSide: function(t2, e2) {
        var n2 = this.getRightmostSideOfSegment(t2, e2);
        return 0 > n2 && (n2 = this.getRightmostSideOfSegment(t2, e2 - 1)), 0 > n2 && (this.minCoord = null, this.checkForRightmostCoordinate(t2)), n2;
      }, findRightmostEdgeAtVertex: function() {
        var t2 = this.minDe.getEdge().getCoordinates();
        f.isTrue(this.minIndex > 0 && this.minIndex < t2.length, "rightmost point expected to be interior vertex of edge");
        var e2 = t2[this.minIndex - 1], n2 = t2[this.minIndex + 1], i3 = he.computeOrientation(this.minCoord, n2, e2), r2 = false;
        e2.y < this.minCoord.y && n2.y < this.minCoord.y && i3 === he.COUNTERCLOCKWISE ? r2 = true : e2.y > this.minCoord.y && n2.y > this.minCoord.y && i3 === he.CLOCKWISE && (r2 = true), r2 && (this.minIndex = this.minIndex - 1);
      }, getRightmostSideOfSegment: function(t2, e2) {
        var n2 = t2.getEdge(), i3 = n2.getCoordinates();
        if (0 > e2 || e2 + 1 >= i3.length)
          return -1;
        if (i3[e2].y === i3[e2 + 1].y)
          return -1;
        var r2 = cn.LEFT;
        return i3[e2].y < i3[e2 + 1].y && (r2 = cn.RIGHT), r2;
      }, getEdge: function() {
        return this.orientedDe;
      }, checkForRightmostCoordinate: function(t2) {
        for (var e2 = t2.getEdge().getCoordinates(), n2 = 0; n2 < e2.length - 1; n2++)
          (null === this.minCoord || e2[n2].x > this.minCoord.x) && (this.minDe = t2, this.minIndex = n2, this.minCoord = e2[n2]);
      }, findRightmostEdgeAtNode: function() {
        var t2 = this.minDe.getNode(), e2 = t2.getEdges();
        this.minDe = e2.getRightmostEdge(), this.minDe.isForward() || (this.minDe = this.minDe.getSym(), this.minIndex = this.minDe.getEdge().getCoordinates().length - 1);
      }, findEdge: function(t2) {
        for (var e2 = t2.iterator(); e2.hasNext(); ) {
          var n2 = e2.next();
          n2.isForward() && this.checkForRightmostCoordinate(n2);
        }
        f.isTrue(0 !== this.minIndex || this.minCoord.equals(this.minDe.getCoordinate()), "inconsistency in rightmost processing"), 0 === this.minIndex ? this.findRightmostEdgeAtNode() : this.findRightmostEdgeAtVertex(), this.orientedDe = this.minDe;
        var i3 = this.getRightmostSide(this.minDe, this.minIndex);
        i3 === cn.LEFT && (this.orientedDe = this.minDe.getSym());
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return zi;
      } }), Vi.prototype.addLast = function(t2) {
        this.array_.push(t2);
      }, Vi.prototype.removeFirst = function() {
        return this.array_.shift();
      }, Vi.prototype.isEmpty = function() {
        return 0 === this.array_.length;
      }, e(ki.prototype, { clearVisitedEdges: function() {
        for (var t2 = this.dirEdgeList.iterator(); t2.hasNext(); ) {
          var e2 = t2.next();
          e2.setVisited(false);
        }
      }, getRightmostCoordinate: function() {
        return this.rightMostCoord;
      }, computeNodeDepth: function(t2) {
        for (var e2 = null, n2 = t2.getEdges().iterator(); n2.hasNext(); ) {
          var i3 = n2.next();
          if (i3.isVisited() || i3.getSym().isVisited()) {
            e2 = i3;
            break;
          }
        }
        if (null === e2)
          throw new sn("unable to find edge to compute depths at " + t2.getCoordinate());
        t2.getEdges().computeDepths(e2);
        for (var n2 = t2.getEdges().iterator(); n2.hasNext(); ) {
          var i3 = n2.next();
          i3.setVisited(true), this.copySymDepths(i3);
        }
      }, computeDepth: function(t2) {
        this.clearVisitedEdges();
        var e2 = this.finder.getEdge();
        e2.getNode(), e2.getLabel();
        e2.setEdgeDepths(cn.RIGHT, t2), this.copySymDepths(e2), this.computeDepths(e2);
      }, create: function(t2) {
        this.addReachable(t2), this.finder.findEdge(this.dirEdgeList), this.rightMostCoord = this.finder.getCoordinate();
      }, findResultEdges: function() {
        for (var t2 = this.dirEdgeList.iterator(); t2.hasNext(); ) {
          var e2 = t2.next();
          e2.getDepth(cn.RIGHT) >= 1 && e2.getDepth(cn.LEFT) <= 0 && !e2.isInteriorAreaEdge() && e2.setInResult(true);
        }
      }, computeDepths: function(t2) {
        var e2 = new J(), n2 = new Vi(), i3 = t2.getNode();
        for (n2.addLast(i3), e2.add(i3), t2.setVisited(true); !n2.isEmpty(); ) {
          var r2 = n2.removeFirst();
          e2.add(r2), this.computeNodeDepth(r2);
          for (var s2 = r2.getEdges().iterator(); s2.hasNext(); ) {
            var o2 = s2.next(), a2 = o2.getSym();
            if (!a2.isVisited()) {
              var u2 = a2.getNode();
              e2.contains(u2) || (n2.addLast(u2), e2.add(u2));
            }
          }
        }
      }, compareTo: function(t2) {
        var e2 = t2;
        return this.rightMostCoord.x < e2.rightMostCoord.x ? -1 : this.rightMostCoord.x > e2.rightMostCoord.x ? 1 : 0;
      }, getEnvelope: function() {
        if (null === this.env) {
          for (var t2 = new C(), e2 = this.dirEdgeList.iterator(); e2.hasNext(); )
            for (var n2 = e2.next(), i3 = n2.getEdge().getCoordinates(), r2 = 0; r2 < i3.length - 1; r2++)
              t2.expandToInclude(i3[r2]);
          this.env = t2;
        }
        return this.env;
      }, addReachable: function(t2) {
        var e2 = new pe();
        for (e2.add(t2); !e2.empty(); ) {
          var n2 = e2.pop();
          this.add(n2, e2);
        }
      }, copySymDepths: function(t2) {
        var e2 = t2.getSym();
        e2.setDepth(cn.LEFT, t2.getDepth(cn.RIGHT)), e2.setDepth(cn.RIGHT, t2.getDepth(cn.LEFT));
      }, add: function(t2, e2) {
        t2.setVisited(true), this.nodes.add(t2);
        for (var n2 = t2.getEdges().iterator(); n2.hasNext(); ) {
          var i3 = n2.next();
          this.dirEdgeList.add(i3);
          var r2 = i3.getSym(), s2 = r2.getNode();
          s2.isVisited() || e2.push(s2);
        }
      }, getNodes: function() {
        return this.nodes;
      }, getDirectedEdges: function() {
        return this.dirEdgeList;
      }, interfaces_: function() {
        return [s];
      }, getClass: function() {
        return ki;
      } }), e(Yi.prototype, { isDeletable: function(t2, e2, n2, i3) {
        var r2 = this.inputLine[t2], s2 = this.inputLine[e2], o2 = this.inputLine[n2];
        return this.isConcave(r2, s2, o2) && this.isShallow(r2, s2, o2, i3) ? this.isShallowSampled(r2, s2, t2, n2, i3) : false;
      }, deleteShallowConcavities: function() {
        for (var t2 = 1, e2 = (this.inputLine.length - 1, this.findNextNonDeletedIndex(t2)), n2 = this.findNextNonDeletedIndex(e2), i3 = false; n2 < this.inputLine.length; ) {
          var r2 = false;
          this.isDeletable(t2, e2, n2, this.distanceTol) && (this.isDeleted[e2] = Yi.DELETE, r2 = true, i3 = true), t2 = r2 ? n2 : e2, e2 = this.findNextNonDeletedIndex(t2), n2 = this.findNextNonDeletedIndex(e2);
        }
        return i3;
      }, isShallowConcavity: function(t2, e2, n2, i3) {
        var r2 = he.computeOrientation(t2, e2, n2), s2 = r2 === this.angleOrientation;
        if (!s2)
          return false;
        var o2 = he.distancePointLine(e2, t2, n2);
        return i3 > o2;
      }, isShallowSampled: function(t2, e2, n2, i3, r2) {
        var s2 = Math.trunc((i3 - n2) / Yi.NUM_PTS_TO_CHECK);
        0 >= s2 && (s2 = 1);
        for (var o2 = n2; i3 > o2; o2 += s2)
          if (!this.isShallow(t2, e2, this.inputLine[o2], r2))
            return false;
        return true;
      }, isConcave: function t2(e2, n2, i3) {
        var r2 = he.computeOrientation(e2, n2, i3), t3 = r2 === this.angleOrientation;
        return t3;
      }, simplify: function(t2) {
        this.distanceTol = Math.abs(t2), 0 > t2 && (this.angleOrientation = he.CLOCKWISE), this.isDeleted = new Array(this.inputLine.length).fill(null);
        var e2 = false;
        do
          e2 = this.deleteShallowConcavities();
        while (e2);
        return this.collapseLine();
      }, findNextNonDeletedIndex: function(t2) {
        for (var e2 = t2 + 1; e2 < this.inputLine.length && this.isDeleted[e2] === Yi.DELETE; )
          e2++;
        return e2;
      }, isShallow: function(t2, e2, n2, i3) {
        var r2 = he.distancePointLine(e2, t2, n2);
        return i3 > r2;
      }, collapseLine: function() {
        for (var t2 = new N(), e2 = 0; e2 < this.inputLine.length; e2++)
          this.isDeleted[e2] !== Yi.DELETE && t2.add(this.inputLine[e2]);
        return t2.toCoordinateArray();
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return Yi;
      } }), Yi.simplify = function(t2, e2) {
        var n2 = new Yi(t2);
        return n2.simplify(e2);
      }, Yi.INIT = 0, Yi.DELETE = 1, Yi.KEEP = 1, Yi.NUM_PTS_TO_CHECK = 10, e(Ui.prototype, { getCoordinates: function() {
        var t2 = this.ptList.toArray(Ui.COORDINATE_ARRAY_TYPE);
        return t2;
      }, setPrecisionModel: function(t2) {
        this.precisionModel = t2;
      }, addPt: function(t2) {
        var e2 = new g(t2);
        return this.precisionModel.makePrecise(e2), this.isRedundant(e2) ? null : void this.ptList.add(e2);
      }, reverse: function() {
      }, addPts: function(t2, e2) {
        if (e2)
          for (var n2 = 0; n2 < t2.length; n2++)
            this.addPt(t2[n2]);
        else
          for (var n2 = t2.length - 1; n2 >= 0; n2--)
            this.addPt(t2[n2]);
      }, isRedundant: function(t2) {
        if (this.ptList.size() < 1)
          return false;
        var e2 = this.ptList.get(this.ptList.size() - 1), n2 = t2.distance(e2);
        return n2 < this.minimimVertexDistance;
      }, toString: function() {
        var t2 = new ie(), e2 = t2.createLineString(this.getCoordinates());
        return e2.toString();
      }, closeRing: function() {
        if (this.ptList.size() < 1)
          return null;
        var t2 = new g(this.ptList.get(0)), e2 = this.ptList.get(this.ptList.size() - 1), n2 = null;
        return this.ptList.size() >= 2 && (n2 = this.ptList.get(this.ptList.size() - 2)), t2.equals(e2) ? null : void this.ptList.add(t2);
      }, setMinimumVertexDistance: function(t2) {
        this.minimimVertexDistance = t2;
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return Ui;
      } }), Ui.COORDINATE_ARRAY_TYPE = new Array(0).fill(null), e(Xi.prototype, { addNextSegment: function(t2, e2) {
        if (this.s0 = this.s1, this.s1 = this.s2, this.s2 = t2, this.seg0.setCoordinates(this.s0, this.s1), this.computeOffsetSegment(this.seg0, this.side, this.distance, this.offset0), this.seg1.setCoordinates(this.s1, this.s2), this.computeOffsetSegment(this.seg1, this.side, this.distance, this.offset1), this.s1.equals(this.s2))
          return null;
        var n2 = he.computeOrientation(this.s0, this.s1, this.s2), i3 = n2 === he.CLOCKWISE && this.side === cn.LEFT || n2 === he.COUNTERCLOCKWISE && this.side === cn.RIGHT;
        0 === n2 ? this.addCollinear(e2) : i3 ? this.addOutsideTurn(n2, e2) : this.addInsideTurn(n2, e2);
      }, addLineEndCap: function(t2, e2) {
        var n2 = new ce(t2, e2), i3 = new ce();
        this.computeOffsetSegment(n2, cn.LEFT, this.distance, i3);
        var r2 = new ce();
        this.computeOffsetSegment(n2, cn.RIGHT, this.distance, r2);
        var s2 = e2.x - t2.x, o2 = e2.y - t2.y, a2 = Math.atan2(o2, s2);
        switch (this.bufParams.getEndCapStyle()) {
          case Bi.CAP_ROUND:
            this.segList.addPt(i3.p1), this.addFilletArc(e2, a2 + Math.PI / 2, a2 - Math.PI / 2, he.CLOCKWISE, this.distance), this.segList.addPt(r2.p1);
            break;
          case Bi.CAP_FLAT:
            this.segList.addPt(i3.p1), this.segList.addPt(r2.p1);
            break;
          case Bi.CAP_SQUARE:
            var u2 = new g();
            u2.x = Math.abs(this.distance) * Math.cos(a2), u2.y = Math.abs(this.distance) * Math.sin(a2);
            var l2 = new g(i3.p1.x + u2.x, i3.p1.y + u2.y), h2 = new g(r2.p1.x + u2.x, r2.p1.y + u2.y);
            this.segList.addPt(l2), this.segList.addPt(h2);
        }
      }, getCoordinates: function() {
        var t2 = this.segList.getCoordinates();
        return t2;
      }, addMitreJoin: function(t2, e2, n2, i3) {
        var r2 = true, s2 = null;
        try {
          s2 = F.intersection(e2.p0, e2.p1, n2.p0, n2.p1);
          var o2 = 0 >= i3 ? 1 : s2.distance(t2) / Math.abs(i3);
          o2 > this.bufParams.getMitreLimit() && (r2 = false);
        } catch (t3) {
          if (!(t3 instanceof w))
            throw t3;
          s2 = new g(0, 0), r2 = false;
        } finally {
        }
        r2 ? this.segList.addPt(s2) : this.addLimitedMitreJoin(e2, n2, i3, this.bufParams.getMitreLimit());
      }, addFilletCorner: function(t2, e2, n2, i3, r2) {
        var s2 = e2.x - t2.x, o2 = e2.y - t2.y, a2 = Math.atan2(o2, s2), u2 = n2.x - t2.x, l2 = n2.y - t2.y, h2 = Math.atan2(l2, u2);
        i3 === he.CLOCKWISE ? h2 >= a2 && (a2 += 2 * Math.PI) : a2 >= h2 && (a2 -= 2 * Math.PI), this.segList.addPt(e2), this.addFilletArc(t2, a2, h2, i3, r2), this.segList.addPt(n2);
      }, addOutsideTurn: function(t2, e2) {
        return this.offset0.p1.distance(this.offset1.p0) < this.distance * Xi.OFFSET_SEGMENT_SEPARATION_FACTOR ? (this.segList.addPt(this.offset0.p1), null) : void (this.bufParams.getJoinStyle() === Bi.JOIN_MITRE ? this.addMitreJoin(this.s1, this.offset0, this.offset1, this.distance) : this.bufParams.getJoinStyle() === Bi.JOIN_BEVEL ? this.addBevelJoin(this.offset0, this.offset1) : (e2 && this.segList.addPt(this.offset0.p1), this.addFilletCorner(this.s1, this.offset0.p1, this.offset1.p0, t2, this.distance), this.segList.addPt(this.offset1.p0)));
      }, createSquare: function(t2) {
        this.segList.addPt(new g(t2.x + this.distance, t2.y + this.distance)), this.segList.addPt(new g(t2.x + this.distance, t2.y - this.distance)), this.segList.addPt(new g(t2.x - this.distance, t2.y - this.distance)), this.segList.addPt(new g(t2.x - this.distance, t2.y + this.distance)), this.segList.closeRing();
      }, addSegments: function(t2, e2) {
        this.segList.addPts(t2, e2);
      }, addFirstSegment: function() {
        this.segList.addPt(this.offset1.p0);
      }, addLastSegment: function() {
        this.segList.addPt(this.offset1.p1);
      }, initSideSegments: function(t2, e2, n2) {
        this.s1 = t2, this.s2 = e2, this.side = n2, this.seg1.setCoordinates(t2, e2), this.computeOffsetSegment(this.seg1, n2, this.distance, this.offset1);
      }, addLimitedMitreJoin: function(t2, e2, n2, i3) {
        var r2 = this.seg0.p1, s2 = hi.angle(r2, this.seg0.p0), o2 = (hi.angle(r2, this.seg1.p1), hi.angleBetweenOriented(this.seg0.p0, r2, this.seg1.p1)), a2 = o2 / 2, u2 = hi.normalize(s2 + a2), l2 = hi.normalize(u2 + Math.PI), h2 = i3 * n2, c2 = h2 * Math.abs(Math.sin(a2)), f2 = n2 - c2, d2 = r2.x + h2 * Math.cos(l2), p2 = r2.y + h2 * Math.sin(l2), v2 = new g(d2, p2), m2 = new ce(r2, v2), y2 = m2.pointAlongOffset(1, f2), x2 = m2.pointAlongOffset(1, -f2);
        this.side === cn.LEFT ? (this.segList.addPt(y2), this.segList.addPt(x2)) : (this.segList.addPt(x2), this.segList.addPt(y2));
      }, computeOffsetSegment: function(t2, e2, n2, i3) {
        var r2 = e2 === cn.LEFT ? 1 : -1, s2 = t2.p1.x - t2.p0.x, o2 = t2.p1.y - t2.p0.y, a2 = Math.sqrt(s2 * s2 + o2 * o2), u2 = r2 * n2 * s2 / a2, l2 = r2 * n2 * o2 / a2;
        i3.p0.x = t2.p0.x - l2, i3.p0.y = t2.p0.y + u2, i3.p1.x = t2.p1.x - l2, i3.p1.y = t2.p1.y + u2;
      }, addFilletArc: function(t2, e2, n2, i3, r2) {
        var s2 = i3 === he.CLOCKWISE ? -1 : 1, o2 = Math.abs(e2 - n2), a2 = Math.trunc(o2 / this.filletAngleQuantum + 0.5);
        if (1 > a2)
          return null;
        var u2 = null, l2 = null;
        u2 = 0, l2 = o2 / a2;
        for (var h2 = u2, c2 = new g(); o2 > h2; ) {
          var f2 = e2 + s2 * h2;
          c2.x = t2.x + r2 * Math.cos(f2), c2.y = t2.y + r2 * Math.sin(f2), this.segList.addPt(c2), h2 += l2;
        }
      }, addInsideTurn: function(t2, e2) {
        if (this.li.computeIntersection(this.offset0.p0, this.offset0.p1, this.offset1.p0, this.offset1.p1), this.li.hasIntersection())
          this.segList.addPt(this.li.getIntersection(0));
        else if (this._hasNarrowConcaveAngle = true, this.offset0.p1.distance(this.offset1.p0) < this.distance * Xi.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR)
          this.segList.addPt(this.offset0.p1);
        else {
          if (this.segList.addPt(this.offset0.p1), this.closingSegLengthFactor > 0) {
            var n2 = new g((this.closingSegLengthFactor * this.offset0.p1.x + this.s1.x) / (this.closingSegLengthFactor + 1), (this.closingSegLengthFactor * this.offset0.p1.y + this.s1.y) / (this.closingSegLengthFactor + 1));
            this.segList.addPt(n2);
            var i3 = new g((this.closingSegLengthFactor * this.offset1.p0.x + this.s1.x) / (this.closingSegLengthFactor + 1), (this.closingSegLengthFactor * this.offset1.p0.y + this.s1.y) / (this.closingSegLengthFactor + 1));
            this.segList.addPt(i3);
          } else
            this.segList.addPt(this.s1);
          this.segList.addPt(this.offset1.p0);
        }
      }, createCircle: function(t2) {
        var e2 = new g(t2.x + this.distance, t2.y);
        this.segList.addPt(e2), this.addFilletArc(t2, 0, 2 * Math.PI, -1, this.distance), this.segList.closeRing();
      }, addBevelJoin: function(t2, e2) {
        this.segList.addPt(t2.p1), this.segList.addPt(e2.p0);
      }, init: function(t2) {
        this.distance = t2, this.maxCurveSegmentError = t2 * (1 - Math.cos(this.filletAngleQuantum / 2)), this.segList = new Ui(), this.segList.setPrecisionModel(this.precisionModel), this.segList.setMinimumVertexDistance(t2 * Xi.CURVE_VERTEX_SNAP_DISTANCE_FACTOR);
      }, addCollinear: function(t2) {
        this.li.computeIntersection(this.s0, this.s1, this.s1, this.s2);
        var e2 = this.li.getIntersectionNum();
        e2 >= 2 && (this.bufParams.getJoinStyle() === Bi.JOIN_BEVEL || this.bufParams.getJoinStyle() === Bi.JOIN_MITRE ? (t2 && this.segList.addPt(this.offset0.p1), this.segList.addPt(this.offset1.p0)) : this.addFilletCorner(this.s1, this.offset0.p1, this.offset1.p0, he.CLOCKWISE, this.distance));
      }, closeRing: function() {
        this.segList.closeRing();
      }, hasNarrowConcaveAngle: function() {
        return this._hasNarrowConcaveAngle;
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return Xi;
      } }), Xi.OFFSET_SEGMENT_SEPARATION_FACTOR = 1e-3, Xi.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR = 1e-3, Xi.CURVE_VERTEX_SNAP_DISTANCE_FACTOR = 1e-6, Xi.MAX_CLOSING_SEG_LEN_FACTOR = 80, e(Hi.prototype, { getOffsetCurve: function(t2, e2) {
        if (this.distance = e2, 0 === e2)
          return null;
        var n2 = 0 > e2, i3 = Math.abs(e2), r2 = this.getSegGen(i3);
        t2.length <= 1 ? this.computePointCurve(t2[0], r2) : this.computeOffsetCurve(t2, n2, r2);
        var s2 = r2.getCoordinates();
        return n2 && H.reverse(s2), s2;
      }, computeSingleSidedBufferCurve: function(t2, e2, n2) {
        var i3 = this.simplifyTolerance(this.distance);
        if (e2) {
          n2.addSegments(t2, true);
          var r2 = Yi.simplify(t2, -i3), s2 = r2.length - 1;
          n2.initSideSegments(r2[s2], r2[s2 - 1], cn.LEFT), n2.addFirstSegment();
          for (var o2 = s2 - 2; o2 >= 0; o2--)
            n2.addNextSegment(r2[o2], true);
        } else {
          n2.addSegments(t2, false);
          var a2 = Yi.simplify(t2, i3), u2 = a2.length - 1;
          n2.initSideSegments(a2[0], a2[1], cn.LEFT), n2.addFirstSegment();
          for (var o2 = 2; u2 >= o2; o2++)
            n2.addNextSegment(a2[o2], true);
        }
        n2.addLastSegment(), n2.closeRing();
      }, computeRingBufferCurve: function(t2, e2, n2) {
        var i3 = this.simplifyTolerance(this.distance);
        e2 === cn.RIGHT && (i3 = -i3);
        var r2 = Yi.simplify(t2, i3), s2 = r2.length - 1;
        n2.initSideSegments(r2[s2 - 1], r2[0], e2);
        for (var o2 = 1; s2 >= o2; o2++) {
          var a2 = 1 !== o2;
          n2.addNextSegment(r2[o2], a2);
        }
        n2.closeRing();
      }, computeLineBufferCurve: function(t2, e2) {
        var n2 = this.simplifyTolerance(this.distance), i3 = Yi.simplify(t2, n2), r2 = i3.length - 1;
        e2.initSideSegments(i3[0], i3[1], cn.LEFT);
        for (var s2 = 2; r2 >= s2; s2++)
          e2.addNextSegment(i3[s2], true);
        e2.addLastSegment(), e2.addLineEndCap(i3[r2 - 1], i3[r2]);
        var o2 = Yi.simplify(t2, -n2), a2 = o2.length - 1;
        e2.initSideSegments(o2[a2], o2[a2 - 1], cn.LEFT);
        for (var s2 = a2 - 2; s2 >= 0; s2--)
          e2.addNextSegment(o2[s2], true);
        e2.addLastSegment(), e2.addLineEndCap(o2[1], o2[0]), e2.closeRing();
      }, computePointCurve: function(t2, e2) {
        switch (this.bufParams.getEndCapStyle()) {
          case Bi.CAP_ROUND:
            e2.createCircle(t2);
            break;
          case Bi.CAP_SQUARE:
            e2.createSquare(t2);
        }
      }, getLineCurve: function(t2, e2) {
        if (this.distance = e2, 0 > e2 && !this.bufParams.isSingleSided())
          return null;
        if (0 === e2)
          return null;
        var n2 = Math.abs(e2), i3 = this.getSegGen(n2);
        if (t2.length <= 1)
          this.computePointCurve(t2[0], i3);
        else if (this.bufParams.isSingleSided()) {
          var r2 = 0 > e2;
          this.computeSingleSidedBufferCurve(t2, r2, i3);
        } else
          this.computeLineBufferCurve(t2, i3);
        var s2 = i3.getCoordinates();
        return s2;
      }, getBufferParameters: function() {
        return this.bufParams;
      }, simplifyTolerance: function(t2) {
        return t2 * this.bufParams.getSimplifyFactor();
      }, getRingCurve: function(t2, e2, n2) {
        if (this.distance = n2, t2.length <= 2)
          return this.getLineCurve(t2, n2);
        if (0 === n2)
          return Hi.copyCoordinates(t2);
        var i3 = this.getSegGen(n2);
        return this.computeRingBufferCurve(t2, e2, i3), i3.getCoordinates();
      }, computeOffsetCurve: function(t2, e2, n2) {
        var i3 = this.simplifyTolerance(this.distance);
        if (e2) {
          var r2 = Yi.simplify(t2, -i3), s2 = r2.length - 1;
          n2.initSideSegments(r2[s2], r2[s2 - 1], cn.LEFT), n2.addFirstSegment();
          for (var o2 = s2 - 2; o2 >= 0; o2--)
            n2.addNextSegment(r2[o2], true);
        } else {
          var a2 = Yi.simplify(t2, i3), u2 = a2.length - 1;
          n2.initSideSegments(a2[0], a2[1], cn.LEFT), n2.addFirstSegment();
          for (var o2 = 2; u2 >= o2; o2++)
            n2.addNextSegment(a2[o2], true);
        }
        n2.addLastSegment();
      }, getSegGen: function(t2) {
        return new Xi(this.precisionModel, this.bufParams, t2);
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return Hi;
      } }), Hi.copyCoordinates = function(t2) {
        for (var e2 = new Array(t2.length).fill(null), n2 = 0; n2 < e2.length; n2++)
          e2[n2] = new g(t2[n2]);
        return e2;
      }, e(Wi.prototype, { findStabbedSegments: function() {
        if (1 === arguments.length) {
          for (var t2 = arguments[0], e2 = new I(), n2 = this.subgraphs.iterator(); n2.hasNext(); ) {
            var i3 = n2.next(), r2 = i3.getEnvelope();
            t2.y < r2.getMinY() || t2.y > r2.getMaxY() || this.findStabbedSegments(t2, i3.getDirectedEdges(), e2);
          }
          return e2;
        }
        if (3 === arguments.length) {
          if (R(arguments[2], y) && arguments[0] instanceof g && arguments[1] instanceof In)
            for (var s2 = arguments[0], o2 = arguments[1], a2 = arguments[2], u2 = o2.getEdge().getCoordinates(), n2 = 0; n2 < u2.length - 1; n2++) {
              this.seg.p0 = u2[n2], this.seg.p1 = u2[n2 + 1], this.seg.p0.y > this.seg.p1.y && this.seg.reverse();
              var l2 = Math.max(this.seg.p0.x, this.seg.p1.x);
              if (!(l2 < s2.x || this.seg.isHorizontal() || s2.y < this.seg.p0.y || s2.y > this.seg.p1.y || he.computeOrientation(this.seg.p0, this.seg.p1, s2) === he.RIGHT)) {
                var h2 = o2.getDepth(cn.LEFT);
                this.seg.p0.equals(u2[n2]) || (h2 = o2.getDepth(cn.RIGHT));
                var c2 = new ji(this.seg, h2);
                a2.add(c2);
              }
            }
          else if (R(arguments[2], y) && arguments[0] instanceof g && R(arguments[1], y))
            for (var f2 = arguments[0], d2 = arguments[1], p2 = arguments[2], n2 = d2.iterator(); n2.hasNext(); ) {
              var v2 = n2.next();
              v2.isForward() && this.findStabbedSegments(f2, v2, p2);
            }
        }
      }, getDepth: function(t2) {
        var e2 = this.findStabbedSegments(t2);
        if (0 === e2.size())
          return 0;
        var n2 = ho.min(e2);
        return n2.leftDepth;
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return Wi;
      } }), e(ji.prototype, { compareTo: function(t2) {
        var e2 = t2;
        if (this.upwardSeg.minX() >= e2.upwardSeg.maxX())
          return 1;
        if (this.upwardSeg.maxX() <= e2.upwardSeg.minX())
          return -1;
        var n2 = this.upwardSeg.orientationIndex(e2.upwardSeg);
        return 0 !== n2 ? n2 : (n2 = -1 * e2.upwardSeg.orientationIndex(this.upwardSeg), 0 !== n2 ? n2 : this.upwardSeg.compareTo(e2.upwardSeg));
      }, compareX: function(t2, e2) {
        var n2 = t2.p0.compareTo(e2.p0);
        return 0 !== n2 ? n2 : t2.p1.compareTo(e2.p1);
      }, toString: function() {
        return this.upwardSeg.toString();
      }, interfaces_: function() {
        return [s];
      }, getClass: function() {
        return ji;
      } }), Wi.DepthSegment = ji, e(Ki.prototype, { addPoint: function(t2) {
        if (this.distance <= 0)
          return null;
        var e2 = t2.getCoordinates(), n2 = this.curveBuilder.getLineCurve(e2, this.distance);
        this.addCurve(n2, L.EXTERIOR, L.INTERIOR);
      }, addPolygon: function(t2) {
        var e2 = this.distance, n2 = cn.LEFT;
        this.distance < 0 && (e2 = -this.distance, n2 = cn.RIGHT);
        var i3 = t2.getExteriorRing(), r2 = H.removeRepeatedPoints(i3.getCoordinates());
        if (this.distance < 0 && this.isErodedCompletely(i3, this.distance))
          return null;
        if (this.distance <= 0 && r2.length < 3)
          return null;
        this.addPolygonRing(r2, e2, n2, L.EXTERIOR, L.INTERIOR);
        for (var s2 = 0; s2 < t2.getNumInteriorRing(); s2++) {
          var o2 = t2.getInteriorRingN(s2), a2 = H.removeRepeatedPoints(o2.getCoordinates());
          this.distance > 0 && this.isErodedCompletely(o2, -this.distance) || this.addPolygonRing(a2, e2, cn.opposite(n2), L.INTERIOR, L.EXTERIOR);
        }
      }, isTriangleErodedCompletely: function(t2, e2) {
        var n2 = new ci(t2[0], t2[1], t2[2]), i3 = n2.inCentre(), r2 = he.distancePointLine(i3, n2.p0, n2.p1);
        return r2 < Math.abs(e2);
      }, addLineString: function(t2) {
        if (this.distance <= 0 && !this.curveBuilder.getBufferParameters().isSingleSided())
          return null;
        var e2 = H.removeRepeatedPoints(t2.getCoordinates()), n2 = this.curveBuilder.getLineCurve(e2, this.distance);
        this.addCurve(n2, L.EXTERIOR, L.INTERIOR);
      }, addCurve: function(t2, e2, n2) {
        if (null === t2 || t2.length < 2)
          return null;
        var i3 = new Ke(t2, new gn(0, L.BOUNDARY, e2, n2));
        this.curveList.add(i3);
      }, getCurves: function() {
        return this.add(this.inputGeom), this.curveList;
      }, addPolygonRing: function(t2, e2, n2, i3, r2) {
        if (0 === e2 && t2.length < bt.MINIMUM_VALID_SIZE)
          return null;
        var s2 = i3, o2 = r2;
        t2.length >= bt.MINIMUM_VALID_SIZE && he.isCCW(t2) && (s2 = r2, o2 = i3, n2 = cn.opposite(n2));
        var a2 = this.curveBuilder.getRingCurve(t2, n2, e2);
        this.addCurve(a2, s2, o2);
      }, add: function(t2) {
        if (t2.isEmpty())
          return null;
        if (t2 instanceof Tt)
          this.addPolygon(t2);
        else if (t2 instanceof St)
          this.addLineString(t2);
        else if (t2 instanceof Lt)
          this.addPoint(t2);
        else if (t2 instanceof Pt)
          this.addCollection(t2);
        else if (t2 instanceof gt)
          this.addCollection(t2);
        else if (t2 instanceof Ot)
          this.addCollection(t2);
        else {
          if (!(t2 instanceof ft))
            throw new UnsupportedOperationException(t2.getClass().getName());
          this.addCollection(t2);
        }
      }, isErodedCompletely: function(t2, e2) {
        var n2 = t2.getCoordinates();
        if (n2.length < 4)
          return 0 > e2;
        if (4 === n2.length)
          return this.isTriangleErodedCompletely(n2, e2);
        var i3 = t2.getEnvelopeInternal(), r2 = Math.min(i3.getHeight(), i3.getWidth());
        return 0 > e2 && 2 * Math.abs(e2) > r2;
      }, addCollection: function(t2) {
        for (var e2 = 0; e2 < t2.getNumGeometries(); e2++) {
          var n2 = t2.getGeometryN(e2);
          this.add(n2);
        }
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return Ki;
      } }), e(Zi.prototype, { isTrivialIntersection: function(t2, e2, n2, i3) {
        if (t2 === n2 && 1 === this.li.getIntersectionNum()) {
          if (Zi.isAdjacentSegments(e2, i3))
            return true;
          if (t2.isClosed()) {
            var r2 = t2.size() - 1;
            if (0 === e2 && i3 === r2 || 0 === i3 && e2 === r2)
              return true;
          }
        }
        return false;
      }, getProperIntersectionPoint: function() {
        return this.properIntersectionPoint;
      }, hasProperInteriorIntersection: function() {
        return this.hasProperInterior;
      }, getLineIntersector: function() {
        return this.li;
      }, hasProperIntersection: function() {
        return this.hasProper;
      }, processIntersections: function(t2, e2, n2, i3) {
        if (t2 === n2 && e2 === i3)
          return null;
        this.numTests++;
        var r2 = t2.getCoordinates()[e2], s2 = t2.getCoordinates()[e2 + 1], o2 = n2.getCoordinates()[i3], a2 = n2.getCoordinates()[i3 + 1];
        this.li.computeIntersection(r2, s2, o2, a2), this.li.hasIntersection() && (this.numIntersections++, this.li.isInteriorIntersection() && (this.numInteriorIntersections++, this.hasInterior = true), this.isTrivialIntersection(t2, e2, n2, i3) || (this._hasIntersection = true, t2.addIntersections(this.li, e2, 0), n2.addIntersections(this.li, i3, 1), this.li.isProper() && (this.numProperIntersections++, this.hasProper = true, this.hasProperInterior = true)));
      }, hasIntersection: function() {
        return this._hasIntersection;
      }, isDone: function() {
        return false;
      }, hasInteriorIntersection: function() {
        return this.hasInterior;
      }, interfaces_: function() {
        return [on];
      }, getClass: function() {
        return Zi;
      } }), Zi.isAdjacentSegments = function(t2, e2) {
        return 1 === Math.abs(t2 - e2);
      }, e(Qi.prototype, { setWorkingPrecisionModel: function(t2) {
        this.workingPrecisionModel = t2;
      }, insertUniqueEdge: function(t2) {
        var e2 = this.edgeList.findEqualEdge(t2);
        if (null !== e2) {
          var n2 = e2.getLabel(), i3 = t2.getLabel();
          e2.isPointwiseEqual(t2) || (i3 = new gn(t2.getLabel()), i3.flip()), n2.merge(i3);
          var r2 = Qi.depthDelta(i3), s2 = e2.getDepthDelta(), o2 = s2 + r2;
          e2.setDepthDelta(o2);
        } else
          this.edgeList.add(t2), t2.setDepthDelta(Qi.depthDelta(t2.getLabel()));
      }, buildSubgraphs: function(t2, e2) {
        for (var n2 = new I(), i3 = t2.iterator(); i3.hasNext(); ) {
          var r2 = i3.next(), s2 = r2.getRightmostCoordinate(), o2 = new Wi(n2), a2 = o2.getDepth(s2);
          r2.computeDepth(a2), r2.findResultEdges(), n2.add(r2), e2.add(r2.getDirectedEdges(), r2.getNodes());
        }
      }, createSubgraphs: function(t2) {
        for (var e2 = new I(), n2 = t2.getNodes().iterator(); n2.hasNext(); ) {
          var i3 = n2.next();
          if (!i3.isVisited()) {
            var r2 = new ki();
            r2.create(i3), e2.add(r2);
          }
        }
        return ho.sort(e2, ho.reverseOrder()), e2;
      }, createEmptyResultGeometry: function() {
        var t2 = this.geomFact.createPolygon();
        return t2;
      }, getNoder: function(t2) {
        if (null !== this.workingNoder)
          return this.workingNoder;
        var e2 = new nn(), n2 = new ae();
        return n2.setPrecisionModel(t2), e2.setSegmentIntersector(new Zi(n2)), e2;
      }, buffer: function(t2, e2) {
        var n2 = this.workingPrecisionModel;
        null === n2 && (n2 = t2.getPrecisionModel()), this.geomFact = t2.getFactory();
        var i3 = new Hi(n2, this.bufParams), r2 = new Ki(t2, e2, i3), s2 = r2.getCurves();
        if (s2.size() <= 0)
          return this.createEmptyResultGeometry();
        this.computeNodedEdges(s2, n2), this.graph = new Cn(new On()), this.graph.addEdges(this.edgeList.getEdges());
        var o2 = this.createSubgraphs(this.graph), a2 = new Sn(this.geomFact);
        this.buildSubgraphs(o2, a2);
        var u2 = a2.getPolygons();
        if (u2.size() <= 0)
          return this.createEmptyResultGeometry();
        var l2 = this.geomFact.buildGeometry(u2);
        return l2;
      }, computeNodedEdges: function(t2, e2) {
        var n2 = this.getNoder(e2);
        n2.computeNodes(t2);
        for (var i3 = n2.getNodedSubstrings(), r2 = i3.iterator(); r2.hasNext(); ) {
          var s2 = r2.next(), o2 = s2.getCoordinates();
          if (2 !== o2.length || !o2[0].equals2D(o2[1])) {
            var a2 = s2.getData(), u2 = new Jn(s2.getCoordinates(), new gn(a2));
            this.insertUniqueEdge(u2);
          }
        }
      }, setNoder: function(t2) {
        this.workingNoder = t2;
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return Qi;
      } }), Qi.depthDelta = function(t2) {
        var e2 = t2.getLocation(0, cn.LEFT), n2 = t2.getLocation(0, cn.RIGHT);
        return e2 === L.INTERIOR && n2 === L.EXTERIOR ? 1 : e2 === L.EXTERIOR && n2 === L.INTERIOR ? -1 : 0;
      }, Qi.convertSegStrings = function(t2) {
        for (var e2 = new ie(), n2 = new I(); t2.hasNext(); ) {
          var i3 = t2.next(), r2 = e2.createLineString(i3.getCoordinates());
          n2.add(r2);
        }
        return e2.buildGeometry(n2);
      }, e(Ji.prototype, { checkEndPtVertexIntersections: function() {
        if (0 === arguments.length)
          for (var t2 = this.segStrings.iterator(); t2.hasNext(); ) {
            var e2 = t2.next(), n2 = e2.getCoordinates();
            this.checkEndPtVertexIntersections(n2[0], this.segStrings), this.checkEndPtVertexIntersections(n2[n2.length - 1], this.segStrings);
          }
        else if (2 === arguments.length) {
          for (var i3 = arguments[0], r2 = arguments[1], t2 = r2.iterator(); t2.hasNext(); )
            for (var e2 = t2.next(), n2 = e2.getCoordinates(), s2 = 1; s2 < n2.length - 1; s2++)
              if (n2[s2].equals(i3))
                throw new l("found endpt/interior pt intersection at index " + s2 + " :pt " + i3);
        }
      }, checkInteriorIntersections: function() {
        if (0 === arguments.length)
          for (var t2 = this.segStrings.iterator(); t2.hasNext(); )
            for (var e2 = t2.next(), n2 = this.segStrings.iterator(); n2.hasNext(); ) {
              var i3 = n2.next();
              this.checkInteriorIntersections(e2, i3);
            }
        else if (2 === arguments.length)
          for (var r2 = arguments[0], s2 = arguments[1], o2 = r2.getCoordinates(), a2 = s2.getCoordinates(), u2 = 0; u2 < o2.length - 1; u2++)
            for (var h2 = 0; h2 < a2.length - 1; h2++)
              this.checkInteriorIntersections(r2, u2, s2, h2);
        else if (4 === arguments.length) {
          var c2 = arguments[0], f2 = arguments[1], g2 = arguments[2], d2 = arguments[3];
          if (c2 === g2 && f2 === d2)
            return null;
          var p2 = c2.getCoordinates()[f2], v2 = c2.getCoordinates()[f2 + 1], m2 = g2.getCoordinates()[d2], y2 = g2.getCoordinates()[d2 + 1];
          if (this.li.computeIntersection(p2, v2, m2, y2), this.li.hasIntersection() && (this.li.isProper() || this.hasInteriorIntersection(this.li, p2, v2) || this.hasInteriorIntersection(this.li, m2, y2)))
            throw new l("found non-noded intersection at " + p2 + "-" + v2 + " and " + m2 + "-" + y2);
        }
      }, checkValid: function() {
        this.checkEndPtVertexIntersections(), this.checkInteriorIntersections(), this.checkCollapses();
      }, checkCollapses: function() {
        if (0 === arguments.length)
          for (var t2 = this.segStrings.iterator(); t2.hasNext(); ) {
            var e2 = t2.next();
            this.checkCollapses(e2);
          }
        else if (1 === arguments.length)
          for (var n2 = arguments[0], i3 = n2.getCoordinates(), t2 = 0; t2 < i3.length - 2; t2++)
            this.checkCollapse(i3[t2], i3[t2 + 1], i3[t2 + 2]);
      }, hasInteriorIntersection: function(t2, e2, n2) {
        for (var i3 = 0; i3 < t2.getIntersectionNum(); i3++) {
          var r2 = t2.getIntersection(i3);
          if (!r2.equals(e2) && !r2.equals(n2))
            return true;
        }
        return false;
      }, checkCollapse: function(t2, e2, n2) {
        if (t2.equals(n2))
          throw new l("found non-noded collapse at " + Ji.fact.createLineString([t2, e2, n2]));
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return Ji;
      } }), Ji.fact = new ie(), e($i.prototype, { intersectsScaled: function(t2, e2) {
        var n2 = Math.min(t2.x, e2.x), i3 = Math.max(t2.x, e2.x), r2 = Math.min(t2.y, e2.y), s2 = Math.max(t2.y, e2.y), o2 = this.maxx < n2 || this.minx > i3 || this.maxy < r2 || this.miny > s2;
        if (o2)
          return false;
        var a2 = this.intersectsToleranceSquare(t2, e2);
        return f.isTrue(!(o2 && a2), "Found bad envelope test"), a2;
      }, initCorners: function(t2) {
        var e2 = 0.5;
        this.minx = t2.x - e2, this.maxx = t2.x + e2, this.miny = t2.y - e2, this.maxy = t2.y + e2, this.corner[0] = new g(this.maxx, this.maxy), this.corner[1] = new g(this.minx, this.maxy), this.corner[2] = new g(this.minx, this.miny), this.corner[3] = new g(this.maxx, this.miny);
      }, intersects: function(t2, e2) {
        return 1 === this.scaleFactor ? this.intersectsScaled(t2, e2) : (this.copyScaled(t2, this.p0Scaled), this.copyScaled(e2, this.p1Scaled), this.intersectsScaled(this.p0Scaled, this.p1Scaled));
      }, scale: function(t2) {
        return Math.round(t2 * this.scaleFactor);
      }, getCoordinate: function() {
        return this.originalPt;
      }, copyScaled: function(t2, e2) {
        e2.x = this.scale(t2.x), e2.y = this.scale(t2.y);
      }, getSafeEnvelope: function() {
        if (null === this.safeEnv) {
          var t2 = $i.SAFE_ENV_EXPANSION_FACTOR / this.scaleFactor;
          this.safeEnv = new C(this.originalPt.x - t2, this.originalPt.x + t2, this.originalPt.y - t2, this.originalPt.y + t2);
        }
        return this.safeEnv;
      }, intersectsPixelClosure: function(t2, e2) {
        return this.li.computeIntersection(t2, e2, this.corner[0], this.corner[1]), this.li.hasIntersection() ? true : (this.li.computeIntersection(t2, e2, this.corner[1], this.corner[2]), this.li.hasIntersection() ? true : (this.li.computeIntersection(t2, e2, this.corner[2], this.corner[3]), this.li.hasIntersection() ? true : (this.li.computeIntersection(t2, e2, this.corner[3], this.corner[0]), !!this.li.hasIntersection())));
      }, intersectsToleranceSquare: function(t2, e2) {
        var n2 = false, i3 = false;
        return this.li.computeIntersection(t2, e2, this.corner[0], this.corner[1]), this.li.isProper() ? true : (this.li.computeIntersection(t2, e2, this.corner[1], this.corner[2]), this.li.isProper() ? true : (this.li.hasIntersection() && (n2 = true), this.li.computeIntersection(t2, e2, this.corner[2], this.corner[3]), this.li.isProper() ? true : (this.li.hasIntersection() && (i3 = true), this.li.computeIntersection(t2, e2, this.corner[3], this.corner[0]), this.li.isProper() ? true : n2 && i3 ? true : t2.equals(this.pt) ? true : !!e2.equals(this.pt))));
      }, addSnappedNode: function(t2, e2) {
        var n2 = t2.getCoordinate(e2), i3 = t2.getCoordinate(e2 + 1);
        return this.intersects(n2, i3) ? (t2.addIntersection(this.getCoordinate(), e2), true) : false;
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return $i;
      } }), $i.SAFE_ENV_EXPANSION_FACTOR = 0.75, e(tr.prototype, { select: function() {
        if (1 === arguments.length) {
          arguments[0];
        } else if (2 === arguments.length) {
          var t2 = arguments[0], e2 = arguments[1];
          t2.getLineSegment(e2, this.selectedSegment), this.select(this.selectedSegment);
        }
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return tr;
      } }), e(er.prototype, { snap: function() {
        if (1 === arguments.length) {
          var t2 = arguments[0];
          return this.snap(t2, null, -1);
        }
        if (3 === arguments.length) {
          var e2 = arguments[0], n2 = arguments[1], i3 = arguments[2], r2 = e2.getSafeEnvelope(), s2 = new nr(e2, n2, i3);
          return this.index.query(r2, { interfaces_: function() {
            return [Ae];
          }, visitItem: function(t3) {
            var e3 = t3;
            e3.select(r2, s2);
          } }), s2.isNodeAdded();
        }
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return er;
      } }), h(nr, tr), e(nr.prototype, { isNodeAdded: function() {
        return this._isNodeAdded;
      }, select: function() {
        if (2 !== arguments.length)
          return tr.prototype.select.apply(this, arguments);
        var t2 = arguments[0], e2 = arguments[1], n2 = t2.getContext();
        return null !== this.parentEdge && n2 === this.parentEdge && e2 === this.hotPixelVertexIndex ? null : void (this._isNodeAdded = this.hotPixel.addSnappedNode(n2, e2));
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return nr;
      } }), er.HotPixelSnapAction = nr, e(ir.prototype, { processIntersections: function(t2, e2, n2, i3) {
        if (t2 === n2 && e2 === i3)
          return null;
        var r2 = t2.getCoordinates()[e2], s2 = t2.getCoordinates()[e2 + 1], o2 = n2.getCoordinates()[i3], a2 = n2.getCoordinates()[i3 + 1];
        if (this.li.computeIntersection(r2, s2, o2, a2), this.li.hasIntersection() && this.li.isInteriorIntersection()) {
          for (var u2 = 0; u2 < this.li.getIntersectionNum(); u2++)
            this.interiorIntersections.add(this.li.getIntersection(u2));
          t2.addIntersections(this.li, e2, 0), n2.addIntersections(this.li, i3, 1);
        }
      }, isDone: function() {
        return false;
      }, getInteriorIntersections: function() {
        return this.interiorIntersections;
      }, interfaces_: function() {
        return [on];
      }, getClass: function() {
        return ir;
      } }), e(rr.prototype, { checkCorrectness: function(t2) {
        var e2 = Ke.getNodedSubstrings(t2), n2 = new Ji(e2);
        try {
          n2.checkValid();
        } catch (t3) {
          if (!(t3 instanceof S))
            throw t3;
          t3.printStackTrace();
        } finally {
        }
      }, getNodedSubstrings: function() {
        return Ke.getNodedSubstrings(this.nodedSegStrings);
      }, snapRound: function(t2, e2) {
        var n2 = this.findInteriorIntersections(t2, e2);
        this.computeIntersectionSnaps(n2), this.computeVertexSnaps(t2);
      }, findInteriorIntersections: function(t2, e2) {
        var n2 = new ir(e2);
        return this.noder.setSegmentIntersector(n2), this.noder.computeNodes(t2), n2.getInteriorIntersections();
      }, computeVertexSnaps: function() {
        if (R(arguments[0], v))
          for (var t2 = arguments[0], e2 = t2.iterator(); e2.hasNext(); ) {
            var n2 = e2.next();
            this.computeVertexSnaps(n2);
          }
        else if (arguments[0] instanceof Ke)
          for (var i3 = arguments[0], r2 = i3.getCoordinates(), s2 = 0; s2 < r2.length; s2++) {
            var o2 = new $i(r2[s2], this.scaleFactor, this.li), a2 = this.pointSnapper.snap(o2, i3, s2);
            a2 && i3.addIntersection(r2[s2], s2);
          }
      }, computeNodes: function(t2) {
        this.nodedSegStrings = t2, this.noder = new nn(), this.pointSnapper = new er(this.noder.getIndex()), this.snapRound(t2, this.li);
      }, computeIntersectionSnaps: function(t2) {
        for (var e2 = t2.iterator(); e2.hasNext(); ) {
          var n2 = e2.next(), i3 = new $i(n2, this.scaleFactor, this.li);
          this.pointSnapper.snap(i3);
        }
      }, interfaces_: function() {
        return [tn];
      }, getClass: function() {
        return rr;
      } }), e(sr.prototype, { bufferFixedPrecision: function(t2) {
        var e2 = new Fi(new rr(new ee(1)), t2.getScale()), n2 = new Qi(this.bufParams);
        n2.setWorkingPrecisionModel(t2), n2.setNoder(e2), this.resultGeometry = n2.buffer(this.argGeom, this.distance);
      }, bufferReducedPrecision: function() {
        if (0 === arguments.length) {
          for (var t2 = sr.MAX_PRECISION_DIGITS; t2 >= 0; t2--) {
            try {
              this.bufferReducedPrecision(t2);
            } catch (t3) {
              if (!(t3 instanceof sn))
                throw t3;
              this.saveException = t3;
            } finally {
            }
            if (null !== this.resultGeometry)
              return null;
          }
          throw this.saveException;
        }
        if (1 === arguments.length) {
          var e2 = arguments[0], n2 = sr.precisionScaleFactor(this.argGeom, this.distance, e2), i3 = new ee(n2);
          this.bufferFixedPrecision(i3);
        }
      }, computeGeometry: function() {
        if (this.bufferOriginalPrecision(), null !== this.resultGeometry)
          return null;
        var t2 = this.argGeom.getFactory().getPrecisionModel();
        t2.getType() === ee.FIXED ? this.bufferFixedPrecision(t2) : this.bufferReducedPrecision();
      }, setQuadrantSegments: function(t2) {
        this.bufParams.setQuadrantSegments(t2);
      }, bufferOriginalPrecision: function() {
        try {
          var t2 = new Qi(this.bufParams);
          this.resultGeometry = t2.buffer(this.argGeom, this.distance);
        } catch (t3) {
          if (!(t3 instanceof l))
            throw t3;
          this.saveException = t3;
        } finally {
        }
      }, getResultGeometry: function(t2) {
        return this.distance = t2, this.computeGeometry(), this.resultGeometry;
      }, setEndCapStyle: function(t2) {
        this.bufParams.setEndCapStyle(t2);
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return sr;
      } }), sr.bufferOp = function() {
        if (2 === arguments.length) {
          var t2 = arguments[0], e2 = arguments[1], n2 = new sr(t2), i3 = n2.getResultGeometry(e2);
          return i3;
        }
        if (3 === arguments.length) {
          if (Number.isInteger(arguments[2]) && arguments[0] instanceof B && "number" == typeof arguments[1]) {
            var r2 = arguments[0], s2 = arguments[1], o2 = arguments[2], a2 = new sr(r2);
            a2.setQuadrantSegments(o2);
            var i3 = a2.getResultGeometry(s2);
            return i3;
          }
          if (arguments[2] instanceof Bi && arguments[0] instanceof B && "number" == typeof arguments[1]) {
            var u2 = arguments[0], l2 = arguments[1], h2 = arguments[2], a2 = new sr(u2, h2), i3 = a2.getResultGeometry(l2);
            return i3;
          }
        } else if (4 === arguments.length) {
          var c2 = arguments[0], f2 = arguments[1], g2 = arguments[2], d2 = arguments[3], a2 = new sr(c2);
          a2.setQuadrantSegments(g2), a2.setEndCapStyle(d2);
          var i3 = a2.getResultGeometry(f2);
          return i3;
        }
      }, sr.precisionScaleFactor = function(t2, e2, n2) {
        var i3 = t2.getEnvelopeInternal(), r2 = T.max(Math.abs(i3.getMaxX()), Math.abs(i3.getMaxY()), Math.abs(i3.getMinX()), Math.abs(i3.getMinY())), s2 = e2 > 0 ? e2 : 0, o2 = r2 + 2 * s2, a2 = Math.trunc(Math.log(o2) / Math.log(10) + 1), u2 = n2 - a2, l2 = Math.pow(10, u2);
        return l2;
      }, sr.CAP_ROUND = Bi.CAP_ROUND, sr.CAP_BUTT = Bi.CAP_FLAT, sr.CAP_FLAT = Bi.CAP_FLAT, sr.CAP_SQUARE = Bi.CAP_SQUARE, sr.MAX_PRECISION_DIGITS = 12;
      var Co = Object.freeze({ BufferOp: sr, BufferParameters: Bi });
      e(or.prototype, { filter: function(t2) {
        t2 instanceof Tt && this.comps.add(t2);
      }, interfaces_: function() {
        return [ht];
      }, getClass: function() {
        return or;
      } }), or.getPolygons = function() {
        if (1 === arguments.length) {
          var t2 = arguments[0];
          return or.getPolygons(t2, new I());
        }
        if (2 === arguments.length) {
          var e2 = arguments[0], n2 = arguments[1];
          return e2 instanceof Tt ? n2.add(e2) : e2 instanceof ft && e2.apply(new or(n2)), n2;
        }
      }, e(ar.prototype, { isInsideArea: function() {
        return this.segIndex === ar.INSIDE_AREA;
      }, getCoordinate: function() {
        return this.pt;
      }, getGeometryComponent: function() {
        return this.component;
      }, getSegmentIndex: function() {
        return this.segIndex;
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return ar;
      } }), ar.INSIDE_AREA = -1, e(ur.prototype, { filter: function(t2) {
        t2 instanceof Lt && this.pts.add(t2);
      }, interfaces_: function() {
        return [ht];
      }, getClass: function() {
        return ur;
      } }), ur.getPoints = function() {
        if (1 === arguments.length) {
          var t2 = arguments[0];
          return t2 instanceof Lt ? ho.singletonList(t2) : ur.getPoints(t2, new I());
        }
        if (2 === arguments.length) {
          var e2 = arguments[0], n2 = arguments[1];
          return e2 instanceof Lt ? n2.add(e2) : e2 instanceof ft && e2.apply(new ur(n2)), n2;
        }
      }, e(lr.prototype, { filter: function(t2) {
        (t2 instanceof Lt || t2 instanceof St || t2 instanceof Tt) && this.locations.add(new ar(t2, 0, t2.getCoordinate()));
      }, interfaces_: function() {
        return [ht];
      }, getClass: function() {
        return lr;
      } }), lr.getLocations = function(t2) {
        var e2 = new I();
        return t2.apply(new lr(e2)), e2;
      }, e(hr.prototype, { computeContainmentDistance: function() {
        if (0 === arguments.length) {
          var t2 = new Array(2).fill(null);
          if (this.computeContainmentDistance(0, t2), this.minDistance <= this.terminateDistance)
            return null;
          this.computeContainmentDistance(1, t2);
        } else if (2 === arguments.length) {
          var e2 = arguments[0], n2 = arguments[1], i3 = 1 - e2, r2 = or.getPolygons(this.geom[e2]);
          if (r2.size() > 0) {
            var s2 = lr.getLocations(this.geom[i3]);
            if (this.computeContainmentDistance(s2, r2, n2), this.minDistance <= this.terminateDistance)
              return this.minDistanceLocation[i3] = n2[0], this.minDistanceLocation[e2] = n2[1], null;
          }
        } else if (3 === arguments.length) {
          if (arguments[2] instanceof Array && R(arguments[0], y) && R(arguments[1], y)) {
            for (var o2 = arguments[0], a2 = arguments[1], u2 = arguments[2], l2 = 0; l2 < o2.size(); l2++)
              for (var h2 = o2.get(l2), c2 = 0; c2 < a2.size(); c2++)
                if (this.computeContainmentDistance(h2, a2.get(c2), u2), this.minDistance <= this.terminateDistance)
                  return null;
          } else if (arguments[2] instanceof Array && arguments[0] instanceof ar && arguments[1] instanceof Tt) {
            var f2 = arguments[0], g2 = arguments[1], d2 = arguments[2], p2 = f2.getCoordinate();
            if (L.EXTERIOR !== this.ptLocator.locate(p2, g2))
              return this.minDistance = 0, d2[0] = f2, d2[1] = new ar(g2, p2), null;
          }
        }
      }, computeMinDistanceLinesPoints: function(t2, e2, n2) {
        for (var i3 = 0; i3 < t2.size(); i3++)
          for (var r2 = t2.get(i3), s2 = 0; s2 < e2.size(); s2++) {
            var o2 = e2.get(s2);
            if (this.computeMinDistance(r2, o2, n2), this.minDistance <= this.terminateDistance)
              return null;
          }
      }, computeFacetDistance: function() {
        var t2 = new Array(2).fill(null), e2 = kn.getLines(this.geom[0]), n2 = kn.getLines(this.geom[1]), i3 = ur.getPoints(this.geom[0]), r2 = ur.getPoints(this.geom[1]);
        return this.computeMinDistanceLines(e2, n2, t2), this.updateMinDistance(t2, false), this.minDistance <= this.terminateDistance ? null : (t2[0] = null, t2[1] = null, this.computeMinDistanceLinesPoints(e2, r2, t2), this.updateMinDistance(t2, false), this.minDistance <= this.terminateDistance ? null : (t2[0] = null, t2[1] = null, this.computeMinDistanceLinesPoints(n2, i3, t2), this.updateMinDistance(t2, true), this.minDistance <= this.terminateDistance ? null : (t2[0] = null, t2[1] = null, this.computeMinDistancePoints(i3, r2, t2), void this.updateMinDistance(t2, false))));
      }, nearestLocations: function() {
        return this.computeMinDistance(), this.minDistanceLocation;
      }, updateMinDistance: function(t2, e2) {
        return null === t2[0] ? null : void (e2 ? (this.minDistanceLocation[0] = t2[1], this.minDistanceLocation[1] = t2[0]) : (this.minDistanceLocation[0] = t2[0], this.minDistanceLocation[1] = t2[1]));
      }, nearestPoints: function() {
        this.computeMinDistance();
        var t2 = [this.minDistanceLocation[0].getCoordinate(), this.minDistanceLocation[1].getCoordinate()];
        return t2;
      }, computeMinDistance: function() {
        if (0 === arguments.length) {
          if (null !== this.minDistanceLocation)
            return null;
          if (this.minDistanceLocation = new Array(2).fill(null), this.computeContainmentDistance(), this.minDistance <= this.terminateDistance)
            return null;
          this.computeFacetDistance();
        } else if (3 === arguments.length) {
          if (arguments[2] instanceof Array && arguments[0] instanceof St && arguments[1] instanceof Lt) {
            var t2 = arguments[0], e2 = arguments[1], n2 = arguments[2];
            if (t2.getEnvelopeInternal().distance(e2.getEnvelopeInternal()) > this.minDistance)
              return null;
            for (var i3 = t2.getCoordinates(), r2 = e2.getCoordinate(), s2 = 0; s2 < i3.length - 1; s2++) {
              var o2 = he.distancePointLine(r2, i3[s2], i3[s2 + 1]);
              if (o2 < this.minDistance) {
                this.minDistance = o2;
                var a2 = new ce(i3[s2], i3[s2 + 1]), u2 = a2.closestPoint(r2);
                n2[0] = new ar(t2, s2, u2), n2[1] = new ar(e2, 0, r2);
              }
              if (this.minDistance <= this.terminateDistance)
                return null;
            }
          } else if (arguments[2] instanceof Array && arguments[0] instanceof St && arguments[1] instanceof St) {
            var l2 = arguments[0], h2 = arguments[1], c2 = arguments[2];
            if (l2.getEnvelopeInternal().distance(h2.getEnvelopeInternal()) > this.minDistance)
              return null;
            for (var i3 = l2.getCoordinates(), f2 = h2.getCoordinates(), s2 = 0; s2 < i3.length - 1; s2++)
              for (var g2 = 0; g2 < f2.length - 1; g2++) {
                var o2 = he.distanceLineLine(i3[s2], i3[s2 + 1], f2[g2], f2[g2 + 1]);
                if (o2 < this.minDistance) {
                  this.minDistance = o2;
                  var d2 = new ce(i3[s2], i3[s2 + 1]), p2 = new ce(f2[g2], f2[g2 + 1]), v2 = d2.closestPoints(p2);
                  c2[0] = new ar(l2, s2, v2[0]), c2[1] = new ar(h2, g2, v2[1]);
                }
                if (this.minDistance <= this.terminateDistance)
                  return null;
              }
          }
        }
      }, computeMinDistancePoints: function(t2, e2, n2) {
        for (var i3 = 0; i3 < t2.size(); i3++)
          for (var r2 = t2.get(i3), s2 = 0; s2 < e2.size(); s2++) {
            var o2 = e2.get(s2), a2 = r2.getCoordinate().distance(o2.getCoordinate());
            if (a2 < this.minDistance && (this.minDistance = a2, n2[0] = new ar(r2, 0, r2.getCoordinate()), n2[1] = new ar(o2, 0, o2.getCoordinate())), this.minDistance <= this.terminateDistance)
              return null;
          }
      }, distance: function() {
        if (null === this.geom[0] || null === this.geom[1])
          throw new i2("null geometries are not supported");
        return this.geom[0].isEmpty() || this.geom[1].isEmpty() ? 0 : (this.computeMinDistance(), this.minDistance);
      }, computeMinDistanceLines: function(t2, e2, n2) {
        for (var i3 = 0; i3 < t2.size(); i3++)
          for (var r2 = t2.get(i3), s2 = 0; s2 < e2.size(); s2++) {
            var o2 = e2.get(s2);
            if (this.computeMinDistance(r2, o2, n2), this.minDistance <= this.terminateDistance)
              return null;
          }
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return hr;
      } }), hr.distance = function(t2, e2) {
        var n2 = new hr(t2, e2);
        return n2.distance();
      }, hr.isWithinDistance = function(t2, e2, n2) {
        var i3 = new hr(t2, e2, n2);
        return i3.distance() <= n2;
      }, hr.nearestPoints = function(t2, e2) {
        var n2 = new hr(t2, e2);
        return n2.nearestPoints();
      };
      var So = Object.freeze({ DistanceOp: hr });
      e(cr.prototype, { getCoordinates: function() {
        if (null === this.coordinates) {
          for (var t2 = 0, e2 = 0, n2 = new N(), i3 = this.directedEdges.iterator(); i3.hasNext(); ) {
            var r2 = i3.next();
            r2.getEdgeDirection() ? t2++ : e2++, n2.add(r2.getEdge().getLine().getCoordinates(), false, r2.getEdgeDirection());
          }
          this.coordinates = n2.toCoordinateArray(), e2 > t2 && H.reverse(this.coordinates);
        }
        return this.coordinates;
      }, toLineString: function() {
        return this.factory.createLineString(this.getCoordinates());
      }, add: function(t2) {
        this.directedEdges.add(t2);
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return cr;
      } }), e(fr.prototype, { setVisited: function(t2) {
        this._isVisited = t2;
      }, isMarked: function() {
        return this._isMarked;
      }, setData: function(t2) {
        this.data = t2;
      }, getData: function() {
        return this.data;
      }, setMarked: function(t2) {
        this._isMarked = t2;
      }, getContext: function() {
        return this.data;
      }, isVisited: function() {
        return this._isVisited;
      }, setContext: function(t2) {
        this.data = t2;
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return fr;
      } }), fr.getComponentWithVisitedState = function(t2, e2) {
        for (; t2.hasNext(); ) {
          var n2 = t2.next();
          if (n2.isVisited() === e2)
            return n2;
        }
        return null;
      }, fr.setVisited = function(t2, e2) {
        for (; t2.hasNext(); ) {
          var n2 = t2.next();
          n2.setVisited(e2);
        }
      }, fr.setMarked = function(t2, e2) {
        for (; t2.hasNext(); ) {
          var n2 = t2.next();
          n2.setMarked(e2);
        }
      }, h(gr, fr), e(gr.prototype, { isRemoved: function() {
        return null === this.parentEdge;
      }, compareDirection: function(t2) {
        return this.quadrant > t2.quadrant ? 1 : this.quadrant < t2.quadrant ? -1 : he.computeOrientation(t2.p0, t2.p1, this.p1);
      }, getCoordinate: function() {
        return this.from.getCoordinate();
      }, print: function(t2) {
        var e2 = this.getClass().getName(), n2 = e2.lastIndexOf("."), i3 = e2.substring(n2 + 1);
        t2.print("  " + i3 + ": " + this.p0 + " - " + this.p1 + " " + this.quadrant + ":" + this.angle);
      }, getDirectionPt: function() {
        return this.p1;
      }, getAngle: function() {
        return this.angle;
      }, compareTo: function(t2) {
        var e2 = t2;
        return this.compareDirection(e2);
      }, getFromNode: function() {
        return this.from;
      }, getSym: function() {
        return this.sym;
      }, setEdge: function(t2) {
        this.parentEdge = t2;
      }, remove: function() {
        this.sym = null, this.parentEdge = null;
      }, getEdge: function() {
        return this.parentEdge;
      }, getQuadrant: function() {
        return this.quadrant;
      }, setSym: function(t2) {
        this.sym = t2;
      }, getToNode: function() {
        return this.to;
      }, getEdgeDirection: function() {
        return this.edgeDirection;
      }, interfaces_: function() {
        return [s];
      }, getClass: function() {
        return gr;
      } }), gr.toEdges = function(t2) {
        for (var e2 = new I(), n2 = t2.iterator(); n2.hasNext(); )
          e2.add(n2.next().parentEdge);
        return e2;
      }, h(dr, gr), e(dr.prototype, { getNext: function() {
        return 2 !== this.getToNode().getDegree() ? null : this.getToNode().getOutEdges().getEdges().get(0) === this.getSym() ? this.getToNode().getOutEdges().getEdges().get(1) : (f.isTrue(this.getToNode().getOutEdges().getEdges().get(1) === this.getSym()), this.getToNode().getOutEdges().getEdges().get(0));
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return dr;
      } }), h(pr, fr), e(pr.prototype, { isRemoved: function() {
        return null === this.dirEdge;
      }, setDirectedEdges: function(t2, e2) {
        this.dirEdge = [t2, e2], t2.setEdge(this), e2.setEdge(this), t2.setSym(e2), e2.setSym(t2), t2.getFromNode().addOutEdge(t2), e2.getFromNode().addOutEdge(e2);
      }, getDirEdge: function() {
        if (Number.isInteger(arguments[0])) {
          var t2 = arguments[0];
          return this.dirEdge[t2];
        }
        if (arguments[0] instanceof mr) {
          var e2 = arguments[0];
          return this.dirEdge[0].getFromNode() === e2 ? this.dirEdge[0] : this.dirEdge[1].getFromNode() === e2 ? this.dirEdge[1] : null;
        }
      }, remove: function() {
        this.dirEdge = null;
      }, getOppositeNode: function(t2) {
        return this.dirEdge[0].getFromNode() === t2 ? this.dirEdge[0].getToNode() : this.dirEdge[1].getFromNode() === t2 ? this.dirEdge[1].getToNode() : null;
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return pr;
      } }), e(vr.prototype, { getNextEdge: function(t2) {
        var e2 = this.getIndex(t2);
        return this.outEdges.get(this.getIndex(e2 + 1));
      }, getCoordinate: function() {
        var t2 = this.iterator();
        if (!t2.hasNext())
          return null;
        var e2 = t2.next();
        return e2.getCoordinate();
      }, iterator: function() {
        return this.sortEdges(), this.outEdges.iterator();
      }, sortEdges: function() {
        this.sorted || (ho.sort(this.outEdges), this.sorted = true);
      }, remove: function(t2) {
        this.outEdges.remove(t2);
      }, getEdges: function() {
        return this.sortEdges(), this.outEdges;
      }, getNextCWEdge: function(t2) {
        var e2 = this.getIndex(t2);
        return this.outEdges.get(this.getIndex(e2 - 1));
      }, getIndex: function() {
        if (arguments[0] instanceof pr) {
          var t2 = arguments[0];
          this.sortEdges();
          for (var e2 = 0; e2 < this.outEdges.size(); e2++) {
            var n2 = this.outEdges.get(e2);
            if (n2.getEdge() === t2)
              return e2;
          }
          return -1;
        }
        if (arguments[0] instanceof gr) {
          var i3 = arguments[0];
          this.sortEdges();
          for (var e2 = 0; e2 < this.outEdges.size(); e2++) {
            var n2 = this.outEdges.get(e2);
            if (n2 === i3)
              return e2;
          }
          return -1;
        }
        if (Number.isInteger(arguments[0])) {
          var r2 = arguments[0], s2 = r2 % this.outEdges.size();
          return 0 > s2 && (s2 += this.outEdges.size()), s2;
        }
      }, add: function(t2) {
        this.outEdges.add(t2), this.sorted = false;
      }, getDegree: function() {
        return this.outEdges.size();
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return vr;
      } }), h(mr, fr), e(mr.prototype, { isRemoved: function() {
        return null === this.pt;
      }, addOutEdge: function(t2) {
        this.deStar.add(t2);
      }, getCoordinate: function() {
        return this.pt;
      }, getOutEdges: function() {
        return this.deStar;
      }, remove: function() {
        if (0 === arguments.length)
          this.pt = null;
        else if (1 === arguments.length) {
          var t2 = arguments[0];
          this.deStar.remove(t2);
        }
      }, getIndex: function(t2) {
        return this.deStar.getIndex(t2);
      }, getDegree: function() {
        return this.deStar.getDegree();
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return mr;
      } }), mr.getEdgesBetween = function(t2, e2) {
        var n2 = gr.toEdges(t2.getOutEdges().getEdges()), i3 = new J(n2), r2 = gr.toEdges(e2.getOutEdges().getEdges());
        return i3.retainAll(r2), i3;
      }, h(yr, pr), e(yr.prototype, { getLine: function() {
        return this.line;
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return yr;
      } }), e(xr.prototype, { find: function(t2) {
        return this.nodeMap.get(t2);
      }, iterator: function() {
        return this.nodeMap.values().iterator();
      }, remove: function(t2) {
        return this.nodeMap.remove(t2);
      }, values: function() {
        return this.nodeMap.values();
      }, add: function(t2) {
        return this.nodeMap.put(t2.getCoordinate(), t2), t2;
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return xr;
      } }), e(Er.prototype, { findNodesOfDegree: function(t2) {
        for (var e2 = new I(), n2 = this.nodeIterator(); n2.hasNext(); ) {
          var i3 = n2.next();
          i3.getDegree() === t2 && e2.add(i3);
        }
        return e2;
      }, dirEdgeIterator: function() {
        return this.dirEdges.iterator();
      }, edgeIterator: function() {
        return this.edges.iterator();
      }, remove: function() {
        if (arguments[0] instanceof pr) {
          var t2 = arguments[0];
          this.remove(t2.getDirEdge(0)), this.remove(t2.getDirEdge(1)), this.edges.remove(t2), t2.remove();
        } else if (arguments[0] instanceof gr) {
          var e2 = arguments[0], n2 = e2.getSym();
          null !== n2 && n2.setSym(null), e2.getFromNode().remove(e2), e2.remove(), this.dirEdges.remove(e2);
        } else if (arguments[0] instanceof mr) {
          for (var i3 = arguments[0], r2 = i3.getOutEdges().getEdges(), s2 = r2.iterator(); s2.hasNext(); ) {
            var o2 = s2.next(), n2 = o2.getSym();
            null !== n2 && this.remove(n2), this.dirEdges.remove(o2);
            var a2 = o2.getEdge();
            null !== a2 && this.edges.remove(a2);
          }
          this.nodeMap.remove(i3.getCoordinate()), i3.remove();
        }
      }, findNode: function(t2) {
        return this.nodeMap.find(t2);
      }, getEdges: function() {
        return this.edges;
      }, nodeIterator: function() {
        return this.nodeMap.iterator();
      }, contains: function() {
        if (arguments[0] instanceof pr) {
          var t2 = arguments[0];
          return this.edges.contains(t2);
        }
        if (arguments[0] instanceof gr) {
          var e2 = arguments[0];
          return this.dirEdges.contains(e2);
        }
      }, add: function() {
        if (arguments[0] instanceof mr) {
          var t2 = arguments[0];
          this.nodeMap.add(t2);
        } else if (arguments[0] instanceof pr) {
          var e2 = arguments[0];
          this.edges.add(e2), this.add(e2.getDirEdge(0)), this.add(e2.getDirEdge(1));
        } else if (arguments[0] instanceof gr) {
          var n2 = arguments[0];
          this.dirEdges.add(n2);
        }
      }, getNodes: function() {
        return this.nodeMap.values();
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return Er;
      } }), h(Ir, Er), e(Ir.prototype, { addEdge: function(t2) {
        if (t2.isEmpty())
          return null;
        var e2 = H.removeRepeatedPoints(t2.getCoordinates());
        if (e2.length <= 1)
          return null;
        var n2 = e2[0], i3 = e2[e2.length - 1], r2 = this.getNode(n2), s2 = this.getNode(i3), o2 = new dr(r2, s2, e2[1], true), a2 = new dr(s2, r2, e2[e2.length - 2], false), u2 = new yr(t2);
        u2.setDirectedEdges(o2, a2), this.add(u2);
      }, getNode: function(t2) {
        var e2 = this.findNode(t2);
        return null === e2 && (e2 = new mr(t2), this.add(e2)), e2;
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return Ir;
      } }), e(Nr.prototype, { buildEdgeStringsForUnprocessedNodes: function() {
        for (var t2 = this.graph.getNodes().iterator(); t2.hasNext(); ) {
          var e2 = t2.next();
          e2.isMarked() || (f.isTrue(2 === e2.getDegree()), this.buildEdgeStringsStartingAt(e2), e2.setMarked(true));
        }
      }, buildEdgeStringsForNonDegree2Nodes: function() {
        for (var t2 = this.graph.getNodes().iterator(); t2.hasNext(); ) {
          var e2 = t2.next();
          2 !== e2.getDegree() && (this.buildEdgeStringsStartingAt(e2), e2.setMarked(true));
        }
      }, buildEdgeStringsForObviousStartNodes: function() {
        this.buildEdgeStringsForNonDegree2Nodes();
      }, getMergedLineStrings: function() {
        return this.merge(), this.mergedLineStrings;
      }, buildEdgeStringsStartingAt: function(t2) {
        for (var e2 = t2.getOutEdges().iterator(); e2.hasNext(); ) {
          var n2 = e2.next();
          n2.getEdge().isMarked() || this.edgeStrings.add(this.buildEdgeStringStartingWith(n2));
        }
      }, merge: function() {
        if (null !== this.mergedLineStrings)
          return null;
        fr.setMarked(this.graph.nodeIterator(), false), fr.setMarked(this.graph.edgeIterator(), false), this.edgeStrings = new I(), this.buildEdgeStringsForObviousStartNodes(), this.buildEdgeStringsForIsolatedLoops(), this.mergedLineStrings = new I();
        for (var t2 = this.edgeStrings.iterator(); t2.hasNext(); ) {
          var e2 = t2.next();
          this.mergedLineStrings.add(e2.toLineString());
        }
      }, buildEdgeStringStartingWith: function(t2) {
        var e2 = new cr(this.factory), n2 = t2;
        do
          e2.add(n2), n2.getEdge().setMarked(true), n2 = n2.getNext();
        while (null !== n2 && n2 !== t2);
        return e2;
      }, add: function() {
        if (arguments[0] instanceof B) {
          var t2 = arguments[0];
          t2.apply({ interfaces_: function() {
            return [q];
          }, filter: function(t3) {
            t3 instanceof St && this.add(t3);
          } });
        } else if (R(arguments[0], v)) {
          var e2 = arguments[0];
          this.mergedLineStrings = null;
          for (var n2 = e2.iterator(); n2.hasNext(); ) {
            var i3 = n2.next();
            this.add(i3);
          }
        } else if (arguments[0] instanceof St) {
          var r2 = arguments[0];
          null === this.factory && (this.factory = r2.getFactory()), this.graph.addEdge(r2);
        }
      }, buildEdgeStringsForIsolatedLoops: function() {
        this.buildEdgeStringsForUnprocessedNodes();
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return Nr;
      } });
      var wo = Object.freeze({ LineMerger: Nr }), Lo = Object.freeze({ OverlayOp: ii });
      h(Cr, gr), e(Cr.prototype, { getNext: function() {
        return this.next;
      }, isInRing: function() {
        return null !== this.edgeRing;
      }, setRing: function(t2) {
        this.edgeRing = t2;
      }, setLabel: function(t2) {
        this.label = t2;
      }, getLabel: function() {
        return this.label;
      }, setNext: function(t2) {
        this.next = t2;
      }, getRing: function() {
        return this.edgeRing;
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return Cr;
      } }), h(Sr, pr), e(Sr.prototype, { getLine: function() {
        return this.line;
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return Sr;
      } }), e(wr.prototype, { isIncluded: function() {
        return this._isIncluded;
      }, getCoordinates: function() {
        if (null === this.ringPts) {
          for (var t2 = new N(), e2 = this.deList.iterator(); e2.hasNext(); ) {
            var n2 = e2.next(), i3 = n2.getEdge();
            wr.addEdge(i3.getLine().getCoordinates(), n2.getEdgeDirection(), t2);
          }
          this.ringPts = t2.toCoordinateArray();
        }
        return this.ringPts;
      }, isIncludedSet: function() {
        return this._isIncludedSet;
      }, isValid: function() {
        return this.getCoordinates(), this.ringPts.length <= 3 ? false : (this.getRing(), this.ring.isValid());
      }, build: function(t2) {
        var e2 = t2;
        do
          this.add(e2), e2.setRing(this), e2 = e2.getNext(), f.isTrue(null !== e2, "found null DE in ring"), f.isTrue(e2 === t2 || !e2.isInRing(), "found DE already in ring");
        while (e2 !== t2);
      }, isOuterHole: function() {
        return this._isHole ? !this.hasShell() : false;
      }, getPolygon: function() {
        var t2 = null;
        if (null !== this.holes) {
          t2 = new Array(this.holes.size()).fill(null);
          for (var e2 = 0; e2 < this.holes.size(); e2++)
            t2[e2] = this.holes.get(e2);
        }
        var n2 = this.factory.createPolygon(this.ring, t2);
        return n2;
      }, isHole: function() {
        return this._isHole;
      }, isProcessed: function() {
        return this._isProcessed;
      }, addHole: function() {
        if (arguments[0] instanceof bt) {
          var t2 = arguments[0];
          null === this.holes && (this.holes = new I()), this.holes.add(t2);
        } else if (arguments[0] instanceof wr) {
          var e2 = arguments[0];
          e2.setShell(this);
          var n2 = e2.getRing();
          null === this.holes && (this.holes = new I()), this.holes.add(n2);
        }
      }, setIncluded: function(t2) {
        this._isIncluded = t2, this._isIncludedSet = true;
      }, getOuterHole: function() {
        if (this.isHole())
          return null;
        for (var t2 = 0; t2 < this.deList.size(); t2++) {
          var e2 = this.deList.get(t2), n2 = e2.getSym().getRing();
          if (n2.isOuterHole())
            return n2;
        }
        return null;
      }, computeHole: function() {
        var t2 = this.getRing();
        this._isHole = he.isCCW(t2.getCoordinates());
      }, hasShell: function() {
        return null !== this.shell;
      }, isOuterShell: function() {
        return null !== this.getOuterHole();
      }, getLineString: function() {
        return this.getCoordinates(), this.factory.createLineString(this.ringPts);
      }, toString: function() {
        return se.toLineString(new Gt(this.getCoordinates()));
      }, getShell: function() {
        return this.isHole() ? this.shell : this;
      }, add: function(t2) {
        this.deList.add(t2);
      }, getRing: function() {
        if (null !== this.ring)
          return this.ring;
        this.getCoordinates(), this.ringPts.length < 3 && A.out.println(this.ringPts);
        try {
          this.ring = this.factory.createLinearRing(this.ringPts);
        } catch (t2) {
          if (!(t2 instanceof S))
            throw t2;
          A.out.println(this.ringPts);
        } finally {
        }
        return this.ring;
      }, updateIncluded: function() {
        if (this.isHole())
          return null;
        for (var t2 = 0; t2 < this.deList.size(); t2++) {
          var e2 = this.deList.get(t2), n2 = e2.getSym().getRing().getShell();
          if (null !== n2 && n2.isIncludedSet())
            return this.setIncluded(!n2.isIncluded()), null;
        }
      }, setShell: function(t2) {
        this.shell = t2;
      }, setProcessed: function(t2) {
        this._isProcessed = t2;
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return wr;
      } }), wr.findDirEdgesInRing = function(t2) {
        var e2 = t2, n2 = new I();
        do
          n2.add(e2), e2 = e2.getNext(), f.isTrue(null !== e2, "found null DE in ring"), f.isTrue(e2 === t2 || !e2.isInRing(), "found DE already in ring");
        while (e2 !== t2);
        return n2;
      }, wr.addEdge = function(t2, e2, n2) {
        if (e2)
          for (var i3 = 0; i3 < t2.length; i3++)
            n2.add(t2[i3], false);
        else
          for (var i3 = t2.length - 1; i3 >= 0; i3--)
            n2.add(t2[i3], false);
      }, wr.findEdgeRingContaining = function(t2, e2) {
        for (var n2 = t2.getRing(), i3 = n2.getEnvelopeInternal(), r2 = n2.getCoordinateN(0), s2 = null, o2 = null, a2 = e2.iterator(); a2.hasNext(); ) {
          var u2 = a2.next(), l2 = u2.getRing(), h2 = l2.getEnvelopeInternal();
          if (!h2.equals(i3) && h2.contains(i3)) {
            r2 = H.ptNotInList(n2.getCoordinates(), l2.getCoordinates());
            var c2 = false;
            he.isPointInRing(r2, l2.getCoordinates()) && (c2 = true), c2 && (null === s2 || o2.contains(h2)) && (s2 = u2, o2 = s2.getRing().getEnvelopeInternal());
          }
        }
        return s2;
      }, e(Lr.prototype, { compare: function(t2, e2) {
        var n2 = t2, i3 = e2;
        return n2.getRing().getEnvelope().compareTo(i3.getRing().getEnvelope());
      }, interfaces_: function() {
        return [a];
      }, getClass: function() {
        return Lr;
      } }), wr.EnvelopeComparator = Lr, h(Rr, Er), e(Rr.prototype, { findEdgeRing: function(t2) {
        var e2 = new wr(this.factory);
        return e2.build(t2), e2;
      }, computeDepthParity: function() {
        if (0 === arguments.length)
          for (; ; ) {
            var t2 = null;
            if (null === t2)
              return null;
            this.computeDepthParity(t2);
          }
        else if (1 === arguments.length) {
          arguments[0];
        }
      }, computeNextCWEdges: function() {
        for (var t2 = this.nodeIterator(); t2.hasNext(); ) {
          var e2 = t2.next();
          Rr.computeNextCWEdges(e2);
        }
      }, addEdge: function(t2) {
        if (t2.isEmpty())
          return null;
        var e2 = H.removeRepeatedPoints(t2.getCoordinates());
        if (e2.length < 2)
          return null;
        var n2 = e2[0], i3 = e2[e2.length - 1], r2 = this.getNode(n2), s2 = this.getNode(i3), o2 = new Cr(r2, s2, e2[1], true), a2 = new Cr(s2, r2, e2[e2.length - 2], false), u2 = new Sr(t2);
        u2.setDirectedEdges(o2, a2), this.add(u2);
      }, deleteCutEdges: function() {
        this.computeNextCWEdges(), Rr.findLabeledEdgeRings(this.dirEdges);
        for (var t2 = new I(), e2 = this.dirEdges.iterator(); e2.hasNext(); ) {
          var n2 = e2.next();
          if (!n2.isMarked()) {
            var i3 = n2.getSym();
            if (n2.getLabel() === i3.getLabel()) {
              n2.setMarked(true), i3.setMarked(true);
              var r2 = n2.getEdge();
              t2.add(r2.getLine());
            }
          }
        }
        return t2;
      }, getEdgeRings: function() {
        this.computeNextCWEdges(), Rr.label(this.dirEdges, -1);
        var t2 = Rr.findLabeledEdgeRings(this.dirEdges);
        this.convertMaximalToMinimalEdgeRings(t2);
        for (var e2 = new I(), n2 = this.dirEdges.iterator(); n2.hasNext(); ) {
          var i3 = n2.next();
          if (!i3.isMarked() && !i3.isInRing()) {
            var r2 = this.findEdgeRing(i3);
            e2.add(r2);
          }
        }
        return e2;
      }, getNode: function(t2) {
        var e2 = this.findNode(t2);
        return null === e2 && (e2 = new mr(t2), this.add(e2)), e2;
      }, convertMaximalToMinimalEdgeRings: function(t2) {
        for (var e2 = t2.iterator(); e2.hasNext(); ) {
          var n2 = e2.next(), i3 = n2.getLabel(), r2 = Rr.findIntersectionNodes(n2, i3);
          if (null !== r2)
            for (var s2 = r2.iterator(); s2.hasNext(); ) {
              var o2 = s2.next();
              Rr.computeNextCCWEdges(o2, i3);
            }
        }
      }, deleteDangles: function() {
        for (var t2 = this.findNodesOfDegree(1), e2 = new J(), n2 = new pe(), i3 = t2.iterator(); i3.hasNext(); )
          n2.push(i3.next());
        for (; !n2.isEmpty(); ) {
          var r2 = n2.pop();
          Rr.deleteAllEdges(r2);
          for (var s2 = r2.getOutEdges().getEdges(), i3 = s2.iterator(); i3.hasNext(); ) {
            var o2 = i3.next();
            o2.setMarked(true);
            var a2 = o2.getSym();
            null !== a2 && a2.setMarked(true);
            var u2 = o2.getEdge();
            e2.add(u2.getLine());
            var l2 = o2.getToNode();
            1 === Rr.getDegreeNonDeleted(l2) && n2.push(l2);
          }
        }
        return e2;
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return Rr;
      } }), Rr.findLabeledEdgeRings = function(t2) {
        for (var e2 = new I(), n2 = 1, i3 = t2.iterator(); i3.hasNext(); ) {
          var r2 = i3.next();
          if (!(r2.isMarked() || r2.getLabel() >= 0)) {
            e2.add(r2);
            var s2 = wr.findDirEdgesInRing(r2);
            Rr.label(s2, n2), n2++;
          }
        }
        return e2;
      }, Rr.getDegreeNonDeleted = function(t2) {
        for (var e2 = t2.getOutEdges().getEdges(), n2 = 0, i3 = e2.iterator(); i3.hasNext(); ) {
          var r2 = i3.next();
          r2.isMarked() || n2++;
        }
        return n2;
      }, Rr.deleteAllEdges = function(t2) {
        for (var e2 = t2.getOutEdges().getEdges(), n2 = e2.iterator(); n2.hasNext(); ) {
          var i3 = n2.next();
          i3.setMarked(true);
          var r2 = i3.getSym();
          null !== r2 && r2.setMarked(true);
        }
      }, Rr.label = function(t2, e2) {
        for (var n2 = t2.iterator(); n2.hasNext(); ) {
          var i3 = n2.next();
          i3.setLabel(e2);
        }
      }, Rr.computeNextCWEdges = function(t2) {
        for (var e2 = t2.getOutEdges(), n2 = null, i3 = null, r2 = e2.getEdges().iterator(); r2.hasNext(); ) {
          var s2 = r2.next();
          if (!s2.isMarked()) {
            if (null === n2 && (n2 = s2), null !== i3) {
              var o2 = i3.getSym();
              o2.setNext(s2);
            }
            i3 = s2;
          }
        }
        if (null !== i3) {
          var o2 = i3.getSym();
          o2.setNext(n2);
        }
      }, Rr.computeNextCCWEdges = function(t2, e2) {
        for (var n2 = t2.getOutEdges(), i3 = null, r2 = null, s2 = n2.getEdges(), o2 = s2.size() - 1; o2 >= 0; o2--) {
          var a2 = s2.get(o2), u2 = a2.getSym(), l2 = null;
          a2.getLabel() === e2 && (l2 = a2);
          var h2 = null;
          u2.getLabel() === e2 && (h2 = u2), null === l2 && null === h2 || (null !== h2 && (r2 = h2), null !== l2 && (null !== r2 && (r2.setNext(l2), r2 = null), null === i3 && (i3 = l2)));
        }
        null !== r2 && (f.isTrue(null !== i3), r2.setNext(i3));
      }, Rr.getDegree = function(t2, e2) {
        for (var n2 = t2.getOutEdges().getEdges(), i3 = 0, r2 = n2.iterator(); r2.hasNext(); ) {
          var s2 = r2.next();
          s2.getLabel() === e2 && i3++;
        }
        return i3;
      }, Rr.findIntersectionNodes = function(t2, e2) {
        var n2 = t2, i3 = null;
        do {
          var r2 = n2.getFromNode();
          Rr.getDegree(r2, e2) > 1 && (null === i3 && (i3 = new I()), i3.add(r2)), n2 = n2.getNext(), f.isTrue(null !== n2, "found null DE in ring"), f.isTrue(n2 === t2 || !n2.isInRing(), "found DE already in ring");
        } while (n2 !== t2);
        return i3;
      }, e(Tr.prototype, { getGeometry: function() {
        return null === this.geomFactory && (this.geomFactory = new ie()), this.polygonize(), this.extractOnlyPolygonal ? this.geomFactory.buildGeometry(this.polyList) : this.geomFactory.createGeometryCollection(ie.toGeometryArray(this.polyList));
      }, getInvalidRingLines: function() {
        return this.polygonize(), this.invalidRingLines;
      }, findValidRings: function(t2, e2, n2) {
        for (var i3 = t2.iterator(); i3.hasNext(); ) {
          var r2 = i3.next();
          r2.isValid() ? e2.add(r2) : n2.add(r2.getLineString());
        }
      }, polygonize: function() {
        if (null !== this.polyList)
          return null;
        if (this.polyList = new I(), null === this.graph)
          return null;
        this.dangles = this.graph.deleteDangles(), this.cutEdges = this.graph.deleteCutEdges();
        var t2 = this.graph.getEdgeRings(), e2 = new I();
        this.invalidRingLines = new I(), this.isCheckingRingsValid ? this.findValidRings(t2, e2, this.invalidRingLines) : e2 = t2, this.findShellsAndHoles(e2), Tr.assignHolesToShells(this.holeList, this.shellList), ho.sort(this.shellList, new wr.EnvelopeComparator());
        var n2 = true;
        this.extractOnlyPolygonal && (Tr.findDisjointShells(this.shellList), n2 = false), this.polyList = Tr.extractPolygons(this.shellList, n2);
      }, getDangles: function() {
        return this.polygonize(), this.dangles;
      }, getCutEdges: function() {
        return this.polygonize(), this.cutEdges;
      }, getPolygons: function() {
        return this.polygonize(), this.polyList;
      }, add: function() {
        if (R(arguments[0], v))
          for (var t2 = arguments[0], e2 = t2.iterator(); e2.hasNext(); ) {
            var n2 = e2.next();
            this.add(n2);
          }
        else if (arguments[0] instanceof St) {
          var i3 = arguments[0];
          this.geomFactory = i3.getFactory(), null === this.graph && (this.graph = new Rr(this.geomFactory)), this.graph.addEdge(i3);
        } else if (arguments[0] instanceof B) {
          var r2 = arguments[0];
          r2.apply(this.lineStringAdder);
        }
      }, setCheckRingsValid: function(t2) {
        this.isCheckingRingsValid = t2;
      }, findShellsAndHoles: function(t2) {
        this.holeList = new I(), this.shellList = new I();
        for (var e2 = t2.iterator(); e2.hasNext(); ) {
          var n2 = e2.next();
          n2.computeHole(), n2.isHole() ? this.holeList.add(n2) : this.shellList.add(n2);
        }
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return Tr;
      } }), Tr.findOuterShells = function(t2) {
        for (var e2 = t2.iterator(); e2.hasNext(); ) {
          var n2 = e2.next(), i3 = n2.getOuterHole();
          null === i3 || i3.isProcessed() || (n2.setIncluded(true), i3.setProcessed(true));
        }
      }, Tr.extractPolygons = function(t2, e2) {
        for (var n2 = new I(), i3 = t2.iterator(); i3.hasNext(); ) {
          var r2 = i3.next();
          (e2 || r2.isIncluded()) && n2.add(r2.getPolygon());
        }
        return n2;
      }, Tr.assignHolesToShells = function(t2, e2) {
        for (var n2 = t2.iterator(); n2.hasNext(); ) {
          var i3 = n2.next();
          Tr.assignHoleToShell(i3, e2);
        }
      }, Tr.assignHoleToShell = function(t2, e2) {
        var n2 = wr.findEdgeRingContaining(t2, e2);
        null !== n2 && n2.addHole(t2);
      }, Tr.findDisjointShells = function(t2) {
        Tr.findOuterShells(t2);
        var e2 = null;
        do {
          e2 = false;
          for (var n2 = t2.iterator(); n2.hasNext(); ) {
            var i3 = n2.next();
            i3.isIncludedSet() || (i3.updateIncluded(), i3.isIncludedSet() || (e2 = true));
          }
        } while (e2);
      }, e(Pr.prototype, { filter: function(t2) {
        t2 instanceof St && this.p.add(t2);
      }, interfaces_: function() {
        return [q];
      }, getClass: function() {
        return Pr;
      } }), Tr.LineStringAdder = Pr;
      var Ro = Object.freeze({ Polygonizer: Tr });
      e(br.prototype, { createEdgeEndForNext: function(t2, e2, n2, i3) {
        var r2 = n2.segmentIndex + 1;
        if (r2 >= t2.getNumPoints() && null === i3)
          return null;
        var s2 = t2.getCoordinate(r2);
        null !== i3 && i3.segmentIndex === n2.segmentIndex && (s2 = i3.coord);
        var o2 = new En(t2, n2.coord, s2, new gn(t2.getLabel()));
        e2.add(o2);
      }, createEdgeEndForPrev: function(t2, e2, n2, i3) {
        var r2 = n2.segmentIndex;
        if (0 === n2.dist) {
          if (0 === r2)
            return null;
          r2--;
        }
        var s2 = t2.getCoordinate(r2);
        null !== i3 && i3.segmentIndex >= r2 && (s2 = i3.coord);
        var o2 = new gn(t2.getLabel());
        o2.flip();
        var a2 = new En(t2, n2.coord, s2, o2);
        e2.add(a2);
      }, computeEdgeEnds: function() {
        if (1 === arguments.length) {
          for (var t2 = arguments[0], e2 = new I(), n2 = t2; n2.hasNext(); ) {
            var i3 = n2.next();
            this.computeEdgeEnds(i3, e2);
          }
          return e2;
        }
        if (2 === arguments.length) {
          var r2 = arguments[0], s2 = arguments[1], o2 = r2.getEdgeIntersectionList();
          o2.addEndpoints();
          var a2 = o2.iterator(), u2 = null, l2 = null;
          if (!a2.hasNext())
            return null;
          var h2 = a2.next();
          do
            u2 = l2, l2 = h2, h2 = null, a2.hasNext() && (h2 = a2.next()), null !== l2 && (this.createEdgeEndForPrev(r2, s2, l2, u2), this.createEdgeEndForNext(r2, s2, l2, h2));
          while (null !== l2);
        }
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return br;
      } }), h(Or, En), e(Or.prototype, { insert: function(t2) {
        this.edgeEnds.add(t2);
      }, print: function(t2) {
        t2.println("EdgeEndBundle--> Label: " + this.label);
        for (var e2 = this.iterator(); e2.hasNext(); ) {
          var n2 = e2.next();
          n2.print(t2), t2.println();
        }
      }, iterator: function() {
        return this.edgeEnds.iterator();
      }, getEdgeEnds: function() {
        return this.edgeEnds;
      }, computeLabelOn: function(t2, e2) {
        for (var n2 = 0, i3 = false, r2 = this.iterator(); r2.hasNext(); ) {
          var s2 = r2.next(), o2 = s2.getLabel().getLocation(t2);
          o2 === L.BOUNDARY && n2++, o2 === L.INTERIOR && (i3 = true);
        }
        var o2 = L.NONE;
        i3 && (o2 = L.INTERIOR), n2 > 0 && (o2 = $n.determineBoundary(e2, n2)), this.label.setLocation(t2, o2);
      }, computeLabelSide: function(t2, e2) {
        for (var n2 = this.iterator(); n2.hasNext(); ) {
          var i3 = n2.next();
          if (i3.getLabel().isArea()) {
            var r2 = i3.getLabel().getLocation(t2, e2);
            if (r2 === L.INTERIOR)
              return this.label.setLocation(t2, e2, L.INTERIOR), null;
            r2 === L.EXTERIOR && this.label.setLocation(t2, e2, L.EXTERIOR);
          }
        }
      }, getLabel: function() {
        return this.label;
      }, computeLabelSides: function(t2) {
        this.computeLabelSide(t2, cn.LEFT), this.computeLabelSide(t2, cn.RIGHT);
      }, updateIM: function(t2) {
        Jn.updateIM(this.label, t2);
      }, computeLabel: function(t2) {
        for (var e2 = false, n2 = this.iterator(); n2.hasNext(); ) {
          var i3 = n2.next();
          i3.getLabel().isArea() && (e2 = true);
        }
        e2 ? this.label = new gn(L.NONE, L.NONE, L.NONE) : this.label = new gn(L.NONE);
        for (var r2 = 0; 2 > r2; r2++)
          this.computeLabelOn(r2, t2), e2 && this.computeLabelSides(r2);
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return Or;
      } }), h(_r, Pn), e(_r.prototype, { updateIM: function(t2) {
        for (var e2 = this.iterator(); e2.hasNext(); ) {
          var n2 = e2.next();
          n2.updateIM(t2);
        }
      }, insert: function(t2) {
        var e2 = this.edgeMap.get(t2);
        null === e2 ? (e2 = new Or(t2), this.insertEdgeEnd(t2, e2)) : e2.insert(t2);
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return _r;
      } }), h(Mr, yn), e(Mr.prototype, { updateIMFromEdges: function(t2) {
        this.edges.updateIM(t2);
      }, computeIM: function(t2) {
        t2.setAtLeastIfValid(this.label.getLocation(0), this.label.getLocation(1), 0);
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return Mr;
      } }), h(Dr, Nn), e(Dr.prototype, { createNode: function(t2) {
        return new Mr(t2, new _r());
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return Dr;
      } }), e(Ar.prototype, { insertEdgeEnds: function(t2) {
        for (var e2 = t2.iterator(); e2.hasNext(); ) {
          var n2 = e2.next();
          this.nodes.add(n2);
        }
      }, computeProperIntersectionIM: function(t2, e2) {
        var n2 = this.arg[0].getGeometry().getDimension(), i3 = this.arg[1].getGeometry().getDimension(), r2 = t2.hasProperIntersection(), s2 = t2.hasProperInteriorIntersection();
        2 === n2 && 2 === i3 ? r2 && e2.setAtLeast("212101212") : 2 === n2 && 1 === i3 ? (r2 && e2.setAtLeast("FFF0FFFF2"), s2 && e2.setAtLeast("1FFFFF1FF")) : 1 === n2 && 2 === i3 ? (r2 && e2.setAtLeast("F0FFFFFF2"), s2 && e2.setAtLeast("1F1FFFFFF")) : 1 === n2 && 1 === i3 && s2 && e2.setAtLeast("0FFFFFFFF");
      }, labelIsolatedEdges: function(t2, e2) {
        for (var n2 = this.arg[t2].getEdgeIterator(); n2.hasNext(); ) {
          var i3 = n2.next();
          i3.isIsolated() && (this.labelIsolatedEdge(i3, e2, this.arg[e2].getGeometry()), this.isolatedEdges.add(i3));
        }
      }, labelIsolatedEdge: function(t2, e2, n2) {
        if (n2.getDimension() > 0) {
          var i3 = this.ptLocator.locate(t2.getCoordinate(), n2);
          t2.getLabel().setAllLocations(e2, i3);
        } else
          t2.getLabel().setAllLocations(e2, L.EXTERIOR);
      }, computeIM: function() {
        var t2 = new fe();
        if (t2.set(L.EXTERIOR, L.EXTERIOR, 2), !this.arg[0].getGeometry().getEnvelopeInternal().intersects(this.arg[1].getGeometry().getEnvelopeInternal()))
          return this.computeDisjointIM(t2), t2;
        this.arg[0].computeSelfNodes(this.li, false), this.arg[1].computeSelfNodes(this.li, false);
        var e2 = this.arg[0].computeEdgeIntersections(this.arg[1], this.li, false);
        this.computeIntersectionNodes(0), this.computeIntersectionNodes(1), this.copyNodesAndLabels(0), this.copyNodesAndLabels(1), this.labelIsolatedNodes(), this.computeProperIntersectionIM(e2, t2);
        var n2 = new br(), i3 = n2.computeEdgeEnds(this.arg[0].getEdgeIterator());
        this.insertEdgeEnds(i3);
        var r2 = n2.computeEdgeEnds(this.arg[1].getEdgeIterator());
        return this.insertEdgeEnds(r2), this.labelNodeEdges(), this.labelIsolatedEdges(0, 1), this.labelIsolatedEdges(1, 0), this.updateIM(t2), t2;
      }, labelNodeEdges: function() {
        for (var t2 = this.nodes.iterator(); t2.hasNext(); ) {
          var e2 = t2.next();
          e2.getEdges().computeLabelling(this.arg);
        }
      }, copyNodesAndLabels: function(t2) {
        for (var e2 = this.arg[t2].getNodeIterator(); e2.hasNext(); ) {
          var n2 = e2.next(), i3 = this.nodes.addNode(n2.getCoordinate());
          i3.setLabel(t2, n2.getLabel().getLocation(t2));
        }
      }, labelIntersectionNodes: function(t2) {
        for (var e2 = this.arg[t2].getEdgeIterator(); e2.hasNext(); )
          for (var n2 = e2.next(), i3 = n2.getLabel().getLocation(t2), r2 = n2.getEdgeIntersectionList().iterator(); r2.hasNext(); ) {
            var s2 = r2.next(), o2 = this.nodes.find(s2.coord);
            o2.getLabel().isNull(t2) && (i3 === L.BOUNDARY ? o2.setLabelBoundary(t2) : o2.setLabel(t2, L.INTERIOR));
          }
      }, labelIsolatedNode: function(t2, e2) {
        var n2 = this.ptLocator.locate(t2.getCoordinate(), this.arg[e2].getGeometry());
        t2.getLabel().setAllLocations(e2, n2);
      }, computeIntersectionNodes: function(t2) {
        for (var e2 = this.arg[t2].getEdgeIterator(); e2.hasNext(); )
          for (var n2 = e2.next(), i3 = n2.getLabel().getLocation(t2), r2 = n2.getEdgeIntersectionList().iterator(); r2.hasNext(); ) {
            var s2 = r2.next(), o2 = this.nodes.addNode(s2.coord);
            i3 === L.BOUNDARY ? o2.setLabelBoundary(t2) : o2.getLabel().isNull(t2) && o2.setLabel(t2, L.INTERIOR);
          }
      }, labelIsolatedNodes: function() {
        for (var t2 = this.nodes.iterator(); t2.hasNext(); ) {
          var e2 = t2.next(), n2 = e2.getLabel();
          f.isTrue(n2.getGeometryCount() > 0, "node with empty label found"), e2.isIsolated() && (n2.isNull(0) ? this.labelIsolatedNode(e2, 0) : this.labelIsolatedNode(e2, 1));
        }
      }, updateIM: function(t2) {
        for (var e2 = this.isolatedEdges.iterator(); e2.hasNext(); ) {
          var n2 = e2.next();
          n2.updateIM(t2);
        }
        for (var i3 = this.nodes.iterator(); i3.hasNext(); ) {
          var r2 = i3.next();
          r2.updateIM(t2), r2.updateIMFromEdges(t2);
        }
      }, computeDisjointIM: function(t2) {
        var e2 = this.arg[0].getGeometry();
        e2.isEmpty() || (t2.set(L.INTERIOR, L.EXTERIOR, e2.getDimension()), t2.set(L.BOUNDARY, L.EXTERIOR, e2.getBoundaryDimension()));
        var n2 = this.arg[1].getGeometry();
        n2.isEmpty() || (t2.set(L.EXTERIOR, L.INTERIOR, n2.getDimension()), t2.set(L.EXTERIOR, L.BOUNDARY, n2.getBoundaryDimension()));
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return Ar;
      } }), e(Fr.prototype, { isContainedInBoundary: function(t2) {
        if (t2 instanceof Tt)
          return false;
        if (t2 instanceof Lt)
          return this.isPointContainedInBoundary(t2);
        if (t2 instanceof St)
          return this.isLineStringContainedInBoundary(t2);
        for (var e2 = 0; e2 < t2.getNumGeometries(); e2++) {
          var n2 = t2.getGeometryN(e2);
          if (!this.isContainedInBoundary(n2))
            return false;
        }
        return true;
      }, isLineSegmentContainedInBoundary: function(t2, e2) {
        if (t2.equals(e2))
          return this.isPointContainedInBoundary(t2);
        if (t2.x === e2.x) {
          if (t2.x === this.rectEnv.getMinX() || t2.x === this.rectEnv.getMaxX())
            return true;
        } else if (t2.y === e2.y && (t2.y === this.rectEnv.getMinY() || t2.y === this.rectEnv.getMaxY()))
          return true;
        return false;
      }, isLineStringContainedInBoundary: function(t2) {
        for (var e2 = t2.getCoordinateSequence(), n2 = new g(), i3 = new g(), r2 = 0; r2 < e2.size() - 1; r2++)
          if (e2.getCoordinate(r2, n2), e2.getCoordinate(r2 + 1, i3), !this.isLineSegmentContainedInBoundary(n2, i3))
            return false;
        return true;
      }, isPointContainedInBoundary: function() {
        if (arguments[0] instanceof Lt) {
          var t2 = arguments[0];
          return this.isPointContainedInBoundary(t2.getCoordinate());
        }
        if (arguments[0] instanceof g) {
          var e2 = arguments[0];
          return e2.x === this.rectEnv.getMinX() || e2.x === this.rectEnv.getMaxX() || e2.y === this.rectEnv.getMinY() || e2.y === this.rectEnv.getMaxY();
        }
      }, contains: function(t2) {
        return this.rectEnv.contains(t2.getEnvelopeInternal()) ? !this.isContainedInBoundary(t2) : false;
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return Fr;
      } }), Fr.contains = function(t2, e2) {
        var n2 = new Fr(t2);
        return n2.contains(e2);
      }, e(Gr.prototype, { intersects: function(t2, e2) {
        var n2 = new C(t2, e2);
        if (!this.rectEnv.intersects(n2))
          return false;
        if (this.rectEnv.intersects(t2))
          return true;
        if (this.rectEnv.intersects(e2))
          return true;
        if (t2.compareTo(e2) > 0) {
          var i3 = t2;
          t2 = e2, e2 = i3;
        }
        var r2 = false;
        return e2.y > t2.y && (r2 = true), r2 ? this.li.computeIntersection(t2, e2, this.diagDown0, this.diagDown1) : this.li.computeIntersection(t2, e2, this.diagUp0, this.diagUp1), !!this.li.hasIntersection();
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return Gr;
      } }), e(qr.prototype, { applyTo: function(t2) {
        for (var e2 = 0; e2 < t2.getNumGeometries() && !this._isDone; e2++) {
          var n2 = t2.getGeometryN(e2);
          if (n2 instanceof ft)
            this.applyTo(n2);
          else if (this.visit(n2), this.isDone())
            return this._isDone = true, null;
        }
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return qr;
      } }), e(Br.prototype, { intersects: function(t2) {
        if (!this.rectEnv.intersects(t2.getEnvelopeInternal()))
          return false;
        var e2 = new zr(this.rectEnv);
        if (e2.applyTo(t2), e2.intersects())
          return true;
        var n2 = new Vr(this.rectangle);
        if (n2.applyTo(t2), n2.containsPoint())
          return true;
        var i3 = new kr(this.rectangle);
        return i3.applyTo(t2), !!i3.intersects();
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return Br;
      } }), Br.intersects = function(t2, e2) {
        var n2 = new Br(t2);
        return n2.intersects(e2);
      }, h(zr, qr), e(zr.prototype, { isDone: function() {
        return this._intersects === true;
      }, visit: function(t2) {
        var e2 = t2.getEnvelopeInternal();
        return this.rectEnv.intersects(e2) ? this.rectEnv.contains(e2) ? (this._intersects = true, null) : e2.getMinX() >= this.rectEnv.getMinX() && e2.getMaxX() <= this.rectEnv.getMaxX() ? (this._intersects = true, null) : e2.getMinY() >= this.rectEnv.getMinY() && e2.getMaxY() <= this.rectEnv.getMaxY() ? (this._intersects = true, null) : void 0 : null;
      }, intersects: function() {
        return this._intersects;
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return zr;
      } }), h(Vr, qr), e(Vr.prototype, { isDone: function() {
        return this._containsPoint === true;
      }, visit: function(t2) {
        if (!(t2 instanceof Tt))
          return null;
        var e2 = t2.getEnvelopeInternal();
        if (!this.rectEnv.intersects(e2))
          return null;
        for (var n2 = new g(), i3 = 0; 4 > i3; i3++)
          if (this.rectSeq.getCoordinate(i3, n2), e2.contains(n2) && Tn.containsPointInPolygon(n2, t2))
            return this._containsPoint = true, null;
      }, containsPoint: function() {
        return this._containsPoint;
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return Vr;
      } }), h(kr, qr), e(kr.prototype, { intersects: function() {
        return this.hasIntersection;
      }, isDone: function() {
        return this.hasIntersection === true;
      }, visit: function(t2) {
        var e2 = t2.getEnvelopeInternal();
        if (!this.rectEnv.intersects(e2))
          return null;
        var n2 = kn.getLines(t2);
        this.checkIntersectionWithLineStrings(n2);
      }, checkIntersectionWithLineStrings: function(t2) {
        for (var e2 = t2.iterator(); e2.hasNext(); ) {
          var n2 = e2.next();
          if (this.checkIntersectionWithSegments(n2), this.hasIntersection)
            return null;
        }
      }, checkIntersectionWithSegments: function(t2) {
        for (var e2 = t2.getCoordinateSequence(), n2 = 1; n2 < e2.size(); n2++)
          if (e2.getCoordinate(n2 - 1, this.p0), e2.getCoordinate(n2, this.p1), this.rectIntersector.intersects(this.p0, this.p1))
            return this.hasIntersection = true, null;
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return kr;
      } }), h(Yr, ti), e(Yr.prototype, { getIntersectionMatrix: function() {
        return this._relate.computeIM();
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return Yr;
      } }), Yr.covers = function(t2, e2) {
        return t2.getEnvelopeInternal().covers(e2.getEnvelopeInternal()) ? t2.isRectangle() ? true : Yr.relate(t2, e2).isCovers() : false;
      }, Yr.intersects = function(t2, e2) {
        return t2.getEnvelopeInternal().intersects(e2.getEnvelopeInternal()) ? t2.isRectangle() ? Br.intersects(t2, e2) : e2.isRectangle() ? Br.intersects(e2, t2) : Yr.relate(t2, e2).isIntersects() : false;
      }, Yr.touches = function(t2, e2) {
        return t2.getEnvelopeInternal().intersects(e2.getEnvelopeInternal()) ? Yr.relate(t2, e2).isTouches(t2.getDimension(), e2.getDimension()) : false;
      }, Yr.within = function(t2, e2) {
        return e2.contains(t2);
      }, Yr.coveredBy = function(t2, e2) {
        return Yr.covers(e2, t2);
      }, Yr.relate = function() {
        if (2 === arguments.length) {
          var t2 = arguments[0], e2 = arguments[1], n2 = new Yr(t2, e2), i3 = n2.getIntersectionMatrix();
          return i3;
        }
        if (3 === arguments.length) {
          if ("string" == typeof arguments[2] && arguments[0] instanceof B && arguments[1] instanceof B) {
            var r2 = arguments[0], s2 = arguments[1], o2 = arguments[2];
            return Yr.relateWithCheck(r2, s2).matches(o2);
          }
          if (R(arguments[2], V) && arguments[0] instanceof B && arguments[1] instanceof B) {
            var a2 = arguments[0], u2 = arguments[1], l2 = arguments[2], n2 = new Yr(a2, u2, l2), i3 = n2.getIntersectionMatrix();
            return i3;
          }
        }
      }, Yr.overlaps = function(t2, e2) {
        return t2.getEnvelopeInternal().intersects(e2.getEnvelopeInternal()) ? Yr.relate(t2, e2).isOverlaps(t2.getDimension(), e2.getDimension()) : false;
      }, Yr.disjoint = function(t2, e2) {
        return !t2.intersects(e2);
      }, Yr.relateWithCheck = function(t2, e2) {
        return t2.checkNotGeometryCollection(t2), t2.checkNotGeometryCollection(e2), Yr.relate(t2, e2);
      }, Yr.crosses = function(t2, e2) {
        return t2.getEnvelopeInternal().intersects(e2.getEnvelopeInternal()) ? Yr.relate(t2, e2).isCrosses(t2.getDimension(), e2.getDimension()) : false;
      }, Yr.contains = function(t2, e2) {
        return t2.getEnvelopeInternal().contains(e2.getEnvelopeInternal()) ? t2.isRectangle() ? Fr.contains(t2, e2) : Yr.relate(t2, e2).isContains() : false;
      };
      var To = Object.freeze({ RelateOp: Yr });
      e(Ur.prototype, { extractElements: function(t2, e2) {
        if (null === t2)
          return null;
        for (var n2 = 0; n2 < t2.getNumGeometries(); n2++) {
          var i3 = t2.getGeometryN(n2);
          this.skipEmpty && i3.isEmpty() || e2.add(i3);
        }
      }, combine: function() {
        for (var t2 = new I(), e2 = this.inputGeoms.iterator(); e2.hasNext(); ) {
          var n2 = e2.next();
          this.extractElements(n2, t2);
        }
        return 0 === t2.size() ? null !== this.geomFactory ? this.geomFactory.createGeometryCollection(null) : null : this.geomFactory.buildGeometry(t2);
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return Ur;
      } }), Ur.combine = function() {
        if (1 === arguments.length) {
          var t2 = arguments[0], e2 = new Ur(t2);
          return e2.combine();
        }
        if (2 === arguments.length) {
          var n2 = arguments[0], i3 = arguments[1], e2 = new Ur(Ur.createList(n2, i3));
          return e2.combine();
        }
        if (3 === arguments.length) {
          var r2 = arguments[0], s2 = arguments[1], o2 = arguments[2], e2 = new Ur(Ur.createList(r2, s2, o2));
          return e2.combine();
        }
      }, Ur.extractFactory = function(t2) {
        return t2.isEmpty() ? null : t2.iterator().next().getFactory();
      }, Ur.createList = function() {
        if (2 === arguments.length) {
          var t2 = arguments[0], e2 = arguments[1], n2 = new I();
          return n2.add(t2), n2.add(e2), n2;
        }
        if (3 === arguments.length) {
          var i3 = arguments[0], r2 = arguments[1], s2 = arguments[2], n2 = new I();
          return n2.add(i3), n2.add(r2), n2.add(s2), n2;
        }
      }, e(Xr.prototype, { union: function() {
        for (var t2 = new Te(), e2 = new at(), n2 = 0; n2 < this.pointGeom.getNumGeometries(); n2++) {
          var i3 = this.pointGeom.getGeometryN(n2), r2 = i3.getCoordinate(), s2 = t2.locate(r2, this.otherGeom);
          s2 === L.EXTERIOR && e2.add(r2);
        }
        if (0 === e2.size())
          return this.otherGeom;
        var o2 = null, a2 = H.toCoordinateArray(e2);
        return o2 = 1 === a2.length ? this.geomFact.createPoint(a2[0]) : this.geomFact.createMultiPointFromCoords(a2), Ur.combine(o2, this.otherGeom);
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return Xr;
      } }), Xr.union = function(t2, e2) {
        var n2 = new Xr(t2, e2);
        return n2.union();
      }, e(Hr.prototype, { filter: function(t2) {
        -1 !== this.sortIndex && t2.getSortIndex() !== this.sortIndex || this.comps.add(t2);
      }, interfaces_: function() {
        return [ht];
      }, getClass: function() {
        return Hr;
      } }), Hr.extract = function() {
        if (2 === arguments.length) {
          var t2 = arguments[0], e2 = arguments[1];
          return Hr.extract(t2, e2, new I());
        }
        if (3 === arguments.length) {
          var n2 = arguments[0], i3 = arguments[1], r2 = arguments[2];
          return n2.getSortIndex() === i3 ? r2.add(n2) : n2 instanceof ft && n2.apply(new Hr(i3, r2)), r2;
        }
      }, e(Wr.prototype, { reduceToGeometries: function(t2) {
        for (var e2 = new I(), n2 = t2.iterator(); n2.hasNext(); ) {
          var i3 = n2.next(), r2 = null;
          R(i3, y) ? r2 = this.unionTree(i3) : i3 instanceof B && (r2 = i3), e2.add(r2);
        }
        return e2;
      }, extractByEnvelope: function(t2, e2, n2) {
        for (var i3 = new I(), r2 = 0; r2 < e2.getNumGeometries(); r2++) {
          var s2 = e2.getGeometryN(r2);
          s2.getEnvelopeInternal().intersects(t2) ? i3.add(s2) : n2.add(s2);
        }
        return this.geomFactory.buildGeometry(i3);
      }, unionOptimized: function(t2, e2) {
        var n2 = t2.getEnvelopeInternal(), i3 = e2.getEnvelopeInternal();
        if (!n2.intersects(i3)) {
          var r2 = Ur.combine(t2, e2);
          return r2;
        }
        if (t2.getNumGeometries() <= 1 && e2.getNumGeometries() <= 1)
          return this.unionActual(t2, e2);
        var s2 = n2.intersection(i3);
        return this.unionUsingEnvelopeIntersection(t2, e2, s2);
      }, union: function() {
        if (null === this.inputPolys)
          throw new IllegalStateException("union() method cannot be called twice");
        if (this.inputPolys.isEmpty())
          return null;
        this.geomFactory = this.inputPolys.iterator().next().getFactory();
        for (var t2 = new ke(Wr.STRTREE_NODE_CAPACITY), e2 = this.inputPolys.iterator(); e2.hasNext(); ) {
          var n2 = e2.next();
          t2.insert(n2.getEnvelopeInternal(), n2);
        }
        this.inputPolys = null;
        var i3 = t2.itemsTree(), r2 = this.unionTree(i3);
        return r2;
      }, binaryUnion: function() {
        if (1 === arguments.length) {
          var t2 = arguments[0];
          return this.binaryUnion(t2, 0, t2.size());
        }
        if (3 === arguments.length) {
          var e2 = arguments[0], n2 = arguments[1], i3 = arguments[2];
          if (1 >= i3 - n2) {
            var r2 = Wr.getGeometry(e2, n2);
            return this.unionSafe(r2, null);
          }
          if (i3 - n2 === 2)
            return this.unionSafe(Wr.getGeometry(e2, n2), Wr.getGeometry(e2, n2 + 1));
          var s2 = Math.trunc((i3 + n2) / 2), r2 = this.binaryUnion(e2, n2, s2), o2 = this.binaryUnion(e2, s2, i3);
          return this.unionSafe(r2, o2);
        }
      }, repeatedUnion: function(t2) {
        for (var e2 = null, n2 = t2.iterator(); n2.hasNext(); ) {
          var i3 = n2.next();
          e2 = null === e2 ? i3.copy() : e2.union(i3);
        }
        return e2;
      }, unionSafe: function(t2, e2) {
        return null === t2 && null === e2 ? null : null === t2 ? e2.copy() : null === e2 ? t2.copy() : this.unionOptimized(t2, e2);
      }, unionActual: function(t2, e2) {
        return Wr.restrictToPolygons(t2.union(e2));
      }, unionTree: function(t2) {
        var e2 = this.reduceToGeometries(t2), n2 = this.binaryUnion(e2);
        return n2;
      }, unionUsingEnvelopeIntersection: function(t2, e2, n2) {
        var i3 = new I(), r2 = this.extractByEnvelope(n2, t2, i3), s2 = this.extractByEnvelope(n2, e2, i3), o2 = this.unionActual(r2, s2);
        i3.add(o2);
        var a2 = Ur.combine(i3);
        return a2;
      }, bufferUnion: function() {
        if (1 === arguments.length) {
          var t2 = arguments[0], e2 = t2.get(0).getFactory(), n2 = e2.buildGeometry(t2), i3 = n2.buffer(0);
          return i3;
        }
        if (2 === arguments.length) {
          var r2 = arguments[0], s2 = arguments[1], e2 = r2.getFactory(), n2 = e2.createGeometryCollection([r2, s2]), i3 = n2.buffer(0);
          return i3;
        }
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return Wr;
      } }), Wr.restrictToPolygons = function(t2) {
        if (R(t2, Rt))
          return t2;
        var e2 = or.getPolygons(t2);
        return 1 === e2.size() ? e2.get(0) : t2.getFactory().createMultiPolygon(ie.toPolygonArray(e2));
      }, Wr.getGeometry = function(t2, e2) {
        return e2 >= t2.size() ? null : t2.get(e2);
      }, Wr.union = function(t2) {
        var e2 = new Wr(t2);
        return e2.union();
      }, Wr.STRTREE_NODE_CAPACITY = 4, e(jr.prototype, { unionNoOpt: function(t2) {
        var e2 = this.geomFact.createPoint();
        return si.overlayOp(t2, e2, ii.UNION);
      }, unionWithNull: function(t2, e2) {
        return null === t2 && null === e2 ? null : null === e2 ? t2 : null === t2 ? e2 : t2.union(e2);
      }, extract: function() {
        if (R(arguments[0], v))
          for (var t2 = arguments[0], e2 = t2.iterator(); e2.hasNext(); ) {
            var n2 = e2.next();
            this.extract(n2);
          }
        else if (arguments[0] instanceof B) {
          var i3 = arguments[0];
          null === this.geomFact && (this.geomFact = i3.getFactory()), Hr.extract(i3, B.SORTINDEX_POLYGON, this.polygons), Hr.extract(i3, B.SORTINDEX_LINESTRING, this.lines), Hr.extract(i3, B.SORTINDEX_POINT, this.points);
        }
      }, union: function t2() {
        if (null === this.geomFact)
          return null;
        var e2 = null;
        if (this.points.size() > 0) {
          var n2 = this.geomFact.buildGeometry(this.points);
          e2 = this.unionNoOpt(n2);
        }
        var i3 = null;
        if (this.lines.size() > 0) {
          var r2 = this.geomFact.buildGeometry(this.lines);
          i3 = this.unionNoOpt(r2);
        }
        var s2 = null;
        this.polygons.size() > 0 && (s2 = Wr.union(this.polygons));
        var o2 = this.unionWithNull(i3, s2), t3 = null;
        return t3 = null === e2 ? o2 : null === o2 ? e2 : Xr.union(e2, o2), null === t3 ? this.geomFact.createGeometryCollection() : t3;
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return jr;
      } }), jr.union = function() {
        if (1 === arguments.length) {
          if (R(arguments[0], v)) {
            var t2 = arguments[0], e2 = new jr(t2);
            return e2.union();
          }
          if (arguments[0] instanceof B) {
            var n2 = arguments[0], e2 = new jr(n2);
            return e2.union();
          }
        } else if (2 === arguments.length) {
          var i3 = arguments[0], r2 = arguments[1], e2 = new jr(i3, r2);
          return e2.union();
        }
      };
      var Po = Object.freeze({ UnaryUnionOp: jr });
      e(Kr.prototype, { visitInteriorRing: function(t2, e2) {
        var n2 = t2.getCoordinates(), i3 = n2[0], r2 = Kr.findDifferentPoint(n2, i3), s2 = e2.findEdgeInSameDirection(i3, r2), o2 = e2.findEdgeEnd(s2), a2 = null;
        o2.getLabel().getLocation(0, cn.RIGHT) === L.INTERIOR ? a2 = o2 : o2.getSym().getLabel().getLocation(0, cn.RIGHT) === L.INTERIOR && (a2 = o2.getSym()), f.isTrue(null !== a2, "unable to find dirEdge with Interior on RHS"), this.visitLinkedDirectedEdges(a2);
      }, visitShellInteriors: function(t2, e2) {
        if (t2 instanceof Tt) {
          var n2 = t2;
          this.visitInteriorRing(n2.getExteriorRing(), e2);
        }
        if (t2 instanceof Ot)
          for (var i3 = t2, r2 = 0; r2 < i3.getNumGeometries(); r2++) {
            var n2 = i3.getGeometryN(r2);
            this.visitInteriorRing(n2.getExteriorRing(), e2);
          }
      }, getCoordinate: function() {
        return this.disconnectedRingcoord;
      }, setInteriorEdgesInResult: function(t2) {
        for (var e2 = t2.getEdgeEnds().iterator(); e2.hasNext(); ) {
          var n2 = e2.next();
          n2.getLabel().getLocation(0, cn.RIGHT) === L.INTERIOR && n2.setInResult(true);
        }
      }, visitLinkedDirectedEdges: function(t2) {
        var e2 = t2, n2 = t2;
        do
          f.isTrue(null !== n2, "found null Directed Edge"), n2.setVisited(true), n2 = n2.getNext();
        while (n2 !== e2);
      }, buildEdgeRings: function(t2) {
        for (var e2 = new I(), n2 = t2.iterator(); n2.hasNext(); ) {
          var i3 = n2.next();
          if (i3.isInResult() && null === i3.getEdgeRing()) {
            var r2 = new vn(i3, this.geometryFactory);
            r2.linkDirectedEdgesForMinimalEdgeRings();
            var s2 = r2.buildMinimalRings();
            e2.addAll(s2);
          }
        }
        return e2;
      }, hasUnvisitedShellEdge: function(t2) {
        for (var e2 = 0; e2 < t2.size(); e2++) {
          var n2 = t2.get(e2);
          if (!n2.isHole()) {
            var i3 = n2.getEdges(), r2 = i3.get(0);
            if (r2.getLabel().getLocation(0, cn.RIGHT) === L.INTERIOR) {
              for (var s2 = 0; s2 < i3.size(); s2++)
                if (r2 = i3.get(s2), !r2.isVisited())
                  return this.disconnectedRingcoord = r2.getCoordinate(), true;
            }
          }
        }
        return false;
      }, isInteriorsConnected: function() {
        var t2 = new I();
        this.geomGraph.computeSplitEdges(t2);
        var e2 = new Cn(new On());
        e2.addEdges(t2), this.setInteriorEdgesInResult(e2), e2.linkResultDirectedEdges();
        var n2 = this.buildEdgeRings(e2.getEdgeEnds());
        return this.visitShellInteriors(this.geomGraph.getGeometry(), e2), !this.hasUnvisitedShellEdge(n2);
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return Kr;
      } }), Kr.findDifferentPoint = function(t2, e2) {
        for (var n2 = 0; n2 < t2.length; n2++)
          if (!t2[n2].equals(e2))
            return t2[n2];
        return null;
      }, e(Zr.prototype, { hasChildren: function() {
        for (var t2 = 0; 2 > t2; t2++)
          if (null !== this.subnode[t2])
            return true;
        return false;
      }, isPrunable: function() {
        return !(this.hasChildren() || this.hasItems());
      }, addAllItems: function(t2) {
        t2.addAll(this.items);
        for (var e2 = 0; 2 > e2; e2++)
          null !== this.subnode[e2] && this.subnode[e2].addAllItems(t2);
        return t2;
      }, size: function() {
        for (var t2 = 0, e2 = 0; 2 > e2; e2++)
          null !== this.subnode[e2] && (t2 += this.subnode[e2].size());
        return t2 + this.items.size();
      }, addAllItemsFromOverlapping: function(t2, e2) {
        return null === t2 || this.isSearchMatch(t2) ? (e2.addAll(this.items), null !== this.subnode[0] && this.subnode[0].addAllItemsFromOverlapping(t2, e2), void (null !== this.subnode[1] && this.subnode[1].addAllItemsFromOverlapping(t2, e2))) : null;
      }, hasItems: function() {
        return !this.items.isEmpty();
      }, remove: function(t2, e2) {
        if (!this.isSearchMatch(t2))
          return false;
        for (var n2 = false, i3 = 0; 2 > i3; i3++)
          if (null !== this.subnode[i3] && (n2 = this.subnode[i3].remove(t2, e2))) {
            this.subnode[i3].isPrunable() && (this.subnode[i3] = null);
            break;
          }
        return n2 ? n2 : n2 = this.items.remove(e2);
      }, getItems: function() {
        return this.items;
      }, depth: function() {
        for (var t2 = 0, e2 = 0; 2 > e2; e2++)
          if (null !== this.subnode[e2]) {
            var n2 = this.subnode[e2].depth();
            n2 > t2 && (t2 = n2);
          }
        return t2 + 1;
      }, nodeSize: function() {
        for (var t2 = 0, e2 = 0; 2 > e2; e2++)
          null !== this.subnode[e2] && (t2 += this.subnode[e2].nodeSize());
        return t2 + 1;
      }, add: function(t2) {
        this.items.add(t2);
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return Zr;
      } }), Zr.getSubnodeIndex = function(t2, e2) {
        var n2 = -1;
        return t2.min >= e2 && (n2 = 1), t2.max <= e2 && (n2 = 0), n2;
      }, e(Qr.prototype, { expandToInclude: function(t2) {
        t2.max > this.max && (this.max = t2.max), t2.min < this.min && (this.min = t2.min);
      }, getWidth: function() {
        return this.max - this.min;
      }, overlaps: function() {
        if (1 === arguments.length) {
          var t2 = arguments[0];
          return this.overlaps(t2.min, t2.max);
        }
        if (2 === arguments.length) {
          var e2 = arguments[0], n2 = arguments[1];
          return !(this.min > n2 || this.max < e2);
        }
      }, getMin: function() {
        return this.min;
      }, toString: function() {
        return "[" + this.min + ", " + this.max + "]";
      }, contains: function() {
        if (1 === arguments.length) {
          if (arguments[0] instanceof Qr) {
            var t2 = arguments[0];
            return this.contains(t2.min, t2.max);
          }
          if ("number" == typeof arguments[0]) {
            var e2 = arguments[0];
            return e2 >= this.min && e2 <= this.max;
          }
        } else if (2 === arguments.length) {
          var n2 = arguments[0], i3 = arguments[1];
          return n2 >= this.min && i3 <= this.max;
        }
      }, init: function(t2, e2) {
        this.min = t2, this.max = e2, t2 > e2 && (this.min = e2, this.max = t2);
      }, getMax: function() {
        return this.max;
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return Qr;
      } }), e(Jr.prototype, { getInterval: function() {
        return this.interval;
      }, getLevel: function() {
        return this.level;
      }, computeKey: function(t2) {
        for (this.level = Jr.computeLevel(t2), this.interval = new Qr(), this.computeInterval(this.level, t2); !this.interval.contains(t2); )
          this.level += 1, this.computeInterval(this.level, t2);
      }, computeInterval: function(t2, e2) {
        var n2 = Ci.powerOf2(t2);
        this.pt = Math.floor(e2.getMin() / n2) * n2, this.interval.init(this.pt, this.pt + n2);
      }, getPoint: function() {
        return this.pt;
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return Jr;
      } }), Jr.computeLevel = function(t2) {
        var e2 = t2.getWidth(), n2 = Ci.exponent(e2) + 1;
        return n2;
      }, h($r, Zr), e($r.prototype, { getInterval: function() {
        return this.interval;
      }, find: function(t2) {
        var e2 = Zr.getSubnodeIndex(t2, this.centre);
        if (-1 === e2)
          return this;
        if (null !== this.subnode[e2]) {
          var n2 = this.subnode[e2];
          return n2.find(t2);
        }
        return this;
      }, insert: function(t2) {
        f.isTrue(null === this.interval || this.interval.contains(t2.interval));
        var e2 = Zr.getSubnodeIndex(t2.interval, this.centre);
        if (t2.level === this.level - 1)
          this.subnode[e2] = t2;
        else {
          var n2 = this.createSubnode(e2);
          n2.insert(t2), this.subnode[e2] = n2;
        }
      }, isSearchMatch: function(t2) {
        return t2.overlaps(this.interval);
      }, getSubnode: function(t2) {
        return null === this.subnode[t2] && (this.subnode[t2] = this.createSubnode(t2)), this.subnode[t2];
      }, getNode: function(t2) {
        var e2 = Zr.getSubnodeIndex(t2, this.centre);
        if (-1 !== e2) {
          var n2 = this.getSubnode(e2);
          return n2.getNode(t2);
        }
        return this;
      }, createSubnode: function(t2) {
        var e2 = 0, n2 = 0;
        switch (t2) {
          case 0:
            e2 = this.interval.getMin(), n2 = this.centre;
            break;
          case 1:
            e2 = this.centre, n2 = this.interval.getMax();
        }
        var i3 = new Qr(e2, n2), r2 = new $r(i3, this.level - 1);
        return r2;
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return $r;
      } }), $r.createNode = function(t2) {
        var e2 = new Jr(t2), n2 = new $r(e2.getInterval(), e2.getLevel());
        return n2;
      }, $r.createExpanded = function(t2, e2) {
        var n2 = new Qr(e2);
        null !== t2 && n2.expandToInclude(t2.interval);
        var i3 = $r.createNode(n2);
        return null !== t2 && i3.insert(t2), i3;
      }, h(ts, Zr), e(ts.prototype, { insert: function(t2, e2) {
        var n2 = Zr.getSubnodeIndex(t2, ts.origin);
        if (-1 === n2)
          return this.add(e2), null;
        var i3 = this.subnode[n2];
        if (null === i3 || !i3.getInterval().contains(t2)) {
          var r2 = $r.createExpanded(i3, t2);
          this.subnode[n2] = r2;
        }
        this.insertContained(this.subnode[n2], t2, e2);
      }, isSearchMatch: function(t2) {
        return true;
      }, insertContained: function(t2, e2, n2) {
        f.isTrue(t2.getInterval().contains(e2));
        var i3 = Ri.isZeroWidth(e2.getMin(), e2.getMax()), r2 = null;
        r2 = i3 ? t2.find(e2) : t2.getNode(e2), r2.add(n2);
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return ts;
      } }), ts.origin = 0, e(es.prototype, { size: function() {
        return null !== this.root ? this.root.size() : 0;
      }, insert: function(t2, e2) {
        this.collectStats(t2);
        var n2 = es.ensureExtent(t2, this.minExtent);
        this.root.insert(n2, e2);
      }, query: function() {
        if (1 === arguments.length) {
          if ("number" == typeof arguments[0]) {
            var t2 = arguments[0];
            return this.query(new Qr(t2, t2));
          }
          if (arguments[0] instanceof Qr) {
            var e2 = arguments[0], n2 = new I();
            return this.query(e2, n2), n2;
          }
        } else if (2 === arguments.length) {
          var i3 = arguments[0], r2 = arguments[1];
          this.root.addAllItemsFromOverlapping(i3, r2);
        }
      }, iterator: function() {
        var t2 = new I();
        return this.root.addAllItems(t2), t2.iterator();
      }, remove: function(t2, e2) {
        var n2 = es.ensureExtent(t2, this.minExtent);
        return this.root.remove(n2, e2);
      }, collectStats: function(t2) {
        var e2 = t2.getWidth();
        e2 < this.minExtent && e2 > 0 && (this.minExtent = e2);
      }, depth: function() {
        return null !== this.root ? this.root.depth() : 0;
      }, nodeSize: function() {
        return null !== this.root ? this.root.nodeSize() : 0;
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return es;
      } }), es.ensureExtent = function(t2, e2) {
        var n2 = t2.getMin(), i3 = t2.getMax();
        return n2 !== i3 ? t2 : (n2 === i3 && (n2 -= e2 / 2, i3 = n2 + e2 / 2), new Qr(n2, i3));
      }, e(ns.prototype, { isInside: function(t2) {
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return ns;
      } }), e(is.prototype, { testLineSegment: function(t2, e2) {
        var n2 = null, i3 = null, r2 = null, s2 = null, o2 = null, a2 = e2.p0, u2 = e2.p1;
        i3 = a2.x - t2.x, r2 = a2.y - t2.y, s2 = u2.x - t2.x, o2 = u2.y - t2.y, (r2 > 0 && 0 >= o2 || o2 > 0 && 0 >= r2) && (n2 = ue.signOfDet2x2(i3, r2, s2, o2) / (o2 - r2), n2 > 0 && this.crossings++);
      }, buildIndex: function() {
        this.tree = new es();
        for (var t2 = H.removeRepeatedPoints(this.ring.getCoordinates()), e2 = $e.getChains(t2), n2 = 0; n2 < e2.size(); n2++) {
          var i3 = e2.get(n2), r2 = i3.getEnvelope();
          this.interval.min = r2.getMinY(), this.interval.max = r2.getMaxY(), this.tree.insert(this.interval, i3);
        }
      }, testMonotoneChain: function(t2, e2, n2) {
        n2.select(t2, e2);
      }, isInside: function(t2) {
        this.crossings = 0;
        var e2 = new C(r.NEGATIVE_INFINITY, r.POSITIVE_INFINITY, t2.y, t2.y);
        this.interval.min = t2.y, this.interval.max = t2.y;
        for (var n2 = this.tree.query(this.interval), i3 = new rs(this, t2), s2 = n2.iterator(); s2.hasNext(); ) {
          var o2 = s2.next();
          this.testMonotoneChain(e2, i3, o2);
        }
        return this.crossings % 2 === 1;
      }, interfaces_: function() {
        return [ns];
      }, getClass: function() {
        return is;
      } }), h(rs, tr), e(rs.prototype, { select: function() {
        if (1 !== arguments.length)
          return tr.prototype.select.apply(this, arguments);
        var t2 = arguments[0];
        this.mcp.testLineSegment(this.p, t2);
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return rs;
      } }), is.MCSelecter = rs, e(ss.prototype, { insertEdgeEnds: function(t2) {
        for (var e2 = t2.iterator(); e2.hasNext(); ) {
          var n2 = e2.next();
          this.nodes.add(n2);
        }
      }, getNodeIterator: function() {
        return this.nodes.iterator();
      }, copyNodesAndLabels: function(t2, e2) {
        for (var n2 = t2.getNodeIterator(); n2.hasNext(); ) {
          var i3 = n2.next(), r2 = this.nodes.addNode(i3.getCoordinate());
          r2.setLabel(e2, i3.getLabel().getLocation(e2));
        }
      }, build: function(t2) {
        this.computeIntersectionNodes(t2, 0), this.copyNodesAndLabels(t2, 0);
        var e2 = new br(), n2 = e2.computeEdgeEnds(t2.getEdgeIterator());
        this.insertEdgeEnds(n2);
      }, computeIntersectionNodes: function(t2, e2) {
        for (var n2 = t2.getEdgeIterator(); n2.hasNext(); )
          for (var i3 = n2.next(), r2 = i3.getLabel().getLocation(e2), s2 = i3.getEdgeIntersectionList().iterator(); s2.hasNext(); ) {
            var o2 = s2.next(), a2 = this.nodes.addNode(o2.coord);
            r2 === L.BOUNDARY ? a2.setLabelBoundary(e2) : a2.getLabel().isNull(e2) && a2.setLabel(e2, L.INTERIOR);
          }
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return ss;
      } }), e(os.prototype, { isNodeEdgeAreaLabelsConsistent: function() {
        for (var t2 = this.nodeGraph.getNodeIterator(); t2.hasNext(); ) {
          var e2 = t2.next();
          if (!e2.getEdges().isAreaLabelsConsistent(this.geomGraph))
            return this.invalidPoint = e2.getCoordinate().copy(), false;
        }
        return true;
      }, getInvalidPoint: function() {
        return this.invalidPoint;
      }, hasDuplicateRings: function() {
        for (var t2 = this.nodeGraph.getNodeIterator(); t2.hasNext(); )
          for (var e2 = t2.next(), n2 = e2.getEdges().iterator(); n2.hasNext(); ) {
            var i3 = n2.next();
            if (i3.getEdgeEnds().size() > 1)
              return this.invalidPoint = i3.getEdge().getCoordinate(0), true;
          }
        return false;
      }, isNodeConsistentArea: function() {
        var t2 = this.geomGraph.computeSelfNodes(this.li, true, true);
        return t2.hasProperIntersection() ? (this.invalidPoint = t2.getProperIntersectionPoint(), false) : (this.nodeGraph.build(this.geomGraph), this.isNodeEdgeAreaLabelsConsistent());
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return os;
      } }), e(as.prototype, { buildIndex: function() {
        this.index = new ke();
        for (var t2 = 0; t2 < this.rings.size(); t2++) {
          var e2 = this.rings.get(t2), n2 = e2.getEnvelopeInternal();
          this.index.insert(n2, e2);
        }
      }, getNestedPoint: function() {
        return this.nestedPt;
      }, isNonNested: function() {
        this.buildIndex();
        for (var t2 = 0; t2 < this.rings.size(); t2++)
          for (var e2 = this.rings.get(t2), n2 = e2.getCoordinates(), i3 = this.index.query(e2.getEnvelopeInternal()), r2 = 0; r2 < i3.size(); r2++) {
            var s2 = i3.get(r2), o2 = s2.getCoordinates();
            if (e2 !== s2 && e2.getEnvelopeInternal().intersects(s2.getEnvelopeInternal())) {
              var a2 = ls.findPtNotNode(n2, s2, this.graph);
              if (null !== a2) {
                var u2 = he.isPointInRing(a2, o2);
                if (u2)
                  return this.nestedPt = a2, false;
              }
            }
          }
        return true;
      }, add: function(t2) {
        this.rings.add(t2), this.totalEnv.expandToInclude(t2.getEnvelopeInternal());
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return as;
      } }), e(us.prototype, { getErrorType: function() {
        return this.errorType;
      }, getMessage: function() {
        return us.errMsg[this.errorType];
      }, getCoordinate: function() {
        return this.pt;
      }, toString: function() {
        var t2 = "";
        return null !== this.pt && (t2 = " at or near point " + this.pt), this.getMessage() + t2;
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return us;
      } }), us.ERROR = 0, us.REPEATED_POINT = 1, us.HOLE_OUTSIDE_SHELL = 2, us.NESTED_HOLES = 3, us.DISCONNECTED_INTERIOR = 4, us.SELF_INTERSECTION = 5, us.RING_SELF_INTERSECTION = 6, us.NESTED_SHELLS = 7, us.DUPLICATE_RINGS = 8, us.TOO_FEW_POINTS = 9, us.INVALID_COORDINATE = 10, us.RING_NOT_CLOSED = 11, us.errMsg = ["Topology Validation Error", "Repeated Point", "Hole lies outside shell", "Holes are nested", "Interior is disconnected", "Self-intersection", "Ring Self-intersection", "Nested shells", "Duplicate Rings", "Too few distinct points in geometry component", "Invalid Coordinate", "Ring is not closed"], e(ls.prototype, { checkInvalidCoordinates: function() {
        if (arguments[0] instanceof Array) {
          for (var t2 = arguments[0], e2 = 0; e2 < t2.length; e2++)
            if (!ls.isValid(t2[e2]))
              return this.validErr = new us(us.INVALID_COORDINATE, t2[e2]), null;
        } else if (arguments[0] instanceof Tt) {
          var n2 = arguments[0];
          if (this.checkInvalidCoordinates(n2.getExteriorRing().getCoordinates()), null !== this.validErr)
            return null;
          for (var e2 = 0; e2 < n2.getNumInteriorRing(); e2++)
            if (this.checkInvalidCoordinates(n2.getInteriorRingN(e2).getCoordinates()), null !== this.validErr)
              return null;
        }
      }, checkHolesNotNested: function(t2, e2) {
        for (var n2 = new as(e2), i3 = 0; i3 < t2.getNumInteriorRing(); i3++) {
          var r2 = t2.getInteriorRingN(i3);
          n2.add(r2);
        }
        var s2 = n2.isNonNested();
        s2 || (this.validErr = new us(us.NESTED_HOLES, n2.getNestedPoint()));
      }, checkConsistentArea: function(t2) {
        var e2 = new os(t2), n2 = e2.isNodeConsistentArea();
        return n2 ? void (e2.hasDuplicateRings() && (this.validErr = new us(us.DUPLICATE_RINGS, e2.getInvalidPoint()))) : (this.validErr = new us(us.SELF_INTERSECTION, e2.getInvalidPoint()), null);
      }, isValid: function() {
        return this.checkValid(this.parentGeometry), null === this.validErr;
      }, checkShellInsideHole: function(t2, e2, n2) {
        var i3 = t2.getCoordinates(), r2 = e2.getCoordinates(), s2 = ls.findPtNotNode(i3, e2, n2);
        if (null !== s2) {
          var o2 = he.isPointInRing(s2, r2);
          if (!o2)
            return s2;
        }
        var a2 = ls.findPtNotNode(r2, t2, n2);
        if (null !== a2) {
          var u2 = he.isPointInRing(a2, i3);
          return u2 ? a2 : null;
        }
        return f.shouldNeverReachHere("points in shell and hole appear to be equal"), null;
      }, checkNoSelfIntersectingRings: function(t2) {
        for (var e2 = t2.getEdgeIterator(); e2.hasNext(); ) {
          var n2 = e2.next();
          if (this.checkNoSelfIntersectingRing(n2.getEdgeIntersectionList()), null !== this.validErr)
            return null;
        }
      }, checkConnectedInteriors: function(t2) {
        var e2 = new Kr(t2);
        e2.isInteriorsConnected() || (this.validErr = new us(us.DISCONNECTED_INTERIOR, e2.getCoordinate()));
      }, checkNoSelfIntersectingRing: function(t2) {
        for (var e2 = new at(), n2 = true, i3 = t2.iterator(); i3.hasNext(); ) {
          var r2 = i3.next();
          if (n2)
            n2 = false;
          else {
            if (e2.contains(r2.coord))
              return this.validErr = new us(us.RING_SELF_INTERSECTION, r2.coord), null;
            e2.add(r2.coord);
          }
        }
      }, checkHolesInShell: function(t2, e2) {
        for (var n2 = t2.getExteriorRing(), i3 = new is(n2), r2 = 0; r2 < t2.getNumInteriorRing(); r2++) {
          var s2 = t2.getInteriorRingN(r2), o2 = ls.findPtNotNode(s2.getCoordinates(), n2, e2);
          if (null === o2)
            return null;
          var a2 = !i3.isInside(o2);
          if (a2)
            return this.validErr = new us(us.HOLE_OUTSIDE_SHELL, o2), null;
        }
      }, checkTooFewPoints: function(t2) {
        return t2.hasTooFewPoints() ? (this.validErr = new us(us.TOO_FEW_POINTS, t2.getInvalidPoint()), null) : void 0;
      }, getValidationError: function() {
        return this.checkValid(this.parentGeometry), this.validErr;
      }, checkValid: function() {
        if (arguments[0] instanceof Lt) {
          var t2 = arguments[0];
          this.checkInvalidCoordinates(t2.getCoordinates());
        } else if (arguments[0] instanceof Pt) {
          var e2 = arguments[0];
          this.checkInvalidCoordinates(e2.getCoordinates());
        } else if (arguments[0] instanceof bt) {
          var n2 = arguments[0];
          if (this.checkInvalidCoordinates(n2.getCoordinates()), null !== this.validErr)
            return null;
          if (this.checkClosedRing(n2), null !== this.validErr)
            return null;
          var i3 = new $n(0, n2);
          if (this.checkTooFewPoints(i3), null !== this.validErr)
            return null;
          var r2 = new ae();
          i3.computeSelfNodes(r2, true, true), this.checkNoSelfIntersectingRings(i3);
        } else if (arguments[0] instanceof St) {
          var s2 = arguments[0];
          if (this.checkInvalidCoordinates(s2.getCoordinates()), null !== this.validErr)
            return null;
          var i3 = new $n(0, s2);
          this.checkTooFewPoints(i3);
        } else if (arguments[0] instanceof Tt) {
          var o2 = arguments[0];
          if (this.checkInvalidCoordinates(o2), null !== this.validErr)
            return null;
          if (this.checkClosedRings(o2), null !== this.validErr)
            return null;
          var i3 = new $n(0, o2);
          if (this.checkTooFewPoints(i3), null !== this.validErr)
            return null;
          if (this.checkConsistentArea(i3), null !== this.validErr)
            return null;
          if (!this.isSelfTouchingRingFormingHoleValid && (this.checkNoSelfIntersectingRings(i3), null !== this.validErr))
            return null;
          if (this.checkHolesInShell(o2, i3), null !== this.validErr)
            return null;
          if (this.checkHolesNotNested(o2, i3), null !== this.validErr)
            return null;
          this.checkConnectedInteriors(i3);
        } else if (arguments[0] instanceof Ot) {
          for (var a2 = arguments[0], u2 = 0; u2 < a2.getNumGeometries(); u2++) {
            var l2 = a2.getGeometryN(u2);
            if (this.checkInvalidCoordinates(l2), null !== this.validErr)
              return null;
            if (this.checkClosedRings(l2), null !== this.validErr)
              return null;
          }
          var i3 = new $n(0, a2);
          if (this.checkTooFewPoints(i3), null !== this.validErr)
            return null;
          if (this.checkConsistentArea(i3), null !== this.validErr)
            return null;
          if (!this.isSelfTouchingRingFormingHoleValid && (this.checkNoSelfIntersectingRings(i3), null !== this.validErr))
            return null;
          for (var u2 = 0; u2 < a2.getNumGeometries(); u2++) {
            var l2 = a2.getGeometryN(u2);
            if (this.checkHolesInShell(l2, i3), null !== this.validErr)
              return null;
          }
          for (var u2 = 0; u2 < a2.getNumGeometries(); u2++) {
            var l2 = a2.getGeometryN(u2);
            if (this.checkHolesNotNested(l2, i3), null !== this.validErr)
              return null;
          }
          if (this.checkShellsNotNested(a2, i3), null !== this.validErr)
            return null;
          this.checkConnectedInteriors(i3);
        } else if (arguments[0] instanceof ft)
          for (var h2 = arguments[0], u2 = 0; u2 < h2.getNumGeometries(); u2++) {
            var c2 = h2.getGeometryN(u2);
            if (this.checkValid(c2), null !== this.validErr)
              return null;
          }
        else if (arguments[0] instanceof B) {
          var f2 = arguments[0];
          if (this.validErr = null, f2.isEmpty())
            return null;
          if (f2 instanceof Lt)
            this.checkValid(f2);
          else if (f2 instanceof Pt)
            this.checkValid(f2);
          else if (f2 instanceof bt)
            this.checkValid(f2);
          else if (f2 instanceof St)
            this.checkValid(f2);
          else if (f2 instanceof Tt)
            this.checkValid(f2);
          else if (f2 instanceof Ot)
            this.checkValid(f2);
          else {
            if (!(f2 instanceof ft))
              throw new UnsupportedOperationException(f2.getClass().getName());
            this.checkValid(f2);
          }
        }
      }, setSelfTouchingRingFormingHoleValid: function(t2) {
        this.isSelfTouchingRingFormingHoleValid = t2;
      }, checkShellNotNested: function(t2, e2, n2) {
        var i3 = t2.getCoordinates(), r2 = e2.getExteriorRing(), s2 = r2.getCoordinates(), o2 = ls.findPtNotNode(i3, r2, n2);
        if (null === o2)
          return null;
        var a2 = he.isPointInRing(o2, s2);
        if (!a2)
          return null;
        if (e2.getNumInteriorRing() <= 0)
          return this.validErr = new us(us.NESTED_SHELLS, o2), null;
        for (var u2 = null, l2 = 0; l2 < e2.getNumInteriorRing(); l2++) {
          var h2 = e2.getInteriorRingN(l2);
          if (u2 = this.checkShellInsideHole(t2, h2, n2), null === u2)
            return null;
        }
        this.validErr = new us(us.NESTED_SHELLS, u2);
      }, checkClosedRings: function(t2) {
        if (this.checkClosedRing(t2.getExteriorRing()), null !== this.validErr)
          return null;
        for (var e2 = 0; e2 < t2.getNumInteriorRing(); e2++)
          if (this.checkClosedRing(t2.getInteriorRingN(e2)), null !== this.validErr)
            return null;
      }, checkClosedRing: function(t2) {
        if (!t2.isClosed()) {
          var e2 = null;
          t2.getNumPoints() >= 1 && (e2 = t2.getCoordinateN(0)), this.validErr = new us(us.RING_NOT_CLOSED, e2);
        }
      }, checkShellsNotNested: function(t2, e2) {
        for (var n2 = 0; n2 < t2.getNumGeometries(); n2++)
          for (var i3 = t2.getGeometryN(n2), r2 = i3.getExteriorRing(), s2 = 0; s2 < t2.getNumGeometries(); s2++)
            if (n2 !== s2) {
              var o2 = t2.getGeometryN(s2);
              if (this.checkShellNotNested(r2, o2, e2), null !== this.validErr)
                return null;
            }
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return ls;
      } }), ls.findPtNotNode = function(t2, e2, n2) {
        for (var i3 = n2.findEdge(e2), r2 = i3.getEdgeIntersectionList(), s2 = 0; s2 < t2.length; s2++) {
          var o2 = t2[s2];
          if (!r2.isIntersection(o2))
            return o2;
        }
        return null;
      }, ls.isValid = function() {
        if (arguments[0] instanceof B) {
          var t2 = arguments[0], e2 = new ls(t2);
          return e2.isValid();
        }
        if (arguments[0] instanceof g) {
          var n2 = arguments[0];
          return r.isNaN(n2.x) ? false : r.isInfinite(n2.x) ? false : r.isNaN(n2.y) ? false : !r.isInfinite(n2.y);
        }
      };
      var bo = Object.freeze({ IsValidOp: ls }), Oo = Object.freeze({ BoundaryOp: dt, IsSimpleOp: Gi, buffer: Co, distance: So, linemerge: wo, overlay: Lo, polygonize: Ro, relate: To, union: Po, valid: bo });
      h(hs, _t.CoordinateOperation), e(hs.prototype, { editCoordinates: function(t2, e2) {
        if (0 === t2.length)
          return null;
        for (var n2 = new Array(t2.length).fill(null), i3 = 0; i3 < t2.length; i3++) {
          var r2 = new g(t2[i3]);
          this.targetPM.makePrecise(r2), n2[i3] = r2;
        }
        var s2 = new N(n2, false), o2 = s2.toCoordinateArray(), a2 = 0;
        e2 instanceof St && (a2 = 2), e2 instanceof bt && (a2 = 4);
        var u2 = n2;
        return this.removeCollapsed && (u2 = null), o2.length < a2 ? u2 : o2;
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return hs;
      } }), e(cs.prototype, { fixPolygonalTopology: function(t2) {
        var e2 = t2;
        this.changePrecisionModel || (e2 = this.changePM(t2, this.targetPM));
        var n2 = e2.buffer(0), i3 = n2;
        return this.changePrecisionModel || (i3 = t2.getFactory().createGeometry(n2)), i3;
      }, reducePointwise: function(t2) {
        var e2 = null;
        if (this.changePrecisionModel) {
          var n2 = this.createFactory(t2.getFactory(), this.targetPM);
          e2 = new _t(n2);
        } else
          e2 = new _t();
        var i3 = this.removeCollapsed;
        t2.getDimension() >= 2 && (i3 = true);
        var r2 = e2.edit(t2, new hs(this.targetPM, i3));
        return r2;
      }, changePM: function(t2, e2) {
        var n2 = this.createEditor(t2.getFactory(), e2);
        return n2.edit(t2, new _t.NoOpGeometryOperation());
      }, setRemoveCollapsedComponents: function(t2) {
        this.removeCollapsed = t2;
      }, createFactory: function(t2, e2) {
        var n2 = new ie(e2, t2.getSRID(), t2.getCoordinateSequenceFactory());
        return n2;
      }, setChangePrecisionModel: function(t2) {
        this.changePrecisionModel = t2;
      }, reduce: function(t2) {
        var e2 = this.reducePointwise(t2);
        return this.isPointwise ? e2 : R(e2, Rt) ? e2.isValid() ? e2 : this.fixPolygonalTopology(e2) : e2;
      }, setPointwise: function(t2) {
        this.isPointwise = t2;
      }, createEditor: function(t2, e2) {
        if (t2.getPrecisionModel() === e2)
          return new _t();
        var n2 = this.createFactory(t2, e2), i3 = new _t(n2);
        return i3;
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return cs;
      } }), cs.reduce = function(t2, e2) {
        var n2 = new cs(e2);
        return n2.reduce(t2);
      }, cs.reducePointwise = function(t2, e2) {
        var n2 = new cs(e2);
        return n2.setPointwise(true), n2.reduce(t2);
      };
      var _o = Object.freeze({ GeometryPrecisionReducer: cs });
      e(fs.prototype, { simplifySection: function(t2, e2) {
        if (t2 + 1 === e2)
          return null;
        this.seg.p0 = this.pts[t2], this.seg.p1 = this.pts[e2];
        for (var n2 = -1, i3 = t2, r2 = t2 + 1; e2 > r2; r2++) {
          var s2 = this.seg.distance(this.pts[r2]);
          s2 > n2 && (n2 = s2, i3 = r2);
        }
        if (n2 <= this.distanceTolerance)
          for (var r2 = t2 + 1; e2 > r2; r2++)
            this.usePt[r2] = false;
        else
          this.simplifySection(t2, i3), this.simplifySection(i3, e2);
      }, setDistanceTolerance: function(t2) {
        this.distanceTolerance = t2;
      }, simplify: function() {
        this.usePt = new Array(this.pts.length).fill(null);
        for (var t2 = 0; t2 < this.pts.length; t2++)
          this.usePt[t2] = true;
        this.simplifySection(0, this.pts.length - 1);
        for (var e2 = new N(), t2 = 0; t2 < this.pts.length; t2++)
          this.usePt[t2] && e2.add(new g(this.pts[t2]));
        return e2.toCoordinateArray();
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return fs;
      } }), fs.simplify = function(t2, e2) {
        var n2 = new fs(t2);
        return n2.setDistanceTolerance(e2), n2.simplify();
      }, e(gs.prototype, { setEnsureValid: function(t2) {
        this.isEnsureValidTopology = t2;
      }, getResultGeometry: function() {
        return this.inputGeom.isEmpty() ? this.inputGeom.copy() : new ds(this.isEnsureValidTopology, this.distanceTolerance).transform(this.inputGeom);
      }, setDistanceTolerance: function(t2) {
        if (0 > t2)
          throw new i2("Tolerance must be non-negative");
        this.distanceTolerance = t2;
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return gs;
      } }), gs.simplify = function(t2, e2) {
        var n2 = new gs(t2);
        return n2.setDistanceTolerance(e2), n2.getResultGeometry();
      }, h(ds, xe), e(ds.prototype, { transformPolygon: function(t2, e2) {
        if (t2.isEmpty())
          return null;
        var n2 = xe.prototype.transformPolygon.call(this, t2, e2);
        return e2 instanceof Ot ? n2 : this.createValidArea(n2);
      }, createValidArea: function(t2) {
        return this.isEnsureValidTopology ? t2.buffer(0) : t2;
      }, transformCoordinates: function(t2, e2) {
        var n2 = t2.toCoordinateArray(), i3 = null;
        return i3 = 0 === n2.length ? new Array(0).fill(null) : fs.simplify(n2, this.distanceTolerance), this.factory.getCoordinateSequenceFactory().create(i3);
      }, transformMultiPolygon: function(t2, e2) {
        var n2 = xe.prototype.transformMultiPolygon.call(this, t2, e2);
        return this.createValidArea(n2);
      }, transformLinearRing: function(t2, e2) {
        var n2 = e2 instanceof Tt, i3 = xe.prototype.transformLinearRing.call(this, t2, e2);
        return !n2 || i3 instanceof bt ? i3 : null;
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return ds;
      } }), gs.DPTransformer = ds, h(ps, ce), e(ps.prototype, { getIndex: function() {
        return this.index;
      }, getParent: function() {
        return this.parent;
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return ps;
      } }), e(vs.prototype, { addToResult: function(t2) {
        this.resultSegs.add(t2);
      }, asLineString: function() {
        return this.parentLine.getFactory().createLineString(vs.extractCoordinates(this.resultSegs));
      }, getResultSize: function() {
        var t2 = this.resultSegs.size();
        return 0 === t2 ? 0 : t2 + 1;
      }, getParent: function() {
        return this.parentLine;
      }, getSegment: function(t2) {
        return this.segs[t2];
      }, getParentCoordinates: function() {
        return this.parentLine.getCoordinates();
      }, getMinimumSize: function() {
        return this.minimumSize;
      }, asLinearRing: function() {
        return this.parentLine.getFactory().createLinearRing(vs.extractCoordinates(this.resultSegs));
      }, getSegments: function() {
        return this.segs;
      }, init: function() {
        var t2 = this.parentLine.getCoordinates();
        this.segs = new Array(t2.length - 1).fill(null);
        for (var e2 = 0; e2 < t2.length - 1; e2++) {
          var n2 = new ps(t2[e2], t2[e2 + 1], this.parentLine, e2);
          this.segs[e2] = n2;
        }
      }, getResultCoordinates: function() {
        return vs.extractCoordinates(this.resultSegs);
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return vs;
      } }), vs.extractCoordinates = function(t2) {
        for (var e2 = new Array(t2.size() + 1).fill(null), n2 = null, i3 = 0; i3 < t2.size(); i3++)
          n2 = t2.get(i3), e2[i3] = n2.p0;
        return e2[e2.length - 1] = n2.p1, e2;
      }, e(ms.prototype, { remove: function(t2) {
        this.index.remove(new C(t2.p0, t2.p1), t2);
      }, add: function() {
        if (arguments[0] instanceof vs)
          for (var t2 = arguments[0], e2 = t2.getSegments(), n2 = 0; n2 < e2.length; n2++) {
            var i3 = e2[n2];
            this.add(i3);
          }
        else if (arguments[0] instanceof ce) {
          var r2 = arguments[0];
          this.index.insert(new C(r2.p0, r2.p1), r2);
        }
      }, query: function(t2) {
        var e2 = new C(t2.p0, t2.p1), n2 = new ys(t2);
        this.index.query(e2, n2);
        var i3 = n2.getItems();
        return i3;
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return ms;
      } }), e(ys.prototype, { visitItem: function(t2) {
        var e2 = t2;
        C.intersects(e2.p0, e2.p1, this.querySeg.p0, this.querySeg.p1) && this.items.add(t2);
      }, getItems: function() {
        return this.items;
      }, interfaces_: function() {
        return [Ae];
      }, getClass: function() {
        return ys;
      } }), e(xs.prototype, { flatten: function(t2, e2) {
        var n2 = this.linePts[t2], i3 = this.linePts[e2], r2 = new ce(n2, i3);
        return this.remove(this.line, t2, e2), this.outputIndex.add(r2), r2;
      }, hasBadIntersection: function(t2, e2, n2) {
        return this.hasBadOutputIntersection(n2) ? true : !!this.hasBadInputIntersection(t2, e2, n2);
      }, setDistanceTolerance: function(t2) {
        this.distanceTolerance = t2;
      }, simplifySection: function(t2, e2, n2) {
        n2 += 1;
        var i3 = new Array(2).fill(null);
        if (t2 + 1 === e2) {
          var r2 = this.line.getSegment(t2);
          return this.line.addToResult(r2), null;
        }
        var s2 = true;
        if (this.line.getResultSize() < this.line.getMinimumSize()) {
          var o2 = n2 + 1;
          o2 < this.line.getMinimumSize() && (s2 = false);
        }
        var a2 = new Array(1).fill(null), u2 = this.findFurthestPoint(this.linePts, t2, e2, a2);
        a2[0] > this.distanceTolerance && (s2 = false);
        var l2 = new ce();
        if (l2.p0 = this.linePts[t2], l2.p1 = this.linePts[e2], i3[0] = t2, i3[1] = e2, this.hasBadIntersection(this.line, i3, l2) && (s2 = false), s2) {
          var r2 = this.flatten(t2, e2);
          return this.line.addToResult(r2), null;
        }
        this.simplifySection(t2, u2, n2), this.simplifySection(u2, e2, n2);
      }, hasBadOutputIntersection: function(t2) {
        for (var e2 = this.outputIndex.query(t2), n2 = e2.iterator(); n2.hasNext(); ) {
          var i3 = n2.next();
          if (this.hasInteriorIntersection(i3, t2))
            return true;
        }
        return false;
      }, findFurthestPoint: function(t2, e2, n2, i3) {
        var r2 = new ce();
        r2.p0 = t2[e2], r2.p1 = t2[n2];
        for (var s2 = -1, o2 = e2, a2 = e2 + 1; n2 > a2; a2++) {
          var u2 = t2[a2], l2 = r2.distance(u2);
          l2 > s2 && (s2 = l2, o2 = a2);
        }
        return i3[0] = s2, o2;
      }, simplify: function(t2) {
        this.line = t2, this.linePts = t2.getParentCoordinates(), this.simplifySection(0, this.linePts.length - 1, 0);
      }, remove: function(t2, e2, n2) {
        for (var i3 = e2; n2 > i3; i3++) {
          var r2 = t2.getSegment(i3);
          this.inputIndex.remove(r2);
        }
      }, hasInteriorIntersection: function(t2, e2) {
        return this.li.computeIntersection(t2.p0, t2.p1, e2.p0, e2.p1), this.li.isInteriorIntersection();
      }, hasBadInputIntersection: function(t2, e2, n2) {
        for (var i3 = this.inputIndex.query(n2), r2 = i3.iterator(); r2.hasNext(); ) {
          var s2 = r2.next();
          if (this.hasInteriorIntersection(s2, n2)) {
            if (xs.isInLineSection(t2, e2, s2))
              continue;
            return true;
          }
        }
        return false;
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return xs;
      } }), xs.isInLineSection = function(t2, e2, n2) {
        if (n2.getParent() !== t2.getParent())
          return false;
        var i3 = n2.getIndex();
        return i3 >= e2[0] && i3 < e2[1];
      }, e(Es.prototype, { setDistanceTolerance: function(t2) {
        this.distanceTolerance = t2;
      }, simplify: function(t2) {
        for (var e2 = t2.iterator(); e2.hasNext(); )
          this.inputIndex.add(e2.next());
        for (var e2 = t2.iterator(); e2.hasNext(); ) {
          var n2 = new xs(this.inputIndex, this.outputIndex);
          n2.setDistanceTolerance(this.distanceTolerance), n2.simplify(e2.next());
        }
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return Es;
      } }), e(Is.prototype, { getResultGeometry: function() {
        if (this.inputGeom.isEmpty())
          return this.inputGeom.copy();
        this.linestringMap = new te(), this.inputGeom.apply(new Cs(this)), this.lineSimplifier.simplify(this.linestringMap.values());
        var t2 = new Ns(this.linestringMap).transform(this.inputGeom);
        return t2;
      }, setDistanceTolerance: function(t2) {
        if (0 > t2)
          throw new i2("Tolerance must be non-negative");
        this.lineSimplifier.setDistanceTolerance(t2);
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return Is;
      } }), Is.simplify = function(t2, e2) {
        var n2 = new Is(t2);
        return n2.setDistanceTolerance(e2), n2.getResultGeometry();
      }, h(Ns, xe), e(Ns.prototype, { transformCoordinates: function(t2, e2) {
        if (0 === t2.size())
          return null;
        if (e2 instanceof St) {
          var n2 = this.linestringMap.get(e2);
          return this.createCoordinateSequence(n2.getResultCoordinates());
        }
        return xe.prototype.transformCoordinates.call(this, t2, e2);
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return Ns;
      } }), e(Cs.prototype, { filter: function(t2) {
        if (t2 instanceof St) {
          var e2 = t2;
          if (e2.isEmpty())
            return null;
          var n2 = e2.isClosed() ? 4 : 2, i3 = new vs(e2, n2);
          this.tps.linestringMap.put(e2, i3);
        }
      }, interfaces_: function() {
        return [q];
      }, getClass: function() {
        return Cs;
      } }), Is.LineStringTransformer = Ns, Is.LineStringMapBuilderFilter = Cs;
      var Mo = Object.freeze({ DouglasPeuckerSimplifier: gs, TopologyPreservingSimplifier: Is });
      e(Ss.prototype, { splitAt: function() {
        if (1 === arguments.length) {
          var t2 = arguments[0], e2 = this.minimumLen / this.segLen;
          if (t2.distance(this.seg.p0) < this.minimumLen)
            return this.splitPt = this.seg.pointAlong(e2), null;
          if (t2.distance(this.seg.p1) < this.minimumLen)
            return this.splitPt = Ss.pointAlongReverse(this.seg, e2), null;
          this.splitPt = t2;
        } else if (2 === arguments.length) {
          var n2 = arguments[0], i3 = arguments[1], r2 = this.getConstrainedLength(n2), s2 = r2 / this.segLen;
          i3.equals2D(this.seg.p0) ? this.splitPt = this.seg.pointAlong(s2) : this.splitPt = Ss.pointAlongReverse(this.seg, s2);
        }
      }, setMinimumLength: function(t2) {
        this.minimumLen = t2;
      }, getConstrainedLength: function(t2) {
        return t2 < this.minimumLen ? this.minimumLen : t2;
      }, getSplitPoint: function() {
        return this.splitPt;
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return Ss;
      } }), Ss.pointAlongReverse = function(t2, e2) {
        var n2 = new g();
        return n2.x = t2.p1.x - e2 * (t2.p1.x - t2.p0.x), n2.y = t2.p1.y - e2 * (t2.p1.y - t2.p0.y), n2;
      }, e(ws.prototype, { findSplitPoint: function(t2, e2) {
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return ws;
      } }), e(Ls.prototype, { findSplitPoint: function(t2, e2) {
        var n2 = t2.getLineSegment(), i3 = n2.getLength(), r2 = i3 / 2, s2 = new Ss(n2), o2 = Ls.projectedSplitPoint(t2, e2), a2 = 2 * o2.distance(e2) * 0.8, u2 = a2;
        return u2 > r2 && (u2 = r2), s2.setMinimumLength(u2), s2.splitAt(o2), s2.getSplitPoint();
      }, interfaces_: function() {
        return [ws];
      }, getClass: function() {
        return Ls;
      } }), Ls.projectedSplitPoint = function(t2, e2) {
        var n2 = t2.getLineSegment(), i3 = n2.project(e2);
        return i3;
      }, e(Rs.prototype, { interfaces_: function() {
        return [];
      }, getClass: function() {
        return Rs;
      } }), Rs.triArea = function(t2, e2, n2) {
        return (e2.x - t2.x) * (n2.y - t2.y) - (e2.y - t2.y) * (n2.x - t2.x);
      }, Rs.isInCircleDDNormalized = function(t2, e2, n2, i3) {
        var r2 = _.valueOf(t2.x).selfSubtract(i3.x), s2 = _.valueOf(t2.y).selfSubtract(i3.y), o2 = _.valueOf(e2.x).selfSubtract(i3.x), a2 = _.valueOf(e2.y).selfSubtract(i3.y), u2 = _.valueOf(n2.x).selfSubtract(i3.x), l2 = _.valueOf(n2.y).selfSubtract(i3.y), h2 = r2.multiply(a2).selfSubtract(o2.multiply(s2)), c2 = o2.multiply(l2).selfSubtract(u2.multiply(a2)), f2 = u2.multiply(s2).selfSubtract(r2.multiply(l2)), g2 = r2.multiply(r2).selfAdd(s2.multiply(s2)), d2 = o2.multiply(o2).selfAdd(a2.multiply(a2)), p2 = u2.multiply(u2).selfAdd(l2.multiply(l2)), v2 = g2.selfMultiply(c2).selfAdd(d2.selfMultiply(f2)).selfAdd(p2.selfMultiply(h2)), m2 = v2.doubleValue() > 0;
        return m2;
      }, Rs.checkRobustInCircle = function(t2, e2, n2, i3) {
        var r2 = Rs.isInCircleNonRobust(t2, e2, n2, i3), s2 = Rs.isInCircleDDSlow(t2, e2, n2, i3), o2 = Rs.isInCircleCC(t2, e2, n2, i3), a2 = ci.circumcentre(t2, e2, n2);
        A.out.println("p radius diff a = " + Math.abs(i3.distance(a2) - t2.distance(a2)) / t2.distance(a2)), r2 === s2 && r2 === o2 || (A.out.println("inCircle robustness failure (double result = " + r2 + ", DD result = " + s2 + ", CC result = " + o2 + ")"), A.out.println(se.toLineString(new Gt([t2, e2, n2, i3]))), A.out.println("Circumcentre = " + se.toPoint(a2) + " radius = " + t2.distance(a2)), A.out.println("p radius diff a = " + Math.abs(i3.distance(a2) / t2.distance(a2) - 1)), A.out.println("p radius diff b = " + Math.abs(i3.distance(a2) / e2.distance(a2) - 1)), A.out.println("p radius diff c = " + Math.abs(i3.distance(a2) / n2.distance(a2) - 1)), A.out.println());
      }, Rs.isInCircleDDFast = function(t2, e2, n2, i3) {
        var r2 = _.sqr(t2.x).selfAdd(_.sqr(t2.y)).selfMultiply(Rs.triAreaDDFast(e2, n2, i3)), s2 = _.sqr(e2.x).selfAdd(_.sqr(e2.y)).selfMultiply(Rs.triAreaDDFast(t2, n2, i3)), o2 = _.sqr(n2.x).selfAdd(_.sqr(n2.y)).selfMultiply(Rs.triAreaDDFast(t2, e2, i3)), a2 = _.sqr(i3.x).selfAdd(_.sqr(i3.y)).selfMultiply(Rs.triAreaDDFast(t2, e2, n2)), u2 = r2.selfSubtract(s2).selfAdd(o2).selfSubtract(a2), l2 = u2.doubleValue() > 0;
        return l2;
      }, Rs.isInCircleCC = function(t2, e2, n2, i3) {
        var r2 = ci.circumcentre(t2, e2, n2), s2 = t2.distance(r2), o2 = i3.distance(r2) - s2;
        return 0 >= o2;
      }, Rs.isInCircleNormalized = function(t2, e2, n2, i3) {
        var r2 = t2.x - i3.x, s2 = t2.y - i3.y, o2 = e2.x - i3.x, a2 = e2.y - i3.y, u2 = n2.x - i3.x, l2 = n2.y - i3.y, h2 = r2 * a2 - o2 * s2, c2 = o2 * l2 - u2 * a2, f2 = u2 * s2 - r2 * l2, g2 = r2 * r2 + s2 * s2, d2 = o2 * o2 + a2 * a2, p2 = u2 * u2 + l2 * l2, v2 = g2 * c2 + d2 * f2 + p2 * h2;
        return v2 > 0;
      }, Rs.isInCircleDDSlow = function(t2, e2, n2, i3) {
        var r2 = _.valueOf(i3.x), s2 = _.valueOf(i3.y), o2 = _.valueOf(t2.x), a2 = _.valueOf(t2.y), u2 = _.valueOf(e2.x), l2 = _.valueOf(e2.y), h2 = _.valueOf(n2.x), c2 = _.valueOf(n2.y), f2 = o2.multiply(o2).add(a2.multiply(a2)).multiply(Rs.triAreaDDSlow(u2, l2, h2, c2, r2, s2)), g2 = u2.multiply(u2).add(l2.multiply(l2)).multiply(Rs.triAreaDDSlow(o2, a2, h2, c2, r2, s2)), d2 = h2.multiply(h2).add(c2.multiply(c2)).multiply(Rs.triAreaDDSlow(o2, a2, u2, l2, r2, s2)), p2 = r2.multiply(r2).add(s2.multiply(s2)).multiply(Rs.triAreaDDSlow(o2, a2, u2, l2, h2, c2)), v2 = f2.subtract(g2).add(d2).subtract(p2), m2 = v2.doubleValue() > 0;
        return m2;
      }, Rs.isInCircleNonRobust = function(t2, e2, n2, i3) {
        var r2 = (t2.x * t2.x + t2.y * t2.y) * Rs.triArea(e2, n2, i3) - (e2.x * e2.x + e2.y * e2.y) * Rs.triArea(t2, n2, i3) + (n2.x * n2.x + n2.y * n2.y) * Rs.triArea(t2, e2, i3) - (i3.x * i3.x + i3.y * i3.y) * Rs.triArea(t2, e2, n2) > 0;
        return r2;
      }, Rs.isInCircleRobust = function(t2, e2, n2, i3) {
        return Rs.isInCircleNormalized(t2, e2, n2, i3);
      }, Rs.triAreaDDSlow = function(t2, e2, n2, i3, r2, s2) {
        return n2.subtract(t2).multiply(s2.subtract(e2)).subtract(i3.subtract(e2).multiply(r2.subtract(t2)));
      }, Rs.triAreaDDFast = function(t2, e2, n2) {
        var i3 = _.valueOf(e2.x).selfSubtract(t2.x).selfMultiply(_.valueOf(n2.y).selfSubtract(t2.y)), r2 = _.valueOf(e2.y).selfSubtract(t2.y).selfMultiply(_.valueOf(n2.x).selfSubtract(t2.x));
        return i3.selfSubtract(r2);
      }, e(Ts.prototype, { circleCenter: function(t2, e2) {
        var n2 = new Ts(this.getX(), this.getY()), i3 = this.bisector(n2, t2), r2 = this.bisector(t2, e2), s2 = new F(i3, r2), o2 = null;
        try {
          o2 = new Ts(s2.getX(), s2.getY());
        } catch (i4) {
          if (!(i4 instanceof w))
            throw i4;
          A.err.println("a: " + n2 + "  b: " + t2 + "  c: " + e2), A.err.println(i4);
        } finally {
        }
        return o2;
      }, dot: function(t2) {
        return this.p.x * t2.getX() + this.p.y * t2.getY();
      }, magn: function() {
        return Math.sqrt(this.p.x * this.p.x + this.p.y * this.p.y);
      }, getZ: function() {
        return this.p.z;
      }, bisector: function(t2, e2) {
        var n2 = e2.getX() - t2.getX(), i3 = e2.getY() - t2.getY(), r2 = new F(t2.getX() + n2 / 2, t2.getY() + i3 / 2, 1), s2 = new F(t2.getX() - i3 + n2 / 2, t2.getY() + n2 + i3 / 2, 1);
        return new F(r2, s2);
      }, equals: function() {
        if (1 === arguments.length) {
          var t2 = arguments[0];
          return this.p.x === t2.getX() && this.p.y === t2.getY();
        }
        if (2 === arguments.length) {
          var e2 = arguments[0], n2 = arguments[1];
          return this.p.distance(e2.getCoordinate()) < n2;
        }
      }, getCoordinate: function() {
        return this.p;
      }, isInCircle: function(t2, e2, n2) {
        return Rs.isInCircleRobust(t2.p, e2.p, n2.p, this.p);
      }, interpolateZValue: function(t2, e2, n2) {
        var i3 = t2.getX(), r2 = t2.getY(), s2 = e2.getX() - i3, o2 = n2.getX() - i3, a2 = e2.getY() - r2, u2 = n2.getY() - r2, l2 = s2 * u2 - o2 * a2, h2 = this.getX() - i3, c2 = this.getY() - r2, f2 = (u2 * h2 - o2 * c2) / l2, g2 = (-a2 * h2 + s2 * c2) / l2, d2 = t2.getZ() + f2 * (e2.getZ() - t2.getZ()) + g2 * (n2.getZ() - t2.getZ());
        return d2;
      }, midPoint: function(t2) {
        var e2 = (this.p.x + t2.getX()) / 2, n2 = (this.p.y + t2.getY()) / 2, i3 = (this.p.z + t2.getZ()) / 2;
        return new Ts(e2, n2, i3);
      }, rightOf: function(t2) {
        return this.isCCW(t2.dest(), t2.orig());
      }, isCCW: function(t2, e2) {
        return (t2.p.x - this.p.x) * (e2.p.y - this.p.y) - (t2.p.y - this.p.y) * (e2.p.x - this.p.x) > 0;
      }, getX: function() {
        return this.p.x;
      }, crossProduct: function(t2) {
        return this.p.x * t2.getY() - this.p.y * t2.getX();
      }, setZ: function(t2) {
        this.p.z = t2;
      }, times: function(t2) {
        return new Ts(t2 * this.p.x, t2 * this.p.y);
      }, cross: function() {
        return new Ts(this.p.y, -this.p.x);
      }, leftOf: function(t2) {
        return this.isCCW(t2.orig(), t2.dest());
      }, toString: function() {
        return "POINT (" + this.p.x + " " + this.p.y + ")";
      }, sub: function(t2) {
        return new Ts(this.p.x - t2.getX(), this.p.y - t2.getY());
      }, getY: function() {
        return this.p.y;
      }, classify: function(t2, e2) {
        var n2 = this, i3 = e2.sub(t2), r2 = n2.sub(t2), s2 = i3.crossProduct(r2);
        return s2 > 0 ? Ts.LEFT : 0 > s2 ? Ts.RIGHT : i3.getX() * r2.getX() < 0 || i3.getY() * r2.getY() < 0 ? Ts.BEHIND : i3.magn() < r2.magn() ? Ts.BEYOND : t2.equals(n2) ? Ts.ORIGIN : e2.equals(n2) ? Ts.DESTINATION : Ts.BETWEEN;
      }, sum: function(t2) {
        return new Ts(this.p.x + t2.getX(), this.p.y + t2.getY());
      }, distance: function(t2, e2) {
        return Math.sqrt(Math.pow(e2.getX() - t2.getX(), 2) + Math.pow(e2.getY() - t2.getY(), 2));
      }, circumRadiusRatio: function(t2, e2) {
        var n2 = this.circleCenter(t2, e2), i3 = this.distance(n2, t2), r2 = this.distance(this, t2), s2 = this.distance(t2, e2);
        return r2 > s2 && (r2 = s2), s2 = this.distance(e2, this), r2 > s2 && (r2 = s2), i3 / r2;
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return Ts;
      } }), Ts.interpolateZ = function() {
        if (3 === arguments.length) {
          var t2 = arguments[0], e2 = arguments[1], n2 = arguments[2], i3 = e2.distance(n2), r2 = t2.distance(e2), s2 = n2.z - e2.z, o2 = e2.z + s2 * (r2 / i3);
          return o2;
        }
        if (4 === arguments.length) {
          var a2 = arguments[0], u2 = arguments[1], l2 = arguments[2], h2 = arguments[3], c2 = u2.x, f2 = u2.y, g2 = l2.x - c2, d2 = h2.x - c2, p2 = l2.y - f2, v2 = h2.y - f2, m2 = g2 * v2 - d2 * p2, y2 = a2.x - c2, x2 = a2.y - f2, E2 = (v2 * y2 - d2 * x2) / m2, I2 = (-p2 * y2 + g2 * x2) / m2, N2 = u2.z + E2 * (l2.z - u2.z) + I2 * (h2.z - u2.z);
          return N2;
        }
      }, Ts.LEFT = 0, Ts.RIGHT = 1, Ts.BEYOND = 2, Ts.BEHIND = 3, Ts.BETWEEN = 4, Ts.ORIGIN = 5, Ts.DESTINATION = 6, h(Ps, Ts), e(Ps.prototype, { getConstraint: function() {
        return this.constraint;
      }, setOnConstraint: function(t2) {
        this._isOnConstraint = t2;
      }, merge: function(t2) {
        t2._isOnConstraint && (this._isOnConstraint = true, this.constraint = t2.constraint);
      }, isOnConstraint: function() {
        return this._isOnConstraint;
      }, setConstraint: function(t2) {
        this._isOnConstraint = true, this.constraint = t2;
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return Ps;
      } }), e(bs.prototype, { equalsNonOriented: function(t2) {
        return this.equalsOriented(t2) ? true : !!this.equalsOriented(t2.sym());
      }, toLineSegment: function() {
        return new ce(this.vertex.getCoordinate(), this.dest().getCoordinate());
      }, dest: function() {
        return this.sym().orig();
      }, oNext: function() {
        return this.next;
      }, equalsOriented: function(t2) {
        return !(!this.orig().getCoordinate().equals2D(t2.orig().getCoordinate()) || !this.dest().getCoordinate().equals2D(t2.dest().getCoordinate()));
      }, dNext: function() {
        return this.sym().oNext().sym();
      }, lPrev: function() {
        return this.next.sym();
      }, rPrev: function() {
        return this.sym().oNext();
      }, rot: function() {
        return this._rot;
      }, oPrev: function() {
        return this._rot.next._rot;
      }, sym: function() {
        return this._rot._rot;
      }, setOrig: function(t2) {
        this.vertex = t2;
      }, lNext: function() {
        return this.invRot().oNext().rot();
      }, getLength: function() {
        return this.orig().getCoordinate().distance(this.dest().getCoordinate());
      }, invRot: function() {
        return this._rot.sym();
      }, setDest: function(t2) {
        this.sym().setOrig(t2);
      }, setData: function(t2) {
        this.data = t2;
      }, getData: function() {
        return this.data;
      }, delete: function() {
        this._rot = null;
      }, orig: function() {
        return this.vertex;
      }, rNext: function() {
        return this._rot.next.invRot();
      }, toString: function() {
        var t2 = this.vertex.getCoordinate(), e2 = this.dest().getCoordinate();
        return se.toLineString(t2, e2);
      }, isLive: function() {
        return null !== this._rot;
      }, getPrimary: function() {
        return this.orig().getCoordinate().compareTo(this.dest().getCoordinate()) <= 0 ? this : this.sym();
      }, dPrev: function() {
        return this.invRot().oNext().invRot();
      }, setNext: function(t2) {
        this.next = t2;
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return bs;
      } }), bs.makeEdge = function(t2, e2) {
        var n2 = new bs(), i3 = new bs(), r2 = new bs(), s2 = new bs();
        n2._rot = i3, i3._rot = r2, r2._rot = s2, s2._rot = n2, n2.setNext(n2), i3.setNext(s2), r2.setNext(r2), s2.setNext(i3);
        var o2 = n2;
        return o2.setOrig(t2), o2.setDest(e2), o2;
      }, bs.swap = function(t2) {
        var e2 = t2.oPrev(), n2 = t2.sym().oPrev();
        bs.splice(t2, e2), bs.splice(t2.sym(), n2), bs.splice(t2, e2.lNext()), bs.splice(t2.sym(), n2.lNext()), t2.setOrig(e2.dest()), t2.setDest(n2.dest());
      }, bs.splice = function(t2, e2) {
        var n2 = t2.oNext().rot(), i3 = e2.oNext().rot(), r2 = e2.oNext(), s2 = t2.oNext(), o2 = i3.oNext(), a2 = n2.oNext();
        t2.setNext(r2), e2.setNext(s2), n2.setNext(o2), i3.setNext(a2);
      }, bs.connect = function(t2, e2) {
        var n2 = bs.makeEdge(t2.dest(), e2.orig());
        return bs.splice(n2, t2.lNext()), bs.splice(n2.sym(), e2), n2;
      }, e(Os.prototype, { insertSite: function(t2) {
        var e2 = this.subdiv.locate(t2);
        if (this.subdiv.isVertexOfEdge(e2, t2))
          return e2;
        this.subdiv.isOnEdge(e2, t2.getCoordinate()) && (e2 = e2.oPrev(), this.subdiv.delete(e2.oNext()));
        var n2 = this.subdiv.makeEdge(e2.orig(), t2);
        bs.splice(n2, e2);
        var i3 = n2;
        do
          n2 = this.subdiv.connect(e2, n2.sym()), e2 = n2.oPrev();
        while (e2.lNext() !== i3);
        for (; ; ) {
          var r2 = e2.oPrev();
          if (r2.dest().rightOf(e2) && t2.isInCircle(e2.orig(), r2.dest(), e2.dest()))
            bs.swap(e2), e2 = e2.oPrev();
          else {
            if (e2.oNext() === i3)
              return n2;
            e2 = e2.oNext().lPrev();
          }
        }
      }, insertSites: function(t2) {
        for (var e2 = t2.iterator(); e2.hasNext(); ) {
          var n2 = e2.next();
          this.insertSite(n2);
        }
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return Os;
      } }), e(_s.prototype, { locate: function(t2) {
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return _s;
      } }), e(Ms.prototype, { init: function() {
        this.lastEdge = this.findEdge();
      }, locate: function(t2) {
        this.lastEdge.isLive() || this.init();
        var e2 = this.subdiv.locateFromEdge(t2, this.lastEdge);
        return this.lastEdge = e2, e2;
      }, findEdge: function() {
        var t2 = this.subdiv.getEdges();
        return t2.iterator().next();
      }, interfaces_: function() {
        return [_s];
      }, getClass: function() {
        return Ms;
      } }), h(Ds, l), e(Ds.prototype, { getSegment: function() {
        return this.seg;
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return Ds;
      } }), Ds.msgWithSpatial = function(t2, e2) {
        return null !== e2 ? t2 + " [ " + e2 + " ]" : t2;
      }, e(As.prototype, { visit: function(t2) {
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return As;
      } }), e(Fs.prototype, { getTriangleVertices: function(t2) {
        var e2 = new Bs();
        return this.visitTriangles(e2, t2), e2.getTriangleVertices();
      }, isFrameVertex: function(t2) {
        return t2.equals(this.frameVertex[0]) ? true : t2.equals(this.frameVertex[1]) ? true : !!t2.equals(this.frameVertex[2]);
      }, isVertexOfEdge: function(t2, e2) {
        return !(!e2.equals(t2.orig(), this.tolerance) && !e2.equals(t2.dest(), this.tolerance));
      }, connect: function(t2, e2) {
        var n2 = bs.connect(t2, e2);
        return this.quadEdges.add(n2), n2;
      }, getVoronoiCellPolygon: function(t2, e2) {
        var n2 = new I(), i3 = t2;
        do {
          var r2 = t2.rot().orig().getCoordinate();
          n2.add(r2), t2 = t2.oPrev();
        } while (t2 !== i3);
        var s2 = new N();
        s2.addAll(n2, false), s2.closeRing(), s2.size() < 4 && (A.out.println(s2), s2.add(s2.get(s2.size() - 1), true));
        var o2 = s2.toCoordinateArray(), a2 = e2.createPolygon(e2.createLinearRing(o2), null), u2 = i3.orig();
        return a2.setUserData(u2.getCoordinate()), a2;
      }, setLocator: function(t2) {
        this.locator = t2;
      }, initSubdiv: function() {
        var t2 = this.makeEdge(this.frameVertex[0], this.frameVertex[1]), e2 = this.makeEdge(this.frameVertex[1], this.frameVertex[2]);
        bs.splice(t2.sym(), e2);
        var n2 = this.makeEdge(this.frameVertex[2], this.frameVertex[0]);
        return bs.splice(e2.sym(), n2), bs.splice(n2.sym(), t2), t2;
      }, isFrameBorderEdge: function(t2) {
        var e2 = new Array(3).fill(null);
        Fs.getTriangleEdges(t2, e2);
        var n2 = new Array(3).fill(null);
        Fs.getTriangleEdges(t2.sym(), n2);
        var i3 = t2.lNext().dest();
        if (this.isFrameVertex(i3))
          return true;
        var r2 = t2.sym().lNext().dest();
        return !!this.isFrameVertex(r2);
      }, makeEdge: function(t2, e2) {
        var n2 = bs.makeEdge(t2, e2);
        return this.quadEdges.add(n2), n2;
      }, visitTriangles: function(t2, e2) {
        this.visitedKey++;
        var n2 = new pe();
        n2.push(this.startingEdge);
        for (var i3 = new J(); !n2.empty(); ) {
          var r2 = n2.pop();
          if (!i3.contains(r2)) {
            var s2 = this.fetchTriangleToVisit(r2, n2, e2, i3);
            null !== s2 && t2.visit(s2);
          }
        }
      }, isFrameEdge: function(t2) {
        return !(!this.isFrameVertex(t2.orig()) && !this.isFrameVertex(t2.dest()));
      }, isOnEdge: function(t2, e2) {
        this.seg.setCoordinates(t2.orig().getCoordinate(), t2.dest().getCoordinate());
        var n2 = this.seg.distance(e2);
        return n2 < this.edgeCoincidenceTolerance;
      }, getEnvelope: function() {
        return new C(this.frameEnv);
      }, createFrame: function(t2) {
        var e2 = t2.getWidth(), n2 = t2.getHeight(), i3 = 0;
        i3 = e2 > n2 ? 10 * e2 : 10 * n2, this.frameVertex[0] = new Ts((t2.getMaxX() + t2.getMinX()) / 2, t2.getMaxY() + i3), this.frameVertex[1] = new Ts(t2.getMinX() - i3, t2.getMinY() - i3), this.frameVertex[2] = new Ts(t2.getMaxX() + i3, t2.getMinY() - i3), this.frameEnv = new C(this.frameVertex[0].getCoordinate(), this.frameVertex[1].getCoordinate()), this.frameEnv.expandToInclude(this.frameVertex[2].getCoordinate());
      }, getTriangleCoordinates: function(t2) {
        var e2 = new zs();
        return this.visitTriangles(e2, t2), e2.getTriangles();
      }, getVertices: function(t2) {
        for (var e2 = new J(), n2 = this.quadEdges.iterator(); n2.hasNext(); ) {
          var i3 = n2.next(), r2 = i3.orig();
          !t2 && this.isFrameVertex(r2) || e2.add(r2);
          var s2 = i3.dest();
          !t2 && this.isFrameVertex(s2) || e2.add(s2);
        }
        return e2;
      }, fetchTriangleToVisit: function(t2, e2, n2, i3) {
        var r2 = t2, s2 = 0, o2 = false;
        do {
          this.triEdges[s2] = r2, this.isFrameEdge(r2) && (o2 = true);
          var a2 = r2.sym();
          i3.contains(a2) || e2.push(a2), i3.add(r2), s2++, r2 = r2.lNext();
        } while (r2 !== t2);
        return o2 && !n2 ? null : this.triEdges;
      }, getEdges: function() {
        if (0 === arguments.length)
          return this.quadEdges;
        if (1 === arguments.length) {
          for (var t2 = arguments[0], e2 = this.getPrimaryEdges(false), n2 = new Array(e2.size()).fill(null), i3 = 0, r2 = e2.iterator(); r2.hasNext(); ) {
            var s2 = r2.next();
            n2[i3++] = t2.createLineString([s2.orig().getCoordinate(), s2.dest().getCoordinate()]);
          }
          return t2.createMultiLineString(n2);
        }
      }, getVertexUniqueEdges: function(t2) {
        for (var e2 = new I(), n2 = new J(), i3 = this.quadEdges.iterator(); i3.hasNext(); ) {
          var r2 = i3.next(), s2 = r2.orig();
          n2.contains(s2) || (n2.add(s2), !t2 && this.isFrameVertex(s2) || e2.add(r2));
          var o2 = r2.sym(), a2 = o2.orig();
          n2.contains(a2) || (n2.add(a2), !t2 && this.isFrameVertex(a2) || e2.add(o2));
        }
        return e2;
      }, getTriangleEdges: function(t2) {
        var e2 = new qs();
        return this.visitTriangles(e2, t2), e2.getTriangleEdges();
      }, getPrimaryEdges: function(t2) {
        this.visitedKey++;
        var e2 = new I(), n2 = new pe();
        n2.push(this.startingEdge);
        for (var i3 = new J(); !n2.empty(); ) {
          var r2 = n2.pop();
          if (!i3.contains(r2)) {
            var s2 = r2.getPrimary();
            !t2 && this.isFrameEdge(s2) || e2.add(s2), n2.push(r2.oNext()), n2.push(r2.sym().oNext()), i3.add(r2), i3.add(r2.sym());
          }
        }
        return e2;
      }, delete: function(t2) {
        bs.splice(t2, t2.oPrev()), bs.splice(t2.sym(), t2.sym().oPrev());
        var e2 = t2.sym(), n2 = t2.rot(), i3 = t2.rot().sym();
        this.quadEdges.remove(t2), this.quadEdges.remove(e2), this.quadEdges.remove(n2), this.quadEdges.remove(i3), t2.delete(), e2.delete(), n2.delete(), i3.delete();
      }, locateFromEdge: function(t2, e2) {
        for (var n2 = 0, i3 = this.quadEdges.size(), r2 = e2; ; ) {
          if (n2++, n2 > i3)
            throw new Ds(r2.toLineSegment());
          if (t2.equals(r2.orig()) || t2.equals(r2.dest()))
            break;
          if (t2.rightOf(r2))
            r2 = r2.sym();
          else if (t2.rightOf(r2.oNext())) {
            if (t2.rightOf(r2.dPrev()))
              break;
            r2 = r2.dPrev();
          } else
            r2 = r2.oNext();
        }
        return r2;
      }, getTolerance: function() {
        return this.tolerance;
      }, getVoronoiCellPolygons: function(t2) {
        this.visitTriangles(new Gs(), true);
        for (var e2 = new I(), n2 = this.getVertexUniqueEdges(false), i3 = n2.iterator(); i3.hasNext(); ) {
          var r2 = i3.next();
          e2.add(this.getVoronoiCellPolygon(r2, t2));
        }
        return e2;
      }, getVoronoiDiagram: function(t2) {
        var e2 = this.getVoronoiCellPolygons(t2);
        return t2.createGeometryCollection(ie.toGeometryArray(e2));
      }, getTriangles: function(t2) {
        for (var e2 = this.getTriangleCoordinates(false), n2 = new Array(e2.size()).fill(null), i3 = 0, r2 = e2.iterator(); r2.hasNext(); ) {
          var s2 = r2.next();
          n2[i3++] = t2.createPolygon(t2.createLinearRing(s2), null);
        }
        return t2.createGeometryCollection(n2);
      }, insertSite: function(t2) {
        var e2 = this.locate(t2);
        if (t2.equals(e2.orig(), this.tolerance) || t2.equals(e2.dest(), this.tolerance))
          return e2;
        var n2 = this.makeEdge(e2.orig(), t2);
        bs.splice(n2, e2);
        var i3 = n2;
        do
          n2 = this.connect(e2, n2.sym()), e2 = n2.oPrev();
        while (e2.lNext() !== i3);
        return i3;
      }, locate: function() {
        if (1 === arguments.length) {
          if (arguments[0] instanceof Ts) {
            var t2 = arguments[0];
            return this.locator.locate(t2);
          }
          if (arguments[0] instanceof g) {
            var e2 = arguments[0];
            return this.locator.locate(new Ts(e2));
          }
        } else if (2 === arguments.length) {
          var n2 = arguments[0], i3 = arguments[1], r2 = this.locator.locate(new Ts(n2));
          if (null === r2)
            return null;
          var s2 = r2;
          r2.dest().getCoordinate().equals2D(n2) && (s2 = r2.sym());
          var o2 = s2;
          do {
            if (o2.dest().getCoordinate().equals2D(i3))
              return o2;
            o2 = o2.oNext();
          } while (o2 !== s2);
          return null;
        }
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return Fs;
      } }), Fs.getTriangleEdges = function(t2, e2) {
        if (e2[0] = t2, e2[1] = e2[0].lNext(), e2[2] = e2[1].lNext(), e2[2].lNext() !== e2[0])
          throw new i2("Edges do not form a triangle");
      }, e(Gs.prototype, { visit: function(t2) {
        for (var e2 = t2[0].orig().getCoordinate(), n2 = t2[1].orig().getCoordinate(), i3 = t2[2].orig().getCoordinate(), r2 = ci.circumcentre(e2, n2, i3), s2 = new Ts(r2), o2 = 0; 3 > o2; o2++)
          t2[o2].rot().setOrig(s2);
      }, interfaces_: function() {
        return [As];
      }, getClass: function() {
        return Gs;
      } }), e(qs.prototype, { getTriangleEdges: function() {
        return this.triList;
      }, visit: function(t2) {
        this.triList.add(t2.clone());
      }, interfaces_: function() {
        return [As];
      }, getClass: function() {
        return qs;
      } }), e(Bs.prototype, { visit: function(t2) {
        this.triList.add([t2[0].orig(), t2[1].orig(), t2[2].orig()]);
      }, getTriangleVertices: function() {
        return this.triList;
      }, interfaces_: function() {
        return [As];
      }, getClass: function() {
        return Bs;
      } }), e(zs.prototype, { checkTriangleSize: function(t2) {
        var e2 = "";
        t2.length >= 2 ? e2 = se.toLineString(t2[0], t2[1]) : t2.length >= 1 && (e2 = se.toPoint(t2[0]));
      }, visit: function(t2) {
        this.coordList.clear();
        for (var e2 = 0; 3 > e2; e2++) {
          var n2 = t2[e2].orig();
          this.coordList.add(n2.getCoordinate());
        }
        if (this.coordList.size() > 0) {
          this.coordList.closeRing();
          var i3 = this.coordList.toCoordinateArray();
          if (4 !== i3.length)
            return null;
          this.triCoords.add(i3);
        }
      }, getTriangles: function() {
        return this.triCoords;
      }, interfaces_: function() {
        return [As];
      }, getClass: function() {
        return zs;
      } }), Fs.TriangleCircumcentreVisitor = Gs, Fs.TriangleEdgesListVisitor = qs, Fs.TriangleVertexListVisitor = Bs, Fs.TriangleCoordinatesVisitor = zs, Fs.EDGE_COINCIDENCE_TOL_FACTOR = 1e3, e(Vs.prototype, { getLineSegment: function() {
        return this.ls;
      }, getEndZ: function() {
        var t2 = this.ls.getCoordinate(1);
        return t2.z;
      }, getStartZ: function() {
        var t2 = this.ls.getCoordinate(0);
        return t2.z;
      }, intersection: function(t2) {
        return this.ls.intersection(t2.getLineSegment());
      }, getStart: function() {
        return this.ls.getCoordinate(0);
      }, getEnd: function() {
        return this.ls.getCoordinate(1);
      }, getEndY: function() {
        var t2 = this.ls.getCoordinate(1);
        return t2.y;
      }, getStartX: function() {
        var t2 = this.ls.getCoordinate(0);
        return t2.x;
      }, equalsTopo: function(t2) {
        return this.ls.equalsTopo(t2.getLineSegment());
      }, getStartY: function() {
        var t2 = this.ls.getCoordinate(0);
        return t2.y;
      }, setData: function(t2) {
        this.data = t2;
      }, getData: function() {
        return this.data;
      }, getEndX: function() {
        var t2 = this.ls.getCoordinate(1);
        return t2.x;
      }, toString: function() {
        return this.ls.toString();
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return Vs;
      } }), e(ks.prototype, { visit: function(t2) {
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return ks;
      } }), e(Ys.prototype, { isRepeated: function() {
        return this.count > 1;
      }, getRight: function() {
        return this.right;
      }, getCoordinate: function() {
        return this.p;
      }, setLeft: function(t2) {
        this.left = t2;
      }, getX: function() {
        return this.p.x;
      }, getData: function() {
        return this.data;
      }, getCount: function() {
        return this.count;
      }, getLeft: function() {
        return this.left;
      }, getY: function() {
        return this.p.y;
      }, increment: function() {
        this.count = this.count + 1;
      }, setRight: function(t2) {
        this.right = t2;
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return Ys;
      } }), e(Us.prototype, { insert: function() {
        if (1 === arguments.length) {
          var t2 = arguments[0];
          return this.insert(t2, null);
        }
        if (2 === arguments.length) {
          var e2 = arguments[0], n2 = arguments[1];
          if (null === this.root)
            return this.root = new Ys(e2, n2), this.root;
          if (this.tolerance > 0) {
            var i3 = this.findBestMatchNode(e2);
            if (null !== i3)
              return i3.increment(), i3;
          }
          return this.insertExact(e2, n2);
        }
      }, query: function() {
        var t2 = arguments, e2 = this;
        if (1 === arguments.length) {
          var n2 = arguments[0], i3 = new I();
          return this.query(n2, i3), i3;
        }
        if (2 === arguments.length) {
          if (arguments[0] instanceof C && R(arguments[1], y))
            !function() {
              var n3 = t2[0], i4 = t2[1];
              e2.queryNode(e2.root, n3, true, { interfaces_: function() {
                return [ks];
              }, visit: function(t3) {
                i4.add(t3);
              } });
            }();
          else if (arguments[0] instanceof C && R(arguments[1], ks)) {
            var r2 = arguments[0], s2 = arguments[1];
            this.queryNode(this.root, r2, true, s2);
          }
        }
      }, queryNode: function(t2, e2, n2, i3) {
        if (null === t2)
          return null;
        var r2 = null, s2 = null, o2 = null;
        n2 ? (r2 = e2.getMinX(), s2 = e2.getMaxX(), o2 = t2.getX()) : (r2 = e2.getMinY(), s2 = e2.getMaxY(), o2 = t2.getY());
        var a2 = o2 > r2, u2 = s2 >= o2;
        a2 && this.queryNode(t2.getLeft(), e2, !n2, i3), e2.contains(t2.getCoordinate()) && i3.visit(t2), u2 && this.queryNode(t2.getRight(), e2, !n2, i3);
      }, findBestMatchNode: function(t2) {
        var e2 = new Xs(t2, this.tolerance);
        return this.query(e2.queryEnvelope(), e2), e2.getNode();
      }, isEmpty: function() {
        return null === this.root;
      }, insertExact: function(t2, e2) {
        for (var n2 = this.root, i3 = this.root, r2 = true, s2 = true; null !== n2; ) {
          if (null !== n2) {
            var o2 = t2.distance(n2.getCoordinate()) <= this.tolerance;
            if (o2)
              return n2.increment(), n2;
          }
          s2 = r2 ? t2.x < n2.getX() : t2.y < n2.getY(), i3 = n2, n2 = s2 ? n2.getLeft() : n2.getRight(), r2 = !r2;
        }
        this.numberOfNodes = this.numberOfNodes + 1;
        var a2 = new Ys(t2, e2);
        return s2 ? i3.setLeft(a2) : i3.setRight(a2), a2;
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return Us;
      } }), Us.toCoordinates = function() {
        if (1 === arguments.length) {
          var t2 = arguments[0];
          return Us.toCoordinates(t2, false);
        }
        if (2 === arguments.length) {
          for (var e2 = arguments[0], n2 = arguments[1], i3 = new N(), r2 = e2.iterator(); r2.hasNext(); )
            for (var s2 = r2.next(), o2 = n2 ? s2.getCount() : 1, a2 = 0; o2 > a2; a2++)
              i3.add(s2.getCoordinate(), true);
          return i3.toCoordinateArray();
        }
      }, e(Xs.prototype, { visit: function(t2) {
        var e2 = this.p.distance(t2.getCoordinate()), n2 = e2 <= this.tolerance;
        if (!n2)
          return null;
        var i3 = false;
        (null === this.matchNode || e2 < this.matchDist || null !== this.matchNode && e2 === this.matchDist && t2.getCoordinate().compareTo(this.matchNode.getCoordinate()) < 1) && (i3 = true), i3 && (this.matchNode = t2, this.matchDist = e2);
      }, queryEnvelope: function() {
        var t2 = new C(this.p);
        return t2.expandBy(this.tolerance), t2;
      }, getNode: function() {
        return this.matchNode;
      }, interfaces_: function() {
        return [ks];
      }, getClass: function() {
        return Xs;
      } }), Us.BestMatchVisitor = Xs, e(Hs.prototype, { getInitialVertices: function() {
        return this.initialVertices;
      }, getKDT: function() {
        return this.kdt;
      }, enforceConstraints: function() {
        this.addConstraintVertices();
        var t2 = 0, e2 = 0;
        do
          e2 = this.enforceGabriel(this.segments), t2++;
        while (e2 > 0 && t2 < Hs.MAX_SPLIT_ITER);
      }, insertSites: function(t2) {
        for (var e2 = t2.iterator(); e2.hasNext(); ) {
          var n2 = e2.next();
          this.insertSite(n2);
        }
      }, getVertexFactory: function() {
        return this.vertexFactory;
      }, getPointArray: function() {
        for (var t2 = new Array(this.initialVertices.size() + this.segVertices.size()).fill(null), e2 = 0, n2 = this.initialVertices.iterator(); n2.hasNext(); ) {
          var i3 = n2.next();
          t2[e2++] = i3.getCoordinate();
        }
        for (var r2 = this.segVertices.iterator(); r2.hasNext(); ) {
          var i3 = r2.next();
          t2[e2++] = i3.getCoordinate();
        }
        return t2;
      }, setConstraints: function(t2, e2) {
        this.segments = t2, this.segVertices = e2;
      }, computeConvexHull: function() {
        var t2 = new ie(), e2 = this.getPointArray(), n2 = new me(e2, t2);
        this.convexHull = n2.getConvexHull();
      }, addConstraintVertices: function() {
        this.computeConvexHull(), this.insertSites(this.segVertices);
      }, findNonGabrielPoint: function(t2) {
        var e2 = t2.getStart(), n2 = t2.getEnd(), i3 = new g((e2.x + n2.x) / 2, (e2.y + n2.y) / 2), s2 = e2.distance(i3), o2 = new C(i3);
        o2.expandBy(s2);
        for (var a2 = this.kdt.query(o2), u2 = null, l2 = r.MAX_VALUE, h2 = a2.iterator(); h2.hasNext(); ) {
          var c2 = h2.next(), f2 = c2.getCoordinate();
          if (!f2.equals2D(e2) && !f2.equals2D(n2)) {
            var d2 = i3.distance(f2);
            if (s2 > d2) {
              var p2 = d2;
              (null === u2 || l2 > p2) && (u2 = f2, l2 = p2);
            }
          }
        }
        return u2;
      }, getConstraintSegments: function() {
        return this.segments;
      }, setSplitPointFinder: function(t2) {
        this.splitFinder = t2;
      }, getConvexHull: function() {
        return this.convexHull;
      }, getTolerance: function() {
        return this.tolerance;
      }, enforceGabriel: function(t2) {
        for (var e2 = new I(), n2 = 0, i3 = new I(), r2 = t2.iterator(); r2.hasNext(); ) {
          var s2 = r2.next(), o2 = this.findNonGabrielPoint(s2);
          if (null !== o2) {
            this.splitPt = this.splitFinder.findSplitPoint(s2, o2);
            var a2 = this.createVertex(this.splitPt, s2), u2 = (this.insertSite(a2), new Vs(s2.getStartX(), s2.getStartY(), s2.getStartZ(), a2.getX(), a2.getY(), a2.getZ(), s2.getData())), l2 = new Vs(a2.getX(), a2.getY(), a2.getZ(), s2.getEndX(), s2.getEndY(), s2.getEndZ(), s2.getData());
            e2.add(u2), e2.add(l2), i3.add(s2), n2 += 1;
          }
        }
        return t2.removeAll(i3), t2.addAll(e2), n2;
      }, createVertex: function() {
        if (1 === arguments.length) {
          var t2 = arguments[0], e2 = null;
          return e2 = null !== this.vertexFactory ? this.vertexFactory.createVertex(t2, null) : new Ps(t2);
        }
        if (2 === arguments.length) {
          var n2 = arguments[0], i3 = arguments[1], e2 = null;
          return e2 = null !== this.vertexFactory ? this.vertexFactory.createVertex(n2, i3) : new Ps(n2), e2.setOnConstraint(true), e2;
        }
      }, getSubdivision: function() {
        return this.subdiv;
      }, computeBoundingBox: function() {
        var t2 = Hs.computeVertexEnvelope(this.initialVertices), e2 = Hs.computeVertexEnvelope(this.segVertices), n2 = new C(t2);
        n2.expandToInclude(e2);
        var i3 = 0.2 * n2.getWidth(), r2 = 0.2 * n2.getHeight(), s2 = Math.max(i3, r2);
        this.computeAreaEnv = new C(n2), this.computeAreaEnv.expandBy(s2);
      }, setVertexFactory: function(t2) {
        this.vertexFactory = t2;
      }, formInitialDelaunay: function() {
        this.computeBoundingBox(), this.subdiv = new Fs(this.computeAreaEnv, this.tolerance), this.subdiv.setLocator(new Ms(this.subdiv)), this.incDel = new Os(this.subdiv), this.insertSites(this.initialVertices);
      }, insertSite: function() {
        if (arguments[0] instanceof Ps) {
          var t2 = arguments[0], e2 = this.kdt.insert(t2.getCoordinate(), t2);
          if (e2.isRepeated()) {
            var n2 = e2.getData();
            return n2.merge(t2), n2;
          }
          return this.incDel.insertSite(t2), t2;
        }
        if (arguments[0] instanceof g) {
          var i3 = arguments[0];
          this.insertSite(this.createVertex(i3));
        }
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return Hs;
      } }), Hs.computeVertexEnvelope = function(t2) {
        for (var e2 = new C(), n2 = t2.iterator(); n2.hasNext(); ) {
          var i3 = n2.next();
          e2.expandToInclude(i3.getCoordinate());
        }
        return e2;
      }, Hs.MAX_SPLIT_ITER = 99, e(Ws.prototype, { create: function() {
        if (null !== this.subdiv)
          return null;
        var t2 = Ws.envelope(this.siteCoords), e2 = Ws.toVertices(this.siteCoords);
        this.subdiv = new Fs(t2, this.tolerance);
        var n2 = new Os(this.subdiv);
        n2.insertSites(e2);
      }, setTolerance: function(t2) {
        this.tolerance = t2;
      }, setSites: function() {
        if (arguments[0] instanceof B) {
          var t2 = arguments[0];
          this.siteCoords = Ws.extractUniqueCoordinates(t2);
        } else if (R(arguments[0], v)) {
          var e2 = arguments[0];
          this.siteCoords = Ws.unique(H.toCoordinateArray(e2));
        }
      }, getEdges: function(t2) {
        return this.create(), this.subdiv.getEdges(t2);
      }, getSubdivision: function() {
        return this.create(), this.subdiv;
      }, getTriangles: function(t2) {
        return this.create(), this.subdiv.getTriangles(t2);
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return Ws;
      } }), Ws.extractUniqueCoordinates = function(t2) {
        if (null === t2)
          return new N();
        var e2 = t2.getCoordinates();
        return Ws.unique(e2);
      }, Ws.envelope = function(t2) {
        for (var e2 = new C(), n2 = t2.iterator(); n2.hasNext(); ) {
          var i3 = n2.next();
          e2.expandToInclude(i3);
        }
        return e2;
      }, Ws.unique = function(t2) {
        var e2 = H.copyDeep(t2);
        ut.sort(e2);
        var n2 = new N(e2, false);
        return n2;
      }, Ws.toVertices = function(t2) {
        for (var e2 = new I(), n2 = t2.iterator(); n2.hasNext(); ) {
          var i3 = n2.next();
          e2.add(new Ts(i3));
        }
        return e2;
      }, e(js.prototype, { createSiteVertices: function(t2) {
        for (var e2 = new I(), n2 = t2.iterator(); n2.hasNext(); ) {
          var i3 = n2.next();
          this.constraintVertexMap.containsKey(i3) || e2.add(new Ps(i3));
        }
        return e2;
      }, create: function() {
        if (null !== this.subdiv)
          return null;
        var t2 = Ws.envelope(this.siteCoords), e2 = new I();
        null !== this.constraintLines && (t2.expandToInclude(this.constraintLines.getEnvelopeInternal()), this.createVertices(this.constraintLines), e2 = js.createConstraintSegments(this.constraintLines));
        var n2 = this.createSiteVertices(this.siteCoords), i3 = new Hs(n2, this.tolerance);
        i3.setConstraints(e2, new I(this.constraintVertexMap.values())), i3.formInitialDelaunay(), i3.enforceConstraints(), this.subdiv = i3.getSubdivision();
      }, setTolerance: function(t2) {
        this.tolerance = t2;
      }, setConstraints: function(t2) {
        this.constraintLines = t2;
      }, setSites: function(t2) {
        this.siteCoords = Ws.extractUniqueCoordinates(t2);
      }, getEdges: function(t2) {
        return this.create(), this.subdiv.getEdges(t2);
      }, getSubdivision: function() {
        return this.create(), this.subdiv;
      }, getTriangles: function(t2) {
        return this.create(), this.subdiv.getTriangles(t2);
      }, createVertices: function(t2) {
        for (var e2 = t2.getCoordinates(), n2 = 0; n2 < e2.length; n2++) {
          var i3 = new Ps(e2[n2]);
          this.constraintVertexMap.put(e2[n2], i3);
        }
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return js;
      } }), js.createConstraintSegments = function() {
        if (1 === arguments.length) {
          for (var t2 = arguments[0], e2 = kn.getLines(t2), n2 = new I(), i3 = e2.iterator(); i3.hasNext(); ) {
            var r2 = i3.next();
            js.createConstraintSegments(r2, n2);
          }
          return n2;
        }
        if (2 === arguments.length)
          for (var s2 = arguments[0], o2 = arguments[1], a2 = s2.getCoordinates(), i3 = 1; i3 < a2.length; i3++)
            o2.add(new Vs(a2[i3 - 1], a2[i3]));
      }, e(Ks.prototype, { create: function() {
        if (null !== this.subdiv)
          return null;
        var t2 = Ws.envelope(this.siteCoords);
        this.diagramEnv = t2;
        var e2 = Math.max(this.diagramEnv.getWidth(), this.diagramEnv.getHeight());
        this.diagramEnv.expandBy(e2), null !== this.clipEnv && this.diagramEnv.expandToInclude(this.clipEnv);
        var n2 = Ws.toVertices(this.siteCoords);
        this.subdiv = new Fs(t2, this.tolerance);
        var i3 = new Os(this.subdiv);
        i3.insertSites(n2);
      }, getDiagram: function(t2) {
        this.create();
        var e2 = this.subdiv.getVoronoiDiagram(t2);
        return Ks.clipGeometryCollection(e2, this.diagramEnv);
      }, setTolerance: function(t2) {
        this.tolerance = t2;
      }, setSites: function() {
        if (arguments[0] instanceof B) {
          var t2 = arguments[0];
          this.siteCoords = Ws.extractUniqueCoordinates(t2);
        } else if (R(arguments[0], v)) {
          var e2 = arguments[0];
          this.siteCoords = Ws.unique(H.toCoordinateArray(e2));
        }
      }, setClipEnvelope: function(t2) {
        this.clipEnv = t2;
      }, getSubdivision: function() {
        return this.create(), this.subdiv;
      }, interfaces_: function() {
        return [];
      }, getClass: function() {
        return Ks;
      } }), Ks.clipGeometryCollection = function(t2, e2) {
        for (var n2 = t2.getFactory().toGeometry(e2), i3 = new I(), r2 = 0; r2 < t2.getNumGeometries(); r2++) {
          var s2 = t2.getGeometryN(r2), o2 = null;
          e2.contains(s2.getEnvelopeInternal()) ? o2 = s2 : e2.intersects(s2.getEnvelopeInternal()) && (o2 = n2.intersection(s2), o2.setUserData(s2.getUserData())), null === o2 || o2.isEmpty() || i3.add(o2);
        }
        return t2.getFactory().createGeometryCollection(ie.toGeometryArray(i3));
      };
      var Do = Object.freeze({ ConformingDelaunayTriangulationBuilder: js, DelaunayTriangulationBuilder: Ws, VoronoiDiagramBuilder: Ks });
      e(Zs.prototype, { interfaces_: function() {
        return [];
      }, getClass: function() {
        return Zs;
      } }), Zs.union = function(t2, e2) {
        if (t2.isEmpty() || e2.isEmpty()) {
          if (t2.isEmpty() && e2.isEmpty())
            return ii.createEmptyResult(ii.UNION, t2, e2, t2.getFactory());
          if (t2.isEmpty())
            return e2.copy();
          if (e2.isEmpty())
            return t2.copy();
        }
        return t2.checkNotGeometryCollection(t2), t2.checkNotGeometryCollection(e2), si.overlayOp(t2, e2, ii.UNION);
      }, e(B.prototype, { equalsTopo: function(t2) {
        return this.getEnvelopeInternal().equals(t2.getEnvelopeInternal()) ? Yr.relate(this, t2).isEquals(this.getDimension(), t2.getDimension()) : false;
      }, union: function() {
        if (0 === arguments.length)
          return jr.union(this);
        if (1 === arguments.length) {
          var t2 = arguments[0];
          return Zs.union(this, t2);
        }
      }, isValid: function() {
        return ls.isValid(this);
      }, intersection: function(t2) {
        if (this.isEmpty() || t2.isEmpty())
          return ii.createEmptyResult(ii.INTERSECTION, this, t2, this.factory);
        if (this.isGeometryCollection()) {
          var e2 = t2;
          return hn.map(this, { interfaces_: function() {
            return [MapOp];
          }, map: function(t3) {
            return t3.intersection(e2);
          } });
        }
        return this.checkNotGeometryCollection(this), this.checkNotGeometryCollection(t2), si.overlayOp(this, t2, ii.INTERSECTION);
      }, covers: function(t2) {
        return Yr.covers(this, t2);
      }, coveredBy: function(t2) {
        return Yr.coveredBy(this, t2);
      }, touches: function(t2) {
        return Yr.touches(this, t2);
      }, intersects: function(t2) {
        return Yr.intersects(this, t2);
      }, within: function(t2) {
        return Yr.within(this, t2);
      }, overlaps: function(t2) {
        return Yr.overlaps(this, t2);
      }, disjoint: function(t2) {
        return Yr.disjoint(this, t2);
      }, crosses: function(t2) {
        return Yr.crosses(this, t2);
      }, buffer: function() {
        if (1 === arguments.length) {
          var t2 = arguments[0];
          return sr.bufferOp(this, t2);
        }
        if (2 === arguments.length) {
          var e2 = arguments[0], n2 = arguments[1];
          return sr.bufferOp(this, e2, n2);
        }
        if (3 === arguments.length) {
          var i3 = arguments[0], r2 = arguments[1], s2 = arguments[2];
          return sr.bufferOp(this, i3, r2, s2);
        }
      }, convexHull: function() {
        return new me(this).getConvexHull();
      }, relate: function() {
        for (var t2 = arguments.length, e2 = Array(t2), n2 = 0; t2 > n2; n2++)
          e2[n2] = arguments[n2];
        return Yr.relate.apply(Yr, [this].concat(e2));
      }, getCentroid: function() {
        if (this.isEmpty())
          return this.factory.createPoint();
        var t2 = ge.getCentroid(this);
        return this.createPointFromInternalCoord(t2, this);
      }, getInteriorPoint: function() {
        if (this.isEmpty())
          return this.factory.createPoint();
        var t2 = null, e2 = this.getDimension();
        if (0 === e2) {
          var n2 = new li(this);
          t2 = n2.getInteriorPoint();
        } else if (1 === e2) {
          var n2 = new ui(this);
          t2 = n2.getInteriorPoint();
        } else {
          var n2 = new oi(this);
          t2 = n2.getInteriorPoint();
        }
        return this.createPointFromInternalCoord(t2, this);
      }, symDifference: function(t2) {
        if (this.isEmpty() || t2.isEmpty()) {
          if (this.isEmpty() && t2.isEmpty())
            return ii.createEmptyResult(ii.SYMDIFFERENCE, this, t2, this.factory);
          if (this.isEmpty())
            return t2.copy();
          if (t2.isEmpty())
            return this.copy();
        }
        return this.checkNotGeometryCollection(this), this.checkNotGeometryCollection(t2), si.overlayOp(this, t2, ii.SYMDIFFERENCE);
      }, createPointFromInternalCoord: function(t2, e2) {
        return e2.getPrecisionModel().makePrecise(t2), e2.getFactory().createPoint(t2);
      }, toText: function() {
        var t2 = new se();
        return t2.write(this);
      }, toString: function() {
        this.toText();
      }, contains: function(t2) {
        return Yr.contains(this, t2);
      }, difference: function(t2) {
        return this.isEmpty() ? ii.createEmptyResult(ii.DIFFERENCE, this, t2, this.factory) : t2.isEmpty() ? this.copy() : (this.checkNotGeometryCollection(this), this.checkNotGeometryCollection(t2), si.overlayOp(this, t2, ii.DIFFERENCE));
      }, isSimple: function() {
        var t2 = new Gi(this);
        return t2.isSimple();
      }, isWithinDistance: function(t2, e2) {
        var n2 = this.getEnvelopeInternal().distance(t2.getEnvelopeInternal());
        return n2 > e2 ? false : hr.isWithinDistance(this, t2, e2);
      }, distance: function(t2) {
        return hr.distance(this, t2);
      }, isEquivalentClass: function(t2) {
        return this.getClass() === t2.getClass();
      } });
      var Ao = "1.1.2 (248dab8)";
      t.version = Ao, t.algorithm = co, t.densify = fo, t.dissolve = go, t.geom = lo, t.index = mo, t.io = Io, t.noding = No, t.operation = Oo, t.precision = _o, t.simplify = Mo, t.triangulate = Do;
    });
  }
});

// node_modules/turf-union/index.js
var require_turf_union = __commonJS({
  "node_modules/turf-union/index.js"(exports, module) {
    var jsts = require_jsts_min();
    module.exports = function(poly1, poly2) {
      var reader = new jsts.io.GeoJSONReader();
      var a = reader.read(JSON.stringify(poly1.geometry));
      var b = reader.read(JSON.stringify(poly2.geometry));
      var union = a.union(b);
      var writer = new jsts.io.GeoJSONWriter();
      union = writer.write(union);
      return {
        type: "Feature",
        geometry: union,
        properties: poly1.properties
      };
    };
  }
});

// node_modules/turf-concave/index.js
var require_turf_concave = __commonJS({
  "node_modules/turf-concave/index.js"(exports, module) {
    var tin = require_turf_tin();
    var union = require_turf_union();
    var distance = require_turf_distance();
    function concave(points, maxEdge, units) {
      if (typeof maxEdge !== "number")
        throw new Error("maxEdge parameter is required");
      if (typeof units !== "string")
        throw new Error("units parameter is required");
      var tinPolys = tin(points);
      var filteredPolys = tinPolys.features.filter(filterTriangles);
      tinPolys.features = filteredPolys;
      function filterTriangles(triangle) {
        var pt1 = triangle.geometry.coordinates[0][0];
        var pt2 = triangle.geometry.coordinates[0][1];
        var pt3 = triangle.geometry.coordinates[0][2];
        var dist1 = distance(pt1, pt2, units);
        var dist2 = distance(pt2, pt3, units);
        var dist3 = distance(pt1, pt3, units);
        return dist1 <= maxEdge && dist2 <= maxEdge && dist3 <= maxEdge;
      }
      return merge(tinPolys);
    }
    function merge(polygons) {
      var merged = JSON.parse(JSON.stringify(polygons.features[0])), features = polygons.features;
      for (var i2 = 0, len = features.length; i2 < len; i2++) {
        var poly = features[i2];
        if (poly.geometry) {
          merged = union(merged, poly);
        }
      }
      return merged;
    }
    module.exports = concave;
  }
});

// node_modules/turf-difference/index.js
var require_turf_difference = __commonJS({
  "node_modules/turf-difference/index.js"(exports, module) {
    var jsts = require_jsts_min();
    module.exports = function(p1, p2) {
      var poly1 = JSON.parse(JSON.stringify(p1));
      var poly2 = JSON.parse(JSON.stringify(p2));
      if (poly1.type !== "Feature") {
        poly1 = {
          type: "Feature",
          properties: {},
          geometry: poly1
        };
      }
      if (poly2.type !== "Feature") {
        poly2 = {
          type: "Feature",
          properties: {},
          geometry: poly2
        };
      }
      var reader = new jsts.io.GeoJSONReader();
      var a = reader.read(JSON.stringify(poly1.geometry));
      var b = reader.read(JSON.stringify(poly2.geometry));
      var differenced = a.difference(b);
      if (differenced.isEmpty())
        return void 0;
      var writer = new jsts.io.GeoJSONWriter();
      var geojsonGeometry = writer.write(differenced);
      poly1.geometry = differenced;
      return {
        type: "Feature",
        properties: poly1.properties,
        geometry: geojsonGeometry
      };
    };
  }
});

// node_modules/turf-collect/index.js
var require_turf_collect = __commonJS({
  "node_modules/turf-collect/index.js"(exports, module) {
    var inside = require_turf_inside();
    module.exports = function collect(polygons, points, inProperty, outProperty) {
      polygons.features.forEach(function(poly) {
        var values = points.features.filter(function(pt) {
          return inside(pt, poly);
        }).map(function(pt) {
          return pt.properties[inProperty];
        });
        if (!poly.properties) {
          poly.properties = {};
        }
        poly.properties[outProperty] = values;
      });
      return polygons;
    };
  }
});

// node_modules/turf-flip/index.js
var require_turf_flip = __commonJS({
  "node_modules/turf-flip/index.js"(exports, module) {
    var coordEach = require_turf_meta().coordEach;
    module.exports = function flip(input) {
      input = JSON.parse(JSON.stringify(input));
      coordEach(input, function(coord) {
        coord.reverse();
      });
      return input;
    };
  }
});

// node_modules/simplify-js/simplify.js
var require_simplify = __commonJS({
  "node_modules/simplify-js/simplify.js"(exports, module) {
    (function() {
      "use strict";
      function getSqDist(p1, p2) {
        var dx = p1.x - p2.x, dy = p1.y - p2.y;
        return dx * dx + dy * dy;
      }
      function getSqSegDist(p, p1, p2) {
        var x = p1.x, y = p1.y, dx = p2.x - x, dy = p2.y - y;
        if (dx !== 0 || dy !== 0) {
          var t = ((p.x - x) * dx + (p.y - y) * dy) / (dx * dx + dy * dy);
          if (t > 1) {
            x = p2.x;
            y = p2.y;
          } else if (t > 0) {
            x += dx * t;
            y += dy * t;
          }
        }
        dx = p.x - x;
        dy = p.y - y;
        return dx * dx + dy * dy;
      }
      function simplifyRadialDist(points, sqTolerance) {
        var prevPoint = points[0], newPoints = [prevPoint], point;
        for (var i2 = 1, len = points.length; i2 < len; i2++) {
          point = points[i2];
          if (getSqDist(point, prevPoint) > sqTolerance) {
            newPoints.push(point);
            prevPoint = point;
          }
        }
        if (prevPoint !== point)
          newPoints.push(point);
        return newPoints;
      }
      function simplifyDPStep(points, first, last, sqTolerance, simplified) {
        var maxSqDist = sqTolerance, index;
        for (var i2 = first + 1; i2 < last; i2++) {
          var sqDist = getSqSegDist(points[i2], points[first], points[last]);
          if (sqDist > maxSqDist) {
            index = i2;
            maxSqDist = sqDist;
          }
        }
        if (maxSqDist > sqTolerance) {
          if (index - first > 1)
            simplifyDPStep(points, first, index, sqTolerance, simplified);
          simplified.push(points[index]);
          if (last - index > 1)
            simplifyDPStep(points, index, last, sqTolerance, simplified);
        }
      }
      function simplifyDouglasPeucker(points, sqTolerance) {
        var last = points.length - 1;
        var simplified = [points[0]];
        simplifyDPStep(points, 0, last, sqTolerance, simplified);
        simplified.push(points[last]);
        return simplified;
      }
      function simplify(points, tolerance, highestQuality) {
        if (points.length <= 2)
          return points;
        var sqTolerance = tolerance !== void 0 ? tolerance * tolerance : 1;
        points = highestQuality ? points : simplifyRadialDist(points, sqTolerance);
        points = simplifyDouglasPeucker(points, sqTolerance);
        return points;
      }
      if (typeof define === "function" && define.amd)
        define(function() {
          return simplify;
        });
      else if (typeof module !== "undefined") {
        module.exports = simplify;
        module.exports.default = simplify;
      } else if (typeof self !== "undefined")
        self.simplify = simplify;
      else
        window.simplify = simplify;
    })();
  }
});

// node_modules/turf-simplify/index.js
var require_turf_simplify = __commonJS({
  "node_modules/turf-simplify/index.js"(exports, module) {
    var simplify = require_simplify();
    var supportedTypes = ["LineString", "MultiLineString", "Polygon", "MultiPolygon"];
    module.exports = function(feature, tolerance, highQuality) {
      if (feature.type === "Feature") {
        return simpleFeature(
          simplifyHelper(feature, tolerance, highQuality),
          feature.properties
        );
      } else if (feature.type === "FeatureCollection") {
        return {
          type: "FeatureCollection",
          features: feature.features.map(function(f) {
            var simplified = simplifyHelper(f, tolerance, highQuality);
            if (supportedTypes.indexOf(simplified.type) > -1) {
              return simpleFeature(simplified, f.properties);
            } else {
              return simplified;
            }
          })
        };
      } else if (feature.type === "GeometryCollection") {
        return {
          type: "GeometryCollection",
          geometries: feature.geometries.map(function(g) {
            if (supportedTypes.indexOf(g.type) > -1) {
              return simplifyHelper({
                type: "Feature",
                geometry: g
              }, tolerance, highQuality);
            }
            return g;
          })
        };
      } else {
        return feature;
      }
    };
    function simplifyHelper(feature, tolerance, highQuality) {
      if (feature.geometry.type === "LineString") {
        return {
          type: "LineString",
          coordinates: simplifyLine(feature.geometry.coordinates, tolerance, highQuality)
        };
      } else if (feature.geometry.type === "MultiLineString") {
        return {
          type: "MultiLineString",
          coordinates: feature.geometry.coordinates.map(function(lines) {
            return simplifyLine(lines, tolerance, highQuality);
          })
        };
      } else if (feature.geometry.type === "Polygon") {
        return {
          type: "Polygon",
          coordinates: simplifyPolygon(feature.geometry.coordinates, tolerance, highQuality)
        };
      } else if (feature.geometry.type === "MultiPolygon") {
        return {
          type: "MultiPolygon",
          coordinates: feature.geometry.coordinates.map(function(rings) {
            return simplifyPolygon(rings, tolerance, highQuality);
          })
        };
      } else {
        return feature;
      }
    }
    function checkValidity(ring) {
      if (ring.length < 3) {
        return false;
      } else if (ring.length === 3 && (ring[2][0] === ring[0][0] && ring[2][1] === ring[0][1])) {
        return false;
      } else {
        return true;
      }
    }
    function simpleFeature(geom, properties) {
      return {
        type: "Feature",
        geometry: geom,
        properties
      };
    }
    function simplifyLine(coordinates, tolerance, highQuality) {
      return simplify(coordinates.map(function(coord) {
        return { x: coord[0], y: coord[1] };
      }), tolerance, highQuality).map(function(coords) {
        return [coords.x, coords.y];
      });
    }
    function simplifyPolygon(coordinates, tolerance, highQuality) {
      return coordinates.map(function(ring) {
        var pts = ring.map(function(coord) {
          return { x: coord[0], y: coord[1] };
        });
        if (pts.length < 4) {
          throw new Error("Invalid polygon");
        }
        var simpleRing = simplify(pts, tolerance, highQuality).map(function(coords) {
          return [coords.x, coords.y];
        });
        while (!checkValidity(simpleRing)) {
          tolerance -= tolerance * 0.01;
          simpleRing = simplify(pts, tolerance, highQuality).map(function(coords) {
            return [coords.x, coords.y];
          });
        }
        if (simpleRing[simpleRing.length - 1][0] !== simpleRing[0][0] || simpleRing[simpleRing.length - 1][1] !== simpleRing[0][1]) {
          simpleRing.push(simpleRing[0]);
        }
        return simpleRing;
      });
    }
  }
});

// node_modules/turf-bezier/spline.js
var require_spline = __commonJS({
  "node_modules/turf-bezier/spline.js"(exports, module) {
    var Spline = function(options) {
      this.points = options.points || [];
      this.duration = options.duration || 1e4;
      this.sharpness = options.sharpness || 0.85;
      this.centers = [];
      this.controls = [];
      this.stepLength = options.stepLength || 60;
      this.length = this.points.length;
      this.delay = 0;
      for (var i2 = 0; i2 < this.length; i2++)
        this.points[i2].z = this.points[i2].z || 0;
      for (var i2 = 0; i2 < this.length - 1; i2++) {
        var p1 = this.points[i2];
        var p2 = this.points[i2 + 1];
        this.centers.push({
          x: (p1.x + p2.x) / 2,
          y: (p1.y + p2.y) / 2,
          z: (p1.z + p2.z) / 2
        });
      }
      this.controls.push([this.points[0], this.points[0]]);
      for (var i2 = 0; i2 < this.centers.length - 1; i2++) {
        var p1 = this.centers[i2];
        var p2 = this.centers[i2 + 1];
        var dx = this.points[i2 + 1].x - (this.centers[i2].x + this.centers[i2 + 1].x) / 2;
        var dy = this.points[i2 + 1].y - (this.centers[i2].y + this.centers[i2 + 1].y) / 2;
        var dz = this.points[i2 + 1].z - (this.centers[i2].y + this.centers[i2 + 1].z) / 2;
        this.controls.push([
          {
            x: (1 - this.sharpness) * this.points[i2 + 1].x + this.sharpness * (this.centers[i2].x + dx),
            y: (1 - this.sharpness) * this.points[i2 + 1].y + this.sharpness * (this.centers[i2].y + dy),
            z: (1 - this.sharpness) * this.points[i2 + 1].z + this.sharpness * (this.centers[i2].z + dz)
          },
          {
            x: (1 - this.sharpness) * this.points[i2 + 1].x + this.sharpness * (this.centers[i2 + 1].x + dx),
            y: (1 - this.sharpness) * this.points[i2 + 1].y + this.sharpness * (this.centers[i2 + 1].y + dy),
            z: (1 - this.sharpness) * this.points[i2 + 1].z + this.sharpness * (this.centers[i2 + 1].z + dz)
          }
        ]);
      }
      this.controls.push([this.points[this.length - 1], this.points[this.length - 1]]);
      this.steps = this.cacheSteps(this.stepLength);
      return this;
    };
    Spline.prototype.cacheSteps = function(mindist) {
      var steps = [];
      var laststep = this.pos(0);
      steps.push(0);
      for (var t = 0; t < this.duration; t += 10) {
        var step = this.pos(t);
        var dist = Math.sqrt((step.x - laststep.x) * (step.x - laststep.x) + (step.y - laststep.y) * (step.y - laststep.y) + (step.z - laststep.z) * (step.z - laststep.z));
        if (dist > mindist) {
          steps.push(t);
          laststep = step;
        }
      }
      return steps;
    };
    Spline.prototype.vector = function(t) {
      var p1 = this.pos(t + 10);
      var p2 = this.pos(t - 10);
      return {
        angle: 180 * Math.atan2(p1.y - p2.y, p1.x - p2.x) / 3.14,
        speed: Math.sqrt((p2.x - p1.x) * (p2.x - p1.x) + (p2.y - p1.y) * (p2.y - p1.y) + (p2.z - p1.z) * (p2.z - p1.z))
      };
    };
    Spline.prototype.pos = function(time) {
      function bezier(t3, p1, c1, c2, p2) {
        var B = function(t4) {
          var t22 = t4 * t4, t32 = t22 * t4;
          return [t32, 3 * t22 * (1 - t4), 3 * t4 * (1 - t4) * (1 - t4), (1 - t4) * (1 - t4) * (1 - t4)];
        };
        var b = B(t3);
        var pos = {
          x: p2.x * b[0] + c2.x * b[1] + c1.x * b[2] + p1.x * b[3],
          y: p2.y * b[0] + c2.y * b[1] + c1.y * b[2] + p1.y * b[3],
          z: p2.z * b[0] + c2.z * b[1] + c1.z * b[2] + p1.z * b[3]
        };
        return pos;
      }
      var t = time - this.delay;
      if (t < 0)
        t = 0;
      if (t > this.duration)
        t = this.duration - 1;
      var t2 = t / this.duration;
      if (t2 >= 1)
        return this.points[this.length - 1];
      var n = Math.floor((this.points.length - 1) * t2);
      var t1 = (this.length - 1) * t2 - n;
      return bezier(t1, this.points[n], this.controls[n][1], this.controls[n + 1][0], this.points[n + 1]);
    };
    module.exports = Spline;
  }
});

// node_modules/turf-bezier/index.js
var require_turf_bezier = __commonJS({
  "node_modules/turf-bezier/index.js"(exports, module) {
    var linestring = require_turf_helpers().lineString;
    var Spline = require_spline();
    module.exports = function(line, resolution, sharpness) {
      var lineOut = linestring([]);
      lineOut.properties = line.properties;
      var spline = new Spline({
        points: line.geometry.coordinates.map(function(pt) {
          return { x: pt[0], y: pt[1] };
        }),
        duration: resolution,
        sharpness
      });
      for (var i2 = 0; i2 < spline.duration; i2 += 10) {
        var pos = spline.pos(i2);
        if (Math.floor(i2 / 100) % 2 === 0) {
          lineOut.geometry.coordinates.push([pos.x, pos.y]);
        }
      }
      return lineOut;
    };
  }
});

// node_modules/turf-tag/index.js
var require_turf_tag = __commonJS({
  "node_modules/turf-tag/index.js"(exports, module) {
    var inside = require_turf_inside();
    module.exports = function(points, polygons, field, outField) {
      points = JSON.parse(JSON.stringify(points));
      polygons = JSON.parse(JSON.stringify(polygons));
      points.features.forEach(function(pt) {
        if (!pt.properties) {
          pt.properties = {};
        }
        polygons.features.forEach(function(poly) {
          if (pt.properties[outField] === void 0) {
            var isInside = inside(pt, poly);
            if (isInside) {
              pt.properties[outField] = poly.properties[field];
            }
          }
        });
      });
      return points;
    };
  }
});

// node_modules/turf-sample/index.js
var require_turf_sample = __commonJS({
  "node_modules/turf-sample/index.js"(exports, module) {
    var featureCollection = require_turf_helpers().featureCollection;
    module.exports = function(featurecollection, num) {
      var outFC = featureCollection(getRandomSubarray(featurecollection.features, num));
      return outFC;
    };
    function getRandomSubarray(arr, size) {
      var shuffled = arr.slice(0), i2 = arr.length, min = i2 - size, temp, index;
      while (i2-- > min) {
        index = Math.floor((i2 + 1) * Math.random());
        temp = shuffled[index];
        shuffled[index] = shuffled[i2];
        shuffled[i2] = temp;
      }
      return shuffled.slice(min);
    }
  }
});

// node_modules/turf-bbox-polygon/index.js
var require_turf_bbox_polygon = __commonJS({
  "node_modules/turf-bbox-polygon/index.js"(exports, module) {
    var polygon = require_turf_helpers().polygon;
    module.exports = function(bbox) {
      var lowLeft = [bbox[0], bbox[1]];
      var topLeft = [bbox[0], bbox[3]];
      var topRight = [bbox[2], bbox[3]];
      var lowRight = [bbox[2], bbox[1]];
      return polygon([[
        lowLeft,
        lowRight,
        topRight,
        topLeft,
        lowLeft
      ]]);
    };
  }
});

// node_modules/turf-envelope/index.js
var require_turf_envelope = __commonJS({
  "node_modules/turf-envelope/index.js"(exports, module) {
    var bbox = require_turf_bbox();
    var bboxPolygon = require_turf_bbox_polygon();
    module.exports = function(features) {
      return bboxPolygon(bbox(features));
    };
  }
});

// node_modules/turf-bearing/index.js
var require_turf_bearing = __commonJS({
  "node_modules/turf-bearing/index.js"(exports, module) {
    var getCoord = require_turf_invariant().getCoord;
    module.exports = function(start, end) {
      var degrees2radians = Math.PI / 180;
      var radians2degrees = 180 / Math.PI;
      var coordinates1 = getCoord(start);
      var coordinates2 = getCoord(end);
      var lon1 = degrees2radians * coordinates1[0];
      var lon2 = degrees2radians * coordinates2[0];
      var lat1 = degrees2radians * coordinates1[1];
      var lat2 = degrees2radians * coordinates2[1];
      var a = Math.sin(lon2 - lon1) * Math.cos(lat2);
      var b = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);
      var bearing = radians2degrees * Math.atan2(a, b);
      return bearing;
    };
  }
});

// node_modules/turf-destination/index.js
var require_turf_destination = __commonJS({
  "node_modules/turf-destination/index.js"(exports, module) {
    var getCoord = require_turf_invariant().getCoord;
    var helpers = require_turf_helpers();
    var point = helpers.point;
    var distanceToRadians = helpers.distanceToRadians;
    module.exports = function(from, distance, bearing, units) {
      var degrees2radians = Math.PI / 180;
      var radians2degrees = 180 / Math.PI;
      var coordinates1 = getCoord(from);
      var longitude1 = degrees2radians * coordinates1[0];
      var latitude1 = degrees2radians * coordinates1[1];
      var bearing_rad = degrees2radians * bearing;
      var radians = distanceToRadians(distance, units);
      var latitude2 = Math.asin(Math.sin(latitude1) * Math.cos(radians) + Math.cos(latitude1) * Math.sin(radians) * Math.cos(bearing_rad));
      var longitude2 = longitude1 + Math.atan2(
        Math.sin(bearing_rad) * Math.sin(radians) * Math.cos(latitude1),
        Math.cos(radians) - Math.sin(latitude1) * Math.sin(latitude2)
      );
      return point([radians2degrees * longitude2, radians2degrees * latitude2]);
    };
  }
});

// node_modules/turf-midpoint/index.js
var require_turf_midpoint = __commonJS({
  "node_modules/turf-midpoint/index.js"(exports, module) {
    var bearing = require_turf_bearing();
    var destination = require_turf_destination();
    var distance = require_turf_distance();
    module.exports = function(from, to) {
      var dist = distance(from, to, "miles");
      var heading = bearing(from, to);
      var midpoint = destination(from, dist / 2, heading, "miles");
      return midpoint;
    };
  }
});

// node_modules/geojson-normalize/index.js
var require_geojson_normalize = __commonJS({
  "node_modules/geojson-normalize/index.js"(exports, module) {
    module.exports = normalize;
    var types = {
      Point: "geometry",
      MultiPoint: "geometry",
      LineString: "geometry",
      MultiLineString: "geometry",
      Polygon: "geometry",
      MultiPolygon: "geometry",
      GeometryCollection: "geometry",
      Feature: "feature",
      FeatureCollection: "featurecollection"
    };
    function normalize(gj) {
      if (!gj || !gj.type)
        return null;
      var type = types[gj.type];
      if (!type)
        return null;
      if (type === "geometry") {
        return {
          type: "FeatureCollection",
          features: [{
            type: "Feature",
            properties: {},
            geometry: gj
          }]
        };
      } else if (type === "feature") {
        return {
          type: "FeatureCollection",
          features: [gj]
        };
      } else if (type === "featurecollection") {
        return gj;
      }
    }
  }
});

// node_modules/turf-buffer/index.js
var require_turf_buffer = __commonJS({
  "node_modules/turf-buffer/index.js"(exports, module) {
    var helpers = require_turf_helpers();
    var featureCollection = helpers.featureCollection;
    var jsts = require_jsts_min();
    var normalize = require_geojson_normalize();
    module.exports = function(feature, radius, units) {
      var degrees = helpers.distanceToDegrees(radius, units);
      var fc = normalize(feature);
      var buffered = normalize(featureCollection(fc.features.map(function(f) {
        return bufferOp(f, degrees);
      })));
      if (buffered.features.length > 1)
        return buffered;
      else if (buffered.features.length === 1)
        return buffered.features[0];
    };
    function bufferOp(feature, radius) {
      var reader = new jsts.io.GeoJSONReader();
      var geom = reader.read(feature.geometry);
      var buffered = geom.buffer(radius);
      var writer = new jsts.io.GeoJSONWriter();
      buffered = writer.write(buffered);
      return {
        type: "Feature",
        geometry: buffered,
        properties: {}
      };
    }
  }
});

// node_modules/turf-center/index.js
var require_turf_center = __commonJS({
  "node_modules/turf-center/index.js"(exports, module) {
    var bbox = require_turf_bbox();
    var point = require_turf_helpers().point;
    module.exports = function(layer) {
      var ext = bbox(layer);
      var x = (ext[0] + ext[2]) / 2;
      var y = (ext[1] + ext[3]) / 2;
      return point([x, y]);
    };
  }
});

// node_modules/turf-centroid/index.js
var require_turf_centroid = __commonJS({
  "node_modules/turf-centroid/index.js"(exports, module) {
    var each = require_turf_meta().coordEach;
    var point = require_turf_helpers().point;
    module.exports = function(features) {
      var xSum = 0, ySum = 0, len = 0;
      each(features, function(coord) {
        xSum += coord[0];
        ySum += coord[1];
        len++;
      }, true);
      return point([xSum / len, ySum / len]);
    };
  }
});

// node_modules/turf-combine/index.js
var require_turf_combine = __commonJS({
  "node_modules/turf-combine/index.js"(exports, module) {
    var meta = require_turf_meta();
    module.exports = function(fc) {
      var groups = {
        MultiPoint: { coordinates: [], properties: [] },
        MultiLineString: { coordinates: [], properties: [] },
        MultiPolygon: { coordinates: [], properties: [] }
      };
      var multiMapping = Object.keys(groups).reduce(function(memo, item) {
        memo[item.replace("Multi", "")] = item;
        return memo;
      }, {});
      function addToGroup(feature, key, multi) {
        if (!multi) {
          groups[key].coordinates.push(feature.geometry.coordinates);
        } else {
          groups[key].coordinates = groups[key].coordinates.concat(feature.geometry.coordinates);
        }
        groups[key].properties.push(feature.properties);
      }
      meta.featureEach(fc, function(feature) {
        if (!feature.geometry)
          return;
        if (groups[feature.geometry.type]) {
          addToGroup(feature, feature.geometry.type, true);
        } else if (multiMapping[feature.geometry.type]) {
          addToGroup(feature, multiMapping[feature.geometry.type], false);
        }
      });
      return {
        type: "FeatureCollection",
        features: Object.keys(groups).filter(function(key) {
          return groups[key].coordinates.length;
        }).sort().map(function(key) {
          return {
            type: "Feature",
            properties: {
              collectedProperties: groups[key].properties
            },
            geometry: {
              type: key,
              coordinates: groups[key].coordinates
            }
          };
        })
      };
    };
  }
});

// node_modules/turf-explode/index.js
var require_turf_explode = __commonJS({
  "node_modules/turf-explode/index.js"(exports, module) {
    var featureCollection = require_turf_helpers().featureCollection;
    var each = require_turf_meta().coordEach;
    var point = require_turf_helpers().point;
    module.exports = function(geojson) {
      var points = [];
      each(geojson, function(coord) {
        points.push(point(coord));
      });
      return featureCollection(points);
    };
  }
});

// node_modules/earcut/src/earcut.js
var require_earcut = __commonJS({
  "node_modules/earcut/src/earcut.js"(exports, module) {
    "use strict";
    module.exports = earcut;
    module.exports.default = earcut;
    function earcut(data, holeIndices, dim) {
      dim = dim || 2;
      var hasHoles = holeIndices && holeIndices.length, outerLen = hasHoles ? holeIndices[0] * dim : data.length, outerNode = linkedList(data, 0, outerLen, dim, true), triangles = [];
      if (!outerNode || outerNode.next === outerNode.prev)
        return triangles;
      var minX, minY, maxX, maxY, x, y, invSize;
      if (hasHoles)
        outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
      if (data.length > 80 * dim) {
        minX = maxX = data[0];
        minY = maxY = data[1];
        for (var i2 = dim; i2 < outerLen; i2 += dim) {
          x = data[i2];
          y = data[i2 + 1];
          if (x < minX)
            minX = x;
          if (y < minY)
            minY = y;
          if (x > maxX)
            maxX = x;
          if (y > maxY)
            maxY = y;
        }
        invSize = Math.max(maxX - minX, maxY - minY);
        invSize = invSize !== 0 ? 32767 / invSize : 0;
      }
      earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);
      return triangles;
    }
    function linkedList(data, start, end, dim, clockwise) {
      var i2, last;
      if (clockwise === signedArea(data, start, end, dim) > 0) {
        for (i2 = start; i2 < end; i2 += dim)
          last = insertNode(i2, data[i2], data[i2 + 1], last);
      } else {
        for (i2 = end - dim; i2 >= start; i2 -= dim)
          last = insertNode(i2, data[i2], data[i2 + 1], last);
      }
      if (last && equals(last, last.next)) {
        removeNode(last);
        last = last.next;
      }
      return last;
    }
    function filterPoints(start, end) {
      if (!start)
        return start;
      if (!end)
        end = start;
      var p = start, again;
      do {
        again = false;
        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
          removeNode(p);
          p = end = p.prev;
          if (p === p.next)
            break;
          again = true;
        } else {
          p = p.next;
        }
      } while (again || p !== end);
      return end;
    }
    function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
      if (!ear)
        return;
      if (!pass && invSize)
        indexCurve(ear, minX, minY, invSize);
      var stop = ear, prev, next;
      while (ear.prev !== ear.next) {
        prev = ear.prev;
        next = ear.next;
        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
          triangles.push(prev.i / dim | 0);
          triangles.push(ear.i / dim | 0);
          triangles.push(next.i / dim | 0);
          removeNode(ear);
          ear = next.next;
          stop = next.next;
          continue;
        }
        ear = next;
        if (ear === stop) {
          if (!pass) {
            earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
          } else if (pass === 1) {
            ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
            earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
          } else if (pass === 2) {
            splitEarcut(ear, triangles, dim, minX, minY, invSize);
          }
          break;
        }
      }
    }
    function isEar(ear) {
      var a = ear.prev, b = ear, c = ear.next;
      if (area(a, b, c) >= 0)
        return false;
      var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;
      var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
      var p = c.next;
      while (p !== a) {
        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0)
          return false;
        p = p.next;
      }
      return true;
    }
    function isEarHashed(ear, minX, minY, invSize) {
      var a = ear.prev, b = ear, c = ear.next;
      if (area(a, b, c) >= 0)
        return false;
      var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;
      var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
      var minZ = zOrder(x0, y0, minX, minY, invSize), maxZ = zOrder(x1, y1, minX, minY, invSize);
      var p = ear.prevZ, n = ear.nextZ;
      while (p && p.z >= minZ && n && n.z <= maxZ) {
        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0)
          return false;
        p = p.prevZ;
        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0)
          return false;
        n = n.nextZ;
      }
      while (p && p.z >= minZ) {
        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0)
          return false;
        p = p.prevZ;
      }
      while (n && n.z <= maxZ) {
        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0)
          return false;
        n = n.nextZ;
      }
      return true;
    }
    function cureLocalIntersections(start, triangles, dim) {
      var p = start;
      do {
        var a = p.prev, b = p.next.next;
        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
          triangles.push(a.i / dim | 0);
          triangles.push(p.i / dim | 0);
          triangles.push(b.i / dim | 0);
          removeNode(p);
          removeNode(p.next);
          p = start = b;
        }
        p = p.next;
      } while (p !== start);
      return filterPoints(p);
    }
    function splitEarcut(start, triangles, dim, minX, minY, invSize) {
      var a = start;
      do {
        var b = a.next.next;
        while (b !== a.prev) {
          if (a.i !== b.i && isValidDiagonal(a, b)) {
            var c = splitPolygon(a, b);
            a = filterPoints(a, a.next);
            c = filterPoints(c, c.next);
            earcutLinked(a, triangles, dim, minX, minY, invSize, 0);
            earcutLinked(c, triangles, dim, minX, minY, invSize, 0);
            return;
          }
          b = b.next;
        }
        a = a.next;
      } while (a !== start);
    }
    function eliminateHoles(data, holeIndices, outerNode, dim) {
      var queue = [], i2, len, start, end, list;
      for (i2 = 0, len = holeIndices.length; i2 < len; i2++) {
        start = holeIndices[i2] * dim;
        end = i2 < len - 1 ? holeIndices[i2 + 1] * dim : data.length;
        list = linkedList(data, start, end, dim, false);
        if (list === list.next)
          list.steiner = true;
        queue.push(getLeftmost(list));
      }
      queue.sort(compareX);
      for (i2 = 0; i2 < queue.length; i2++) {
        outerNode = eliminateHole(queue[i2], outerNode);
      }
      return outerNode;
    }
    function compareX(a, b) {
      return a.x - b.x;
    }
    function eliminateHole(hole, outerNode) {
      var bridge = findHoleBridge(hole, outerNode);
      if (!bridge) {
        return outerNode;
      }
      var bridgeReverse = splitPolygon(bridge, hole);
      filterPoints(bridgeReverse, bridgeReverse.next);
      return filterPoints(bridge, bridge.next);
    }
    function findHoleBridge(hole, outerNode) {
      var p = outerNode, hx = hole.x, hy = hole.y, qx = -Infinity, m;
      do {
        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
          var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
          if (x <= hx && x > qx) {
            qx = x;
            m = p.x < p.next.x ? p : p.next;
            if (x === hx)
              return m;
          }
        }
        p = p.next;
      } while (p !== outerNode);
      if (!m)
        return null;
      var stop = m, mx = m.x, my = m.y, tanMin = Infinity, tan;
      p = m;
      do {
        if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
          tan = Math.abs(hy - p.y) / (hx - p.x);
          if (locallyInside(p, hole) && (tan < tanMin || tan === tanMin && (p.x > m.x || p.x === m.x && sectorContainsSector(m, p)))) {
            m = p;
            tanMin = tan;
          }
        }
        p = p.next;
      } while (p !== stop);
      return m;
    }
    function sectorContainsSector(m, p) {
      return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
    }
    function indexCurve(start, minX, minY, invSize) {
      var p = start;
      do {
        if (p.z === 0)
          p.z = zOrder(p.x, p.y, minX, minY, invSize);
        p.prevZ = p.prev;
        p.nextZ = p.next;
        p = p.next;
      } while (p !== start);
      p.prevZ.nextZ = null;
      p.prevZ = null;
      sortLinked(p);
    }
    function sortLinked(list) {
      var i2, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;
      do {
        p = list;
        list = null;
        tail = null;
        numMerges = 0;
        while (p) {
          numMerges++;
          q = p;
          pSize = 0;
          for (i2 = 0; i2 < inSize; i2++) {
            pSize++;
            q = q.nextZ;
            if (!q)
              break;
          }
          qSize = inSize;
          while (pSize > 0 || qSize > 0 && q) {
            if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
              e = p;
              p = p.nextZ;
              pSize--;
            } else {
              e = q;
              q = q.nextZ;
              qSize--;
            }
            if (tail)
              tail.nextZ = e;
            else
              list = e;
            e.prevZ = tail;
            tail = e;
          }
          p = q;
        }
        tail.nextZ = null;
        inSize *= 2;
      } while (numMerges > 1);
      return list;
    }
    function zOrder(x, y, minX, minY, invSize) {
      x = (x - minX) * invSize | 0;
      y = (y - minY) * invSize | 0;
      x = (x | x << 8) & 16711935;
      x = (x | x << 4) & 252645135;
      x = (x | x << 2) & 858993459;
      x = (x | x << 1) & 1431655765;
      y = (y | y << 8) & 16711935;
      y = (y | y << 4) & 252645135;
      y = (y | y << 2) & 858993459;
      y = (y | y << 1) & 1431655765;
      return x | y << 1;
    }
    function getLeftmost(start) {
      var p = start, leftmost = start;
      do {
        if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y)
          leftmost = p;
        p = p.next;
      } while (p !== start);
      return leftmost;
    }
    function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
      return (cx - px) * (ay - py) >= (ax - px) * (cy - py) && (ax - px) * (by - py) >= (bx - px) * (ay - py) && (bx - px) * (cy - py) >= (cx - px) * (by - py);
    }
    function isValidDiagonal(a, b) {
      return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // dones't intersect other edges
      (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible
      (area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors
      equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0);
    }
    function area(p, q, r) {
      return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
    }
    function equals(p1, p2) {
      return p1.x === p2.x && p1.y === p2.y;
    }
    function intersects(p1, q1, p2, q2) {
      var o1 = sign(area(p1, q1, p2));
      var o2 = sign(area(p1, q1, q2));
      var o3 = sign(area(p2, q2, p1));
      var o4 = sign(area(p2, q2, q1));
      if (o1 !== o2 && o3 !== o4)
        return true;
      if (o1 === 0 && onSegment(p1, p2, q1))
        return true;
      if (o2 === 0 && onSegment(p1, q2, q1))
        return true;
      if (o3 === 0 && onSegment(p2, p1, q2))
        return true;
      if (o4 === 0 && onSegment(p2, q1, q2))
        return true;
      return false;
    }
    function onSegment(p, q, r) {
      return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
    }
    function sign(num) {
      return num > 0 ? 1 : num < 0 ? -1 : 0;
    }
    function intersectsPolygon(a, b) {
      var p = a;
      do {
        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b))
          return true;
        p = p.next;
      } while (p !== a);
      return false;
    }
    function locallyInside(a, b) {
      return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
    }
    function middleInside(a, b) {
      var p = a, inside = false, px = (a.x + b.x) / 2, py = (a.y + b.y) / 2;
      do {
        if (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x)
          inside = !inside;
        p = p.next;
      } while (p !== a);
      return inside;
    }
    function splitPolygon(a, b) {
      var a2 = new Node(a.i, a.x, a.y), b2 = new Node(b.i, b.x, b.y), an = a.next, bp = b.prev;
      a.next = b;
      b.prev = a;
      a2.next = an;
      an.prev = a2;
      b2.next = a2;
      a2.prev = b2;
      bp.next = b2;
      b2.prev = bp;
      return b2;
    }
    function insertNode(i2, x, y, last) {
      var p = new Node(i2, x, y);
      if (!last) {
        p.prev = p;
        p.next = p;
      } else {
        p.next = last.next;
        p.prev = last;
        last.next.prev = p;
        last.next = p;
      }
      return p;
    }
    function removeNode(p) {
      p.next.prev = p.prev;
      p.prev.next = p.next;
      if (p.prevZ)
        p.prevZ.nextZ = p.nextZ;
      if (p.nextZ)
        p.nextZ.prevZ = p.prevZ;
    }
    function Node(i2, x, y) {
      this.i = i2;
      this.x = x;
      this.y = y;
      this.prev = null;
      this.next = null;
      this.z = 0;
      this.prevZ = null;
      this.nextZ = null;
      this.steiner = false;
    }
    earcut.deviation = function(data, holeIndices, dim, triangles) {
      var hasHoles = holeIndices && holeIndices.length;
      var outerLen = hasHoles ? holeIndices[0] * dim : data.length;
      var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
      if (hasHoles) {
        for (var i2 = 0, len = holeIndices.length; i2 < len; i2++) {
          var start = holeIndices[i2] * dim;
          var end = i2 < len - 1 ? holeIndices[i2 + 1] * dim : data.length;
          polygonArea -= Math.abs(signedArea(data, start, end, dim));
        }
      }
      var trianglesArea = 0;
      for (i2 = 0; i2 < triangles.length; i2 += 3) {
        var a = triangles[i2] * dim;
        var b = triangles[i2 + 1] * dim;
        var c = triangles[i2 + 2] * dim;
        trianglesArea += Math.abs(
          (data[a] - data[c]) * (data[b + 1] - data[a + 1]) - (data[a] - data[b]) * (data[c + 1] - data[a + 1])
        );
      }
      return polygonArea === 0 && trianglesArea === 0 ? 0 : Math.abs((trianglesArea - polygonArea) / polygonArea);
    };
    function signedArea(data, start, end, dim) {
      var sum = 0;
      for (var i2 = start, j = end - dim; i2 < end; i2 += dim) {
        sum += (data[j] - data[i2]) * (data[i2 + 1] + data[j + 1]);
        j = i2;
      }
      return sum;
    }
    earcut.flatten = function(data) {
      var dim = data[0][0].length, result = { vertices: [], holes: [], dimensions: dim }, holeIndex = 0;
      for (var i2 = 0; i2 < data.length; i2++) {
        for (var j = 0; j < data[i2].length; j++) {
          for (var d = 0; d < dim; d++)
            result.vertices.push(data[i2][j][d]);
        }
        if (i2 > 0) {
          holeIndex += data[i2 - 1].length;
          result.holes.push(holeIndex);
        }
      }
      return result;
    };
  }
});

// node_modules/turf-tesselate/index.js
var require_turf_tesselate = __commonJS({
  "node_modules/turf-tesselate/index.js"(exports, module) {
    var polygon = require_turf_helpers().polygon;
    var earcut = require_earcut();
    module.exports = function(poly) {
      if (!poly.geometry || poly.geometry.type !== "Polygon" && poly.geometry.type !== "MultiPolygon") {
        throw new Error("input must be a Polygon or MultiPolygon");
      }
      var fc = { type: "FeatureCollection", features: [] };
      if (poly.geometry.type === "Polygon") {
        fc.features = processPolygon(poly.geometry.coordinates);
      } else {
        poly.geometry.coordinates.forEach(function(coordinates) {
          fc.features = fc.features.concat(processPolygon(coordinates));
        });
      }
      return fc;
    };
    function processPolygon(coordinates) {
      var data = flattenCoords(coordinates);
      var dim = 2;
      var result = earcut(data.vertices, data.holes, dim);
      var features = [];
      var vertices = [];
      result.forEach(function(vert, i3) {
        var index = result[i3];
        vertices.push([data.vertices[index * dim], data.vertices[index * dim + 1]]);
      });
      for (var i2 = 0; i2 < vertices.length; i2 += 3) {
        var coords = vertices.slice(i2, i2 + 3);
        coords.push(vertices[i2]);
        features.push(polygon([coords]));
      }
      return features;
    }
    function flattenCoords(data) {
      var dim = data[0][0].length, result = { vertices: [], holes: [], dimensions: dim }, holeIndex = 0;
      for (var i2 = 0; i2 < data.length; i2++) {
        for (var j = 0; j < data[i2].length; j++) {
          for (var d = 0; d < dim; d++)
            result.vertices.push(data[i2][j][d]);
        }
        if (i2 > 0) {
          holeIndex += data[i2 - 1].length;
          result.holes.push(holeIndex);
        }
      }
      return result;
    }
  }
});

// node_modules/turf-intersect/index.js
var require_turf_intersect = __commonJS({
  "node_modules/turf-intersect/index.js"(exports, module) {
    var jsts = require_jsts_min();
    module.exports = function intersect(poly1, poly2) {
      var geom1, geom2;
      if (poly1.type === "Feature")
        geom1 = poly1.geometry;
      else
        geom1 = poly1;
      if (poly2.type === "Feature")
        geom2 = poly2.geometry;
      else
        geom2 = poly2;
      var reader = new jsts.io.GeoJSONReader();
      var a = reader.read(JSON.stringify(geom1));
      var b = reader.read(JSON.stringify(geom2));
      var intersection = a.intersection(b);
      if (intersection.isEmpty()) {
        return void 0;
      }
      var writer = new jsts.io.GeoJSONWriter();
      var geojsonGeometry = writer.write(intersection);
      return {
        type: "Feature",
        properties: {},
        geometry: geojsonGeometry
      };
    };
  }
});

// node_modules/turf-nearest/index.js
var require_turf_nearest = __commonJS({
  "node_modules/turf-nearest/index.js"(exports, module) {
    var distance = require_turf_distance();
    module.exports = function(targetPoint, points) {
      var nearestPoint, minDist = Infinity;
      for (var i2 = 0; i2 < points.features.length; i2++) {
        var distanceToPoint = distance(targetPoint, points.features[i2], "miles");
        if (distanceToPoint < minDist) {
          nearestPoint = points.features[i2];
          minDist = distanceToPoint;
        }
      }
      return nearestPoint;
    };
  }
});

// node_modules/geojson-random/index.js
var require_geojson_random = __commonJS({
  "node_modules/geojson-random/index.js"(exports, module) {
    module.exports = function() {
      throw new Error("call .point() or .polygon() instead");
    };
    function position(bbox) {
      if (bbox)
        return coordInBBBOX(bbox);
      else
        return [lon(), lat()];
    }
    module.exports.position = position;
    module.exports.point = function(count, bbox) {
      var features = [];
      for (i = 0; i < count; i++) {
        features.push(feature(bbox ? point(position(bbox)) : point()));
      }
      return collection(features);
    };
    module.exports.polygon = function(count, num_vertices, max_radial_length, bbox) {
      if (typeof num_vertices !== "number")
        num_vertices = 10;
      if (typeof max_radial_length !== "number")
        max_radial_length = 10;
      var features = [];
      for (i = 0; i < count; i++) {
        var vertices = [], circle_offsets = Array.apply(
          null,
          new Array(num_vertices + 1)
        ).map(Math.random);
        circle_offsets.forEach(sumOffsets);
        circle_offsets.forEach(scaleOffsets);
        vertices[vertices.length - 1] = vertices[0];
        vertices = vertices.map(vertexToCoordinate(position(bbox)));
        features.push(feature(polygon([vertices])));
      }
      function sumOffsets(cur, index, arr) {
        arr[index] = index > 0 ? cur + arr[index - 1] : cur;
      }
      function scaleOffsets(cur, index) {
        cur = cur * 2 * Math.PI / circle_offsets[circle_offsets.length - 1];
        var radial_scaler = Math.random();
        vertices.push([
          radial_scaler * max_radial_length * Math.sin(cur),
          radial_scaler * max_radial_length * Math.cos(cur)
        ]);
      }
      return collection(features);
    };
    function vertexToCoordinate(hub) {
      return function(cur, index) {
        return [cur[0] + hub[0], cur[1] + hub[1]];
      };
    }
    function rnd() {
      return Math.random() - 0.5;
    }
    function lon() {
      return rnd() * 360;
    }
    function lat() {
      return rnd() * 180;
    }
    function point(coordinates) {
      return {
        type: "Point",
        coordinates: coordinates || [lon(), lat()]
      };
    }
    function coordInBBBOX(bbox) {
      return [
        Math.random() * (bbox[2] - bbox[0]) + bbox[0],
        Math.random() * (bbox[3] - bbox[1]) + bbox[1]
      ];
    }
    function polygon(coordinates) {
      return {
        type: "Polygon",
        coordinates
      };
    }
    function feature(geom) {
      return {
        type: "Feature",
        geometry: geom,
        properties: {}
      };
    }
    function collection(f) {
      return {
        type: "FeatureCollection",
        features: f
      };
    }
  }
});

// node_modules/turf-random/index.js
var require_turf_random = __commonJS({
  "node_modules/turf-random/index.js"(exports, module) {
    var random = require_geojson_random();
    module.exports = function(type, count, options) {
      options = options || {};
      count = count || 1;
      switch (type) {
        case "point":
        case "points":
        case void 0:
          return random.point(count, options.bbox);
        case "polygon":
        case "polygons":
          return random.polygon(
            count,
            options.num_vertices,
            options.max_radial_length,
            options.bbox
          );
        default:
          throw new Error("Unknown type given: valid options are points and polygons");
      }
    };
  }
});

// node_modules/turf-kinks/index.js
var require_turf_kinks = __commonJS({
  "node_modules/turf-kinks/index.js"(exports, module) {
    var point = require_turf_helpers().point;
    module.exports = function(polyIn) {
      var poly;
      var results = {
        type: "FeatureCollection",
        features: []
      };
      if (polyIn.type === "Feature") {
        poly = polyIn.geometry;
      } else {
        poly = polyIn;
      }
      poly.coordinates.forEach(function(ring1) {
        poly.coordinates.forEach(function(ring2) {
          for (var i2 = 0; i2 < ring1.length - 1; i2++) {
            for (var k = 0; k < ring2.length - 1; k++) {
              if (ring1 === ring2 && (Math.abs(i2 - k) === 1 || Math.abs(i2 - k) === ring1.length - 2)) {
                continue;
              }
              var intersection = lineIntersects(
                ring1[i2][0],
                ring1[i2][1],
                ring1[i2 + 1][0],
                ring1[i2 + 1][1],
                ring2[k][0],
                ring2[k][1],
                ring2[k + 1][0],
                ring2[k + 1][1]
              );
              if (intersection) {
                results.features.push(point([intersection[0], intersection[1]]));
              }
            }
          }
        });
      });
      return results;
    };
    function lineIntersects(line1StartX, line1StartY, line1EndX, line1EndY, line2StartX, line2StartY, line2EndX, line2EndY) {
      var denominator, a, b, numerator1, numerator2, result = {
        x: null,
        y: null,
        onLine1: false,
        onLine2: false
      };
      denominator = (line2EndY - line2StartY) * (line1EndX - line1StartX) - (line2EndX - line2StartX) * (line1EndY - line1StartY);
      if (denominator === 0) {
        if (result.x !== null && result.y !== null) {
          return result;
        } else {
          return false;
        }
      }
      a = line1StartY - line2StartY;
      b = line1StartX - line2StartX;
      numerator1 = (line2EndX - line2StartX) * a - (line2EndY - line2StartY) * b;
      numerator2 = (line1EndX - line1StartX) * a - (line1EndY - line1StartY) * b;
      a = numerator1 / denominator;
      b = numerator2 / denominator;
      result.x = line1StartX + a * (line1EndX - line1StartX);
      result.y = line1StartY + a * (line1EndY - line1StartY);
      if (a >= 0 && a <= 1) {
        result.onLine1 = true;
      }
      if (b >= 0 && b <= 1) {
        result.onLine2 = true;
      }
      if (result.onLine1 && result.onLine2) {
        return [result.x, result.y];
      } else {
        return false;
      }
    }
  }
});

// node_modules/turf-point-on-surface/index.js
var require_turf_point_on_surface = __commonJS({
  "node_modules/turf-point-on-surface/index.js"(exports, module) {
    var featureCollection = require_turf_helpers().featureCollection;
    var centroid = require_turf_center();
    var distance = require_turf_distance();
    var inside = require_turf_inside();
    var explode = require_turf_explode();
    function pointOnSurface(fc) {
      if (fc.type !== "FeatureCollection") {
        if (fc.type !== "Feature") {
          fc = {
            type: "Feature",
            geometry: fc,
            properties: {}
          };
        }
        fc = featureCollection([fc]);
      }
      var cent = centroid(fc);
      var onSurface = false;
      var i2 = 0;
      while (!onSurface && i2 < fc.features.length) {
        var geom = fc.features[i2].geometry;
        var x, y, x1, y1, x2, y2, k;
        var onLine = false;
        if (geom.type === "Point") {
          if (cent.geometry.coordinates[0] === geom.coordinates[0] && cent.geometry.coordinates[1] === geom.coordinates[1]) {
            onSurface = true;
          }
        } else if (geom.type === "MultiPoint") {
          var onMultiPoint = false;
          k = 0;
          while (!onMultiPoint && k < geom.coordinates.length) {
            if (cent.geometry.coordinates[0] === geom.coordinates[k][0] && cent.geometry.coordinates[1] === geom.coordinates[k][1]) {
              onSurface = true;
              onMultiPoint = true;
            }
            k++;
          }
        } else if (geom.type === "LineString") {
          k = 0;
          while (!onLine && k < geom.coordinates.length - 1) {
            x = cent.geometry.coordinates[0];
            y = cent.geometry.coordinates[1];
            x1 = geom.coordinates[k][0];
            y1 = geom.coordinates[k][1];
            x2 = geom.coordinates[k + 1][0];
            y2 = geom.coordinates[k + 1][1];
            if (pointOnSegment(x, y, x1, y1, x2, y2)) {
              onLine = true;
              onSurface = true;
            }
            k++;
          }
        } else if (geom.type === "MultiLineString") {
          var j = 0;
          while (j < geom.coordinates.length) {
            onLine = false;
            k = 0;
            var line = geom.coordinates[j];
            while (!onLine && k < line.length - 1) {
              x = cent.geometry.coordinates[0];
              y = cent.geometry.coordinates[1];
              x1 = line[k][0];
              y1 = line[k][1];
              x2 = line[k + 1][0];
              y2 = line[k + 1][1];
              if (pointOnSegment(x, y, x1, y1, x2, y2)) {
                onLine = true;
                onSurface = true;
              }
              k++;
            }
            j++;
          }
        } else if (geom.type === "Polygon" || geom.type === "MultiPolygon") {
          var f = {
            type: "Feature",
            geometry: geom,
            properties: {}
          };
          if (inside(cent, f)) {
            onSurface = true;
          }
        }
        i2++;
      }
      if (onSurface) {
        return cent;
      } else {
        var vertices = featureCollection([]);
        for (i2 = 0; i2 < fc.features.length; i2++) {
          vertices.features = vertices.features.concat(explode(fc.features[i2]).features);
        }
        var closestVertex;
        var closestDistance = Infinity;
        for (i2 = 0; i2 < vertices.features.length; i2++) {
          var dist = distance(cent, vertices.features[i2], "miles");
          if (dist < closestDistance) {
            closestDistance = dist;
            closestVertex = vertices.features[i2];
          }
        }
        return closestVertex;
      }
    }
    function pointOnSegment(x, y, x1, y1, x2, y2) {
      var ab = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
      var ap = Math.sqrt((x - x1) * (x - x1) + (y - y1) * (y - y1));
      var pb = Math.sqrt((x2 - x) * (x2 - x) + (y2 - y) * (y2 - y));
      if (ab === ap + pb) {
        return true;
      }
    }
    module.exports = pointOnSurface;
  }
});

// node_modules/wgs84/index.js
var require_wgs84 = __commonJS({
  "node_modules/wgs84/index.js"(exports, module) {
    module.exports.RADIUS = 6378137;
    module.exports.FLATTENING = 1 / 298.257223563;
    module.exports.POLAR_RADIUS = 63567523142e-4;
  }
});

// node_modules/geojson-area/index.js
var require_geojson_area = __commonJS({
  "node_modules/geojson-area/index.js"(exports, module) {
    var wgs84 = require_wgs84();
    module.exports.geometry = geometry;
    module.exports.ring = ringArea;
    function geometry(_) {
      var area = 0, i2;
      switch (_.type) {
        case "Polygon":
          return polygonArea(_.coordinates);
        case "MultiPolygon":
          for (i2 = 0; i2 < _.coordinates.length; i2++) {
            area += polygonArea(_.coordinates[i2]);
          }
          return area;
        case "Point":
        case "MultiPoint":
        case "LineString":
        case "MultiLineString":
          return 0;
        case "GeometryCollection":
          for (i2 = 0; i2 < _.geometries.length; i2++) {
            area += geometry(_.geometries[i2]);
          }
          return area;
      }
    }
    function polygonArea(coords) {
      var area = 0;
      if (coords && coords.length > 0) {
        area += Math.abs(ringArea(coords[0]));
        for (var i2 = 1; i2 < coords.length; i2++) {
          area -= Math.abs(ringArea(coords[i2]));
        }
      }
      return area;
    }
    function ringArea(coords) {
      var p1, p2, p3, lowerIndex, middleIndex, upperIndex, area = 0, coordsLength = coords.length;
      if (coordsLength > 2) {
        for (i = 0; i < coordsLength; i++) {
          if (i === coordsLength - 2) {
            lowerIndex = coordsLength - 2;
            middleIndex = coordsLength - 1;
            upperIndex = 0;
          } else if (i === coordsLength - 1) {
            lowerIndex = coordsLength - 1;
            middleIndex = 0;
            upperIndex = 1;
          } else {
            lowerIndex = i;
            middleIndex = i + 1;
            upperIndex = i + 2;
          }
          p1 = coords[lowerIndex];
          p2 = coords[middleIndex];
          p3 = coords[upperIndex];
          area += (rad(p3[0]) - rad(p1[0])) * Math.sin(rad(p2[1]));
        }
        area = area * wgs84.RADIUS * wgs84.RADIUS / 2;
      }
      return area;
    }
    function rad(_) {
      return _ * Math.PI / 180;
    }
  }
});

// node_modules/turf-area/index.js
var require_turf_area = __commonJS({
  "node_modules/turf-area/index.js"(exports, module) {
    var geometryArea = require_geojson_area().geometry;
    function area(input) {
      if (input.type === "FeatureCollection") {
        for (var i2 = 0, sum = 0; i2 < input.features.length; i2++) {
          if (input.features[i2].geometry) {
            sum += geometryArea(input.features[i2].geometry);
          }
        }
        return sum;
      } else if (input.type === "Feature") {
        return geometryArea(input.geometry);
      } else {
        return geometryArea(input);
      }
    }
    module.exports = area;
  }
});

// node_modules/turf-along/index.js
var require_turf_along = __commonJS({
  "node_modules/turf-along/index.js"(exports, module) {
    var measureDistance = require_turf_distance();
    var point = require_turf_helpers().point;
    var bearing = require_turf_bearing();
    var destination = require_turf_destination();
    module.exports = function(line, distance, units) {
      var coords;
      if (line.type === "Feature")
        coords = line.geometry.coordinates;
      else if (line.type === "LineString")
        coords = line.coordinates;
      else
        throw new Error("input must be a LineString Feature or Geometry");
      var travelled = 0;
      for (var i2 = 0; i2 < coords.length; i2++) {
        if (distance >= travelled && i2 === coords.length - 1)
          break;
        else if (travelled >= distance) {
          var overshot = distance - travelled;
          if (!overshot)
            return point(coords[i2]);
          else {
            var direction = bearing(coords[i2], coords[i2 - 1]) - 180;
            var interpolated = destination(coords[i2], overshot, direction, units);
            return interpolated;
          }
        } else {
          travelled += measureDistance(coords[i2], coords[i2 + 1], units);
        }
      }
      return point(coords[coords.length - 1]);
    };
  }
});

// node_modules/turf-line-distance/index.js
var require_turf_line_distance = __commonJS({
  "node_modules/turf-line-distance/index.js"(exports, module) {
    var distance = require_turf_distance();
    var point = require_turf_helpers().point;
    module.exports = function lineDistance(line, units) {
      if (line.type === "FeatureCollection") {
        return line.features.reduce(function(memo, feature) {
          return memo + lineDistance(feature, units);
        }, 0);
      }
      var geometry = line.type === "Feature" ? line.geometry : line;
      var d, i2;
      if (geometry.type === "LineString") {
        return length(geometry.coordinates, units);
      } else if (geometry.type === "Polygon" || geometry.type === "MultiLineString") {
        d = 0;
        for (i2 = 0; i2 < geometry.coordinates.length; i2++) {
          d += length(geometry.coordinates[i2], units);
        }
        return d;
      } else if (line.type === "MultiPolygon") {
        d = 0;
        for (i2 = 0; i2 < geometry.coordinates.length; i2++) {
          for (var j = 0; j < geometry.coordinates[i2].length; j++) {
            d += length(geometry.coordinates[i2][j], units);
          }
        }
        return d;
      } else {
        throw new Error("input must be a LineString, MultiLineString, Polygon, or MultiPolygon Feature or Geometry (or a FeatureCollection containing only those types)");
      }
    };
    function length(coords, units) {
      var travelled = 0;
      var prevCoords = point(coords[0]);
      var curCoords = point(coords[0]);
      var temp;
      for (var i2 = 1; i2 < coords.length; i2++) {
        curCoords.geometry.coordinates = coords[i2];
        travelled += distance(prevCoords, curCoords, units);
        temp = prevCoords;
        prevCoords = curCoords;
        curCoords = temp;
      }
      return travelled;
    }
  }
});

// node_modules/turf-point-on-line/index.js
var require_turf_point_on_line = __commonJS({
  "node_modules/turf-point-on-line/index.js"(exports, module) {
    var distance = require_turf_distance();
    var point = require_turf_helpers().point;
    var bearing = require_turf_bearing();
    var destination = require_turf_destination();
    module.exports = function(line, pt) {
      var coords;
      if (line.type === "Feature") {
        coords = line.geometry.coordinates;
      } else if (line.type === "LineString") {
        coords = line.coordinates;
      } else {
        throw new Error("input must be a LineString Feature or Geometry");
      }
      return pointOnLine(pt, coords);
    };
    function pointOnLine(pt, coords) {
      var units = "miles";
      var closestPt = point([Infinity, Infinity], {
        dist: Infinity
      });
      for (var i2 = 0; i2 < coords.length - 1; i2++) {
        var start = point(coords[i2]);
        var stop = point(coords[i2 + 1]);
        start.properties.dist = distance(pt, start, units);
        stop.properties.dist = distance(pt, stop, units);
        var heightDistance = Math.max(start.properties.dist, stop.properties.dist);
        var direction = bearing(start, stop);
        var perpendicularPt1 = destination(pt, heightDistance, direction + 90, units);
        var perpendicularPt2 = destination(pt, heightDistance, direction - 90, units);
        var intersect = lineIntersects(
          perpendicularPt1.geometry.coordinates[0],
          perpendicularPt1.geometry.coordinates[1],
          perpendicularPt2.geometry.coordinates[0],
          perpendicularPt2.geometry.coordinates[1],
          start.geometry.coordinates[0],
          start.geometry.coordinates[1],
          stop.geometry.coordinates[0],
          stop.geometry.coordinates[1]
        );
        var intersectPt;
        if (intersect) {
          intersectPt = point(intersect);
          intersectPt.properties.dist = distance(pt, intersectPt, units);
        }
        if (start.properties.dist < closestPt.properties.dist) {
          closestPt = start;
          closestPt.properties.index = i2;
        }
        if (stop.properties.dist < closestPt.properties.dist) {
          closestPt = stop;
          closestPt.properties.index = i2;
        }
        if (intersectPt && intersectPt.properties.dist < closestPt.properties.dist) {
          closestPt = intersectPt;
          closestPt.properties.index = i2;
        }
      }
      return closestPt;
    }
    function lineIntersects(line1StartX, line1StartY, line1EndX, line1EndY, line2StartX, line2StartY, line2EndX, line2EndY) {
      var denominator, a, b, numerator1, numerator2;
      var result = {
        x: null,
        y: null,
        onLine1: false,
        onLine2: false
      };
      denominator = (line2EndY - line2StartY) * (line1EndX - line1StartX) - (line2EndX - line2StartX) * (line1EndY - line1StartY);
      if (denominator === 0) {
        if (result.x !== null && result.y !== null) {
          return result;
        } else {
          return false;
        }
      }
      a = line1StartY - line2StartY;
      b = line1StartX - line2StartX;
      numerator1 = (line2EndX - line2StartX) * a - (line2EndY - line2StartY) * b;
      numerator2 = (line1EndX - line1StartX) * a - (line1EndY - line1StartY) * b;
      a = numerator1 / denominator;
      b = numerator2 / denominator;
      result.x = line1StartX + a * (line1EndX - line1StartX);
      result.y = line1StartY + a * (line1EndY - line1StartY);
      if (a > 0 && a < 1) {
        result.onLine1 = true;
      }
      if (b > 0 && b < 1) {
        result.onLine2 = true;
      }
      if (result.onLine1 && result.onLine2) {
        return [result.x, result.y];
      } else {
        return false;
      }
    }
  }
});

// node_modules/turf-line-slice/index.js
var require_turf_line_slice = __commonJS({
  "node_modules/turf-line-slice/index.js"(exports, module) {
    var linestring = require_turf_helpers().lineString;
    var pointOnLine = require_turf_point_on_line();
    module.exports = function lineSlice(startPt, stopPt, line) {
      var coords;
      if (line.type === "Feature") {
        coords = line.geometry.coordinates;
      } else if (line.type === "LineString") {
        coords = line.coordinates;
      } else {
        throw new Error("input must be a LineString Feature or Geometry");
      }
      var startVertex = pointOnLine(line, startPt);
      var stopVertex = pointOnLine(line, stopPt);
      var ends;
      if (startVertex.properties.index <= stopVertex.properties.index) {
        ends = [startVertex, stopVertex];
      } else {
        ends = [stopVertex, startVertex];
      }
      var clipLine = linestring([ends[0].geometry.coordinates], {});
      for (var i2 = ends[0].properties.index + 1; i2 < ends[1].properties.index + 1; i2++) {
        clipLine.geometry.coordinates.push(coords[i2]);
      }
      clipLine.geometry.coordinates.push(ends[1].geometry.coordinates);
      return clipLine;
    };
  }
});

// node_modules/turf-point-grid/index.js
var require_turf_point_grid = __commonJS({
  "node_modules/turf-point-grid/index.js"(exports, module) {
    var point = require_turf_helpers().point;
    var featurecollection = require_turf_helpers().featureCollection;
    var distance = require_turf_distance();
    module.exports = function pointGrid(bbox, cellSize, units) {
      var fc = featurecollection([]);
      var xFraction = cellSize / distance(point([bbox[0], bbox[1]]), point([bbox[2], bbox[1]]), units);
      var cellWidth = xFraction * (bbox[2] - bbox[0]);
      var yFraction = cellSize / distance(point([bbox[0], bbox[1]]), point([bbox[0], bbox[3]]), units);
      var cellHeight = yFraction * (bbox[3] - bbox[1]);
      var currentX = bbox[0];
      while (currentX <= bbox[2]) {
        var currentY = bbox[1];
        while (currentY <= bbox[3]) {
          fc.features.push(point([currentX, currentY]));
          currentY += cellHeight;
        }
        currentX += cellWidth;
      }
      return fc;
    };
  }
});

// node_modules/turf-square-grid/index.js
var require_turf_square_grid = __commonJS({
  "node_modules/turf-square-grid/index.js"(exports, module) {
    var featurecollection = require_turf_helpers().featureCollection;
    var point = require_turf_helpers().point;
    var polygon = require_turf_helpers().polygon;
    var distance = require_turf_distance();
    module.exports = function squareGrid(bbox, cellSize, units) {
      var fc = featurecollection([]);
      var xFraction = cellSize / distance(point([bbox[0], bbox[1]]), point([bbox[2], bbox[1]]), units);
      var cellWidth = xFraction * (bbox[2] - bbox[0]);
      var yFraction = cellSize / distance(point([bbox[0], bbox[1]]), point([bbox[0], bbox[3]]), units);
      var cellHeight = yFraction * (bbox[3] - bbox[1]);
      var currentX = bbox[0];
      while (currentX <= bbox[2]) {
        var currentY = bbox[1];
        while (currentY <= bbox[3]) {
          var cellPoly = polygon([[
            [currentX, currentY],
            [currentX, currentY + cellHeight],
            [currentX + cellWidth, currentY + cellHeight],
            [currentX + cellWidth, currentY],
            [currentX, currentY]
          ]]);
          fc.features.push(cellPoly);
          currentY += cellHeight;
        }
        currentX += cellWidth;
      }
      return fc;
    };
  }
});

// node_modules/turf-triangle-grid/index.js
var require_turf_triangle_grid = __commonJS({
  "node_modules/turf-triangle-grid/index.js"(exports, module) {
    var featurecollection = require_turf_helpers().featureCollection;
    var polygon = require_turf_helpers().polygon;
    var distance = require_turf_distance();
    module.exports = function(bbox, cellSize, units) {
      var fc = featurecollection([]);
      var xFraction = cellSize / distance([bbox[0], bbox[1]], [bbox[2], bbox[1]], units);
      var cellWidth = xFraction * (bbox[2] - bbox[0]);
      var yFraction = cellSize / distance([bbox[0], bbox[1]], [bbox[0], bbox[3]], units);
      var cellHeight = yFraction * (bbox[3] - bbox[1]);
      var xi = 0;
      var currentX = bbox[0];
      while (currentX <= bbox[2]) {
        var yi = 0;
        var currentY = bbox[1];
        while (currentY <= bbox[3]) {
          if (xi % 2 === 0 && yi % 2 === 0) {
            fc.features.push(polygon([[
              [currentX, currentY],
              [currentX, currentY + cellHeight],
              [currentX + cellWidth, currentY],
              [currentX, currentY]
            ]]), polygon([[
              [currentX, currentY + cellHeight],
              [currentX + cellWidth, currentY + cellHeight],
              [currentX + cellWidth, currentY],
              [currentX, currentY + cellHeight]
            ]]));
          } else if (xi % 2 === 0 && yi % 2 === 1) {
            fc.features.push(polygon([[
              [currentX, currentY],
              [currentX + cellWidth, currentY + cellHeight],
              [currentX + cellWidth, currentY],
              [currentX, currentY]
            ]]), polygon([[
              [currentX, currentY],
              [currentX, currentY + cellHeight],
              [currentX + cellWidth, currentY + cellHeight],
              [currentX, currentY]
            ]]));
          } else if (yi % 2 === 0 && xi % 2 === 1) {
            fc.features.push(polygon([[
              [currentX, currentY],
              [currentX, currentY + cellHeight],
              [currentX + cellWidth, currentY + cellHeight],
              [currentX, currentY]
            ]]), polygon([[
              [currentX, currentY],
              [currentX + cellWidth, currentY + cellHeight],
              [currentX + cellWidth, currentY],
              [currentX, currentY]
            ]]));
          } else if (yi % 2 === 1 && xi % 2 === 1) {
            fc.features.push(polygon([[
              [currentX, currentY],
              [currentX, currentY + cellHeight],
              [currentX + cellWidth, currentY],
              [currentX, currentY]
            ]]), polygon([[
              [currentX, currentY + cellHeight],
              [currentX + cellWidth, currentY + cellHeight],
              [currentX + cellWidth, currentY],
              [currentX, currentY + cellHeight]
            ]]));
          }
          currentY += cellHeight;
          yi++;
        }
        xi++;
        currentX += cellWidth;
      }
      return fc;
    };
  }
});

// node_modules/turf-hex-grid/index.js
var require_turf_hex_grid = __commonJS({
  "node_modules/turf-hex-grid/index.js"(exports, module) {
    var point = require_turf_helpers().point;
    var polygon = require_turf_helpers().polygon;
    var distance = require_turf_distance();
    var featurecollection = require_turf_helpers().featureCollection;
    var cosines = [];
    var sines = [];
    for (i2 = 0; i2 < 6; i2++) {
      angle = 2 * Math.PI / 6 * i2;
      cosines.push(Math.cos(angle));
      sines.push(Math.sin(angle));
    }
    var angle;
    var i2;
    module.exports = function hexGrid(bbox, cellSize, units, triangles) {
      var xFraction = cellSize / distance(point([bbox[0], bbox[1]]), point([bbox[2], bbox[1]]), units);
      var cellWidth = xFraction * (bbox[2] - bbox[0]);
      var yFraction = cellSize / distance(point([bbox[0], bbox[1]]), point([bbox[0], bbox[3]]), units);
      var cellHeight = yFraction * (bbox[3] - bbox[1]);
      var radius = cellWidth / 2;
      var hex_width = radius * 2;
      var hex_height = Math.sqrt(3) / 2 * cellHeight;
      var box_width = bbox[2] - bbox[0];
      var box_height = bbox[3] - bbox[1];
      var x_interval = 3 / 4 * hex_width;
      var y_interval = hex_height;
      var x_span = box_width / (hex_width - radius / 2);
      var x_count = Math.ceil(x_span);
      if (Math.round(x_span) === x_count) {
        x_count++;
      }
      var x_adjust = (x_count * x_interval - radius / 2 - box_width) / 2 - radius / 2;
      var y_count = Math.ceil(box_height / hex_height);
      var y_adjust = (box_height - y_count * hex_height) / 2;
      var hasOffsetY = y_count * hex_height - box_height > hex_height / 2;
      if (hasOffsetY) {
        y_adjust -= hex_height / 4;
      }
      var fc = featurecollection([]);
      for (var x = 0; x < x_count; x++) {
        for (var y = 0; y <= y_count; y++) {
          var isOdd = x % 2 === 1;
          if (y === 0 && isOdd) {
            continue;
          }
          if (y === 0 && hasOffsetY) {
            continue;
          }
          var center_x = x * x_interval + bbox[0] - x_adjust;
          var center_y = y * y_interval + bbox[1] + y_adjust;
          if (isOdd) {
            center_y -= hex_height / 2;
          }
          if (triangles) {
            fc.features.push.apply(fc.features, hexTriangles([center_x, center_y], cellWidth / 2, cellHeight / 2));
          } else {
            fc.features.push(hexagon([center_x, center_y], cellWidth / 2, cellHeight / 2));
          }
        }
      }
      return fc;
    };
    function hexagon(center, rx, ry) {
      var vertices = [];
      for (var i3 = 0; i3 < 6; i3++) {
        var x = center[0] + rx * cosines[i3];
        var y = center[1] + ry * sines[i3];
        vertices.push([x, y]);
      }
      vertices.push(vertices[0]);
      return polygon([vertices]);
    }
    function hexTriangles(center, rx, ry) {
      var triangles = [];
      for (var i3 = 0; i3 < 6; i3++) {
        var vertices = [];
        vertices.push(center);
        vertices.push([
          center[0] + rx * cosines[i3],
          center[1] + ry * sines[i3]
        ]);
        vertices.push([
          center[0] + rx * cosines[(i3 + 1) % 6],
          center[1] + ry * sines[(i3 + 1) % 6]
        ]);
        vertices.push(center);
        triangles.push(polygon([vertices]));
      }
      return triangles;
    }
  }
});

// node_modules/turf/index.js
var require_turf = __commonJS({
  "node_modules/turf/index.js"(exports, module) {
    module.exports = {
      isolines: require_turf_isolines(),
      convex: require_turf_convex(),
      within: require_turf_within(),
      concave: require_turf_concave(),
      difference: require_turf_difference(),
      collect: require_turf_collect(),
      flip: require_turf_flip(),
      simplify: require_turf_simplify(),
      bezier: require_turf_bezier(),
      tag: require_turf_tag(),
      sample: require_turf_sample(),
      envelope: require_turf_envelope(),
      square: require_turf_square(),
      midpoint: require_turf_midpoint(),
      buffer: require_turf_buffer(),
      center: require_turf_center(),
      centroid: require_turf_centroid(),
      combine: require_turf_combine(),
      distance: require_turf_distance(),
      explode: require_turf_explode(),
      bbox: require_turf_bbox(),
      tesselate: require_turf_tesselate(),
      bboxPolygon: require_turf_bbox_polygon(),
      inside: require_turf_inside(),
      intersect: require_turf_intersect(),
      nearest: require_turf_nearest(),
      planepoint: require_turf_planepoint(),
      random: require_turf_random(),
      tin: require_turf_tin(),
      union: require_turf_union(),
      bearing: require_turf_bearing(),
      destination: require_turf_destination(),
      kinks: require_turf_kinks(),
      pointOnSurface: require_turf_point_on_surface(),
      area: require_turf_area(),
      along: require_turf_along(),
      lineDistance: require_turf_line_distance(),
      lineSlice: require_turf_line_slice(),
      pointOnLine: require_turf_point_on_line(),
      pointGrid: require_turf_point_grid(),
      squareGrid: require_turf_square_grid(),
      triangleGrid: require_turf_triangle_grid(),
      hexGrid: require_turf_hex_grid()
    };
    var helpers = require_turf_helpers();
    module.exports.point = helpers.point;
    module.exports.polygon = helpers.polygon;
    module.exports.lineString = helpers.lineString;
    module.exports.multiPoint = helpers.multiPoint;
    module.exports.multiPolygon = helpers.multiPolygon;
    module.exports.multiLineString = helpers.multiLineString;
    module.exports.feature = helpers.feature;
    module.exports.featureCollection = helpers.featureCollection;
    module.exports.geometryCollection = helpers.geometryCollection;
  }
});
export default require_turf();
//# sourceMappingURL=turf.js.map
